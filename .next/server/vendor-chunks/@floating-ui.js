"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n    const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const isVertical = sideAxis === \"y\";\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < validMiddleware.length; i++){\n        const { name, fn } = validMiddleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = state;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n        x,\n        y,\n        width: rects.floating.width,\n        height: rects.floating.height\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n        x: 1,\n        y: 1\n    } : {\n        x: 1,\n        y: 1\n    };\n    const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        elements,\n        rect,\n        offsetParent,\n        strategy\n    }) : rect);\n    return {\n        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (state) {\n            const { x, y, placement, rects, platform, elements, middlewareData } = state;\n            // Since `element` is required, we don't Partial<> the type.\n            const { element, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n            if (element == null) {\n                return {};\n            }\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n            const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const isYAxis = axis === \"y\";\n            const minProp = isYAxis ? \"top\" : \"left\";\n            const maxProp = isYAxis ? \"bottom\" : \"right\";\n            const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n            // DOM platform can return `window` as the `offsetParent`.\n            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2;\n            // If the padding is large enough that it causes the arrow to no longer be\n            // centered, modify the padding so that it is centered.\n            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n            const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n            const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n            // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds.\n            const min$1 = minPadding;\n            const max = clientSize - arrowDimensions[length] - maxPadding;\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n            // If the reference is small enough that the arrow's padding causes it to\n            // to point to nothing for an aligned placement, adjust the offset of the\n            // floating element itself. To ensure `shift()` continues to take action,\n            // a single reset is performed when this is true.\n            const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n            return {\n                [axis]: coords[axis] + alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset - alignmentOffset,\n                    ...shouldAddOffset && {\n                        alignmentOffset\n                    }\n                },\n                reset: shouldAddOffset\n            };\n        }\n    });\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (state) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n            const { rects, middlewareData, placement, platform, elements } = state;\n            const { crossAxis = false, alignment, allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements, autoAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n            const currentPlacement = placements$1[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n            // Make `computeCoords` start from the right place.\n            if (placement !== currentPlacement) {\n                return {\n                    reset: {\n                        placement: placements$1[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)],\n                overflow[alignmentSides[0]],\n                overflow[alignmentSides[1]]\n            ];\n            const allOverflows = [\n                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements$1[currentIndex + 1];\n            // There are more placements to check.\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByMostSpace = allOverflows.map((d)=>{\n                const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n                return [\n                    d.placement,\n                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.\n                    d.overflows[0],\n                    d.overflows\n                ];\n            }).sort((a, b)=>a[1] - b[1]);\n            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));\n            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (state) {\n            var _middlewareData$arrow, _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", fallbackAxisSideDirection = \"none\", flipAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            // If a reset by the arrow was caused due to an alignment offset being\n            // added, we should skip any logic now since `flip()` has already done its\n            // work.\n            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const initialSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(initialPlacement);\n            const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)\n            ] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n            const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n                fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n            }\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ];\n            // One or more sides is overflowing.\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip2, _overflowsData$filter;\n                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    const ignoreCrossAxisOverflow = checkCrossAxis === \"alignment\" ? initialSideAxis !== (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(nextPlacement) : false;\n                    if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis\n                    // overflows the main axis.\n                    overflowsData.every((d)=>d.overflows[0] > 0 && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement) === initialSideAxis)) {\n                        // Try next placement and re-run the lifecycle.\n                        return {\n                            data: {\n                                index: nextIndex,\n                                overflows: overflowsData\n                            },\n                            reset: {\n                                placement: nextPlacement\n                            }\n                        };\n                    }\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) {\n                    switch(fallbackStrategy){\n                        case \"bestFit\":\n                            {\n                                var _overflowsData$filter2;\n                                const placement = (_overflowsData$filter2 = overflowsData.filter((d)=>{\n                                    if (hasFallbackAxisSideDirection) {\n                                        const currentSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement);\n                                        return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                                        // reading directions favoring greater width.\n                                        currentSideAxis === \"y\";\n                                    }\n                                    return true;\n                                }).map((d)=>[\n                                        d.placement,\n                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                                if (placement) {\n                                    resetPlacement = placement;\n                                }\n                                break;\n                            }\n                        case \"initialPlacement\":\n                            resetPlacement = initialPlacement;\n                            break;\n                    }\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options,\n        async fn (state) {\n            const { rects } = state;\n            const { strategy = \"referenceHidden\", ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.left));\n    const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.top));\n    const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.right));\n    const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.bottom));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for(let i = 0; i < sortedRects.length; i++){\n        const rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map((rect)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (state) {\n            const { placement, elements, rects, platform, strategy } = state;\n            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n            const clientRects = getRectsByLine(nativeClientRects);\n            const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    // Find the first rect in which the point is fully inside.\n                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n                }\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                    if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"left\";\n                    const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map((rect)=>rect.right));\n                    const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\nconst originSides = /*#__PURE__*/ new Set([\n    \"left\",\n    \"top\"\n]);\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n    const { placement, platform, elements } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n    const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n    const mainAxisMulti = originSides.has(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    // eslint-disable-next-line prefer-const\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: rawValue.mainAxis || 0,\n        crossAxis: rawValue.crossAxis || 0,\n        alignmentAxis: rawValue.alignmentAxis\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options,\n        async fn (state) {\n            var _middlewareData$offse, _middlewareData$arrow;\n            const { x, y, placement, middlewareData } = state;\n            const diffCoords = await convertValueToCoords(state, options);\n            // If the placement is the same and the arrow caused an alignment offset\n            // then we don't need to change the positioning coordinates.\n            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: {\n                    ...diffCoords,\n                    placement\n                }\n            };\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (state) {\n            const { x, y, placement } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...state,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y,\n                    enabled: {\n                        [mainAxis]: checkMainAxis,\n                        [crossAxis]: checkCrossAxis\n                    }\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (state) {\n            const { x, y, placement, rects, middlewareData } = state;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = originSides.has((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (state) {\n            var _state$middlewareData, _state$middlewareData2;\n            const { placement, rects, platform, elements } = state;\n            const { apply = ()=>{}, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n            const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n            const { width, height } = rects.floating;\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const maximumClippingHeight = height - overflow.top - overflow.bottom;\n            const maximumClippingWidth = width - overflow.left - overflow.right;\n            const overflowAvailableHeight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(height - overflow[heightSide], maximumClippingHeight);\n            const overflowAvailableWidth = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(width - overflow[widthSide], maximumClippingWidth);\n            const noShift = !state.middlewareData.shift;\n            let availableHeight = overflowAvailableHeight;\n            let availableWidth = overflowAvailableWidth;\n            if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n                availableWidth = maximumClippingWidth;\n            }\n            if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n                availableHeight = maximumClippingHeight;\n            }\n            if (noShift && !alignment) {\n                const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n                const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n                const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n                const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n                if (isYAxis) {\n                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n                } else {\n                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n                }\n            }\n            await apply({\n                ...state,\n                availableWidth,\n                availableHeight\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwyQkFBMkJDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHO0lBQ3RELElBQUksRUFDRkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1QsR0FBR0o7SUFDSixNQUFNSyxXQUFXekIsK0RBQVdBLENBQUNxQjtJQUM3QixNQUFNSyxnQkFBZ0J6QixvRUFBZ0JBLENBQUNvQjtJQUN2QyxNQUFNTSxjQUFjekIsaUVBQWFBLENBQUN3QjtJQUNsQyxNQUFNRSxPQUFPekIsMkRBQU9BLENBQUNrQjtJQUNyQixNQUFNUSxhQUFhSixhQUFhO0lBQ2hDLE1BQU1LLFVBQVVQLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSyxHQUFHLElBQUlSLFNBQVNRLEtBQUssR0FBRztJQUNyRSxNQUFNQyxVQUFVVixVQUFVVyxDQUFDLEdBQUdYLFVBQVVZLE1BQU0sR0FBRyxJQUFJWCxTQUFTVyxNQUFNLEdBQUc7SUFDdkUsTUFBTUMsY0FBY2IsU0FBUyxDQUFDSSxZQUFZLEdBQUcsSUFBSUgsUUFBUSxDQUFDRyxZQUFZLEdBQUc7SUFDekUsSUFBSVU7SUFDSixPQUFRVDtRQUNOLEtBQUs7WUFDSFMsU0FBUztnQkFDUE4sR0FBR0Q7Z0JBQ0hJLEdBQUdYLFVBQVVXLENBQUMsR0FBR1YsU0FBU1csTUFBTTtZQUNsQztZQUNBO1FBQ0YsS0FBSztZQUNIRSxTQUFTO2dCQUNQTixHQUFHRDtnQkFDSEksR0FBR1gsVUFBVVcsQ0FBQyxHQUFHWCxVQUFVWSxNQUFNO1lBQ25DO1lBQ0E7UUFDRixLQUFLO1lBQ0hFLFNBQVM7Z0JBQ1BOLEdBQUdSLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSztnQkFDaENFLEdBQUdEO1lBQ0w7WUFDQTtRQUNGLEtBQUs7WUFDSEksU0FBUztnQkFDUE4sR0FB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TTtnQkFDNUc7WUFDRjtZQUNBLE1BQU1pSixNQUFNO2dCQUNWLEdBQUd6SyxLQUFLO2dCQUNSa0w7Z0JBQ0FEO1lBQ0Y7WUFDQSxNQUFNTSxpQkFBaUIsTUFBTTVNLFNBQVNtRCxhQUFhLENBQUNoQyxTQUFTckMsUUFBUTtZQUNyRSxJQUFJUSxVQUFVc04sZUFBZXROLEtBQUssSUFBSUcsV0FBV21OLGVBQWVuTixNQUFNLEVBQUU7Z0JBQ3RFLE9BQU87b0JBQ0x3QixPQUFPO3dCQUNMWixPQUFPO29CQUNUO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZ3QtY2xpbmljLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5tanM/NTZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTaWRlQXhpcywgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QXhpc0xlbmd0aCwgZ2V0U2lkZSwgZ2V0QWxpZ25tZW50LCBldmFsdWF0ZSwgZ2V0UGFkZGluZ09iamVjdCwgcmVjdFRvQ2xpZW50UmVjdCwgbWluLCBjbGFtcCwgcGxhY2VtZW50cywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBzaWRlcywgbWF4LCBnZXRPcHBvc2l0ZUF4aXMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuZXhwb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5cbmZ1bmN0aW9uIGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KF9yZWYsIHBsYWNlbWVudCwgcnRsKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzaWRlQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWduTGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IHNpZGVBeGlzID09PSAneSc7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgY29tbW9uQWxpZ24gPSByZWZlcmVuY2VbYWxpZ25MZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2FsaWduTGVuZ3RoXSAvIDI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGV4cG9ydCBkb2VzIG5vdCBoYXZlIGFueSBgcGxhdGZvcm1gIGludGVyZmFjZSBsb2dpYy4gWW91IHdpbGwgbmVlZCB0b1xuICogd3JpdGUgb25lIGZvciB0aGUgcGxhdGZvcm0geW91IGFyZSB1c2luZyBGbG9hdGluZyBVSSB3aXRoLlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSB2YWxpZE1pZGRsZXdhcmVbaV07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4ID0gbmV4dFggIT0gbnVsbCA/IG5leHRYIDogeDtcbiAgICB5ID0gbmV4dFkgIT0gbnVsbCA/IG5leHRZIDogeTtcbiAgICBtaWRkbGV3YXJlRGF0YSA9IHtcbiAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2F3YWl0JHBsYXRmb3JtJGlzRWxlO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlO1xuICBjb25zdCB7XG4gICAgYm91bmRhcnkgPSAnY2xpcHBpbmdBbmNlc3RvcnMnLFxuICAgIHJvb3RCb3VuZGFyeSA9ICd2aWV3cG9ydCcsXG4gICAgZWxlbWVudENvbnRleHQgPSAnZmxvYXRpbmcnLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/ICdyZWZlcmVuY2UnIDogJ2Zsb2F0aW5nJztcbiAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChhd2FpdCBwbGF0Zm9ybS5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0gYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGVsZW1lbnQpKSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKGF3YWl0IChwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpO1xuICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3RzLmZsb2F0aW5nLmhlaWdodFxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IGNlbnRlciAtIG1pbiQxIDogY2VudGVyIC0gbWF4IDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gKyBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgICAgLi4uKHNob3VsZEFkZE9mZnNldCAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzZXQ6IHNob3VsZEFkZE9mZnNldFxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGFycm93LCBfbWlkZGxld2FyZURhdGEkZmxpcDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9ICdub25lJyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAgICAgLy8gSWYgYSByZXNldCBieSB0aGUgYXJyb3cgd2FzIGNhdXNlZCBkdWUgdG8gYW4gYWxpZ25tZW50IG9mZnNldCBiZWluZ1xuICAgICAgLy8gYWRkZWQsIHdlIHNob3VsZCBza2lwIGFueSBsb2dpYyBub3cgc2luY2UgYGZsaXAoKWAgaGFzIGFscmVhZHkgZG9uZSBpdHNcbiAgICAgIC8vIHdvcmsuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI1NDkjaXNzdWVjb21tZW50LTE3MTk2MDE2NDNcbiAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaW5pdGlhbFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoaW5pdGlhbFBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZSc7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nLlxuICAgICAgaWYgKCFvdmVyZmxvd3MuZXZlcnkoc2lkZSA9PiBzaWRlIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIGNvbnN0IGlnbm9yZUNyb3NzQXhpc092ZXJmbG93ID0gY2hlY2tDcm9zc0F4aXMgPT09ICdhbGlnbm1lbnQnID8gaW5pdGlhbFNpZGVBeGlzICE9PSBnZXRTaWRlQXhpcyhuZXh0UGxhY2VtZW50KSA6IGZhbHNlO1xuICAgICAgICAgIGlmICghaWdub3JlQ3Jvc3NBeGlzT3ZlcmZsb3cgfHxcbiAgICAgICAgICAvLyBXZSBsZWF2ZSB0aGUgY3VycmVudCBtYWluIGF4aXMgb25seSBpZiBldmVyeSBwbGFjZW1lbnQgb24gdGhhdCBheGlzXG4gICAgICAgICAgLy8gb3ZlcmZsb3dzIHRoZSBtYWluIGF4aXMuXG4gICAgICAgICAgb3ZlcmZsb3dzRGF0YS5ldmVyeShkID0+IGQub3ZlcmZsb3dzWzBdID4gMCAmJiBnZXRTaWRlQXhpcyhkLnBsYWNlbWVudCkgPT09IGluaXRpYWxTaWRlQXhpcykpIHtcbiAgICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGUuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2FuZGlkYXRlcyB0aGF0IGZpdCBvbiB0aGUgbWFpbkF4aXMgc2lkZSBvZiBvdmVyZmxvdyxcbiAgICAgICAgLy8gdGhlbiBmaW5kIHRoZSBwbGFjZW1lbnQgdGhhdCBmaXRzIHRoZSBiZXN0IG9uIHRoZSBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBsZXQgcmVzZXRQbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiBkLm92ZXJmbG93c1swXSA8PSAwKS5zb3J0KChhLCBiKSA9PiBhLm92ZXJmbG93c1sxXSAtIGIub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlci5wbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZhbGxiYWNrLlxuICAgICAgICBpZiAoIXJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlICdiZXN0Rml0JzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhkLnBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2lkZUF4aXMgPT09IGluaXRpYWxTaWRlQXhpcyB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBiaWFzIHRvIHRoZSBgeWAgc2lkZSBheGlzIGR1ZSB0byBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRpbmcgZGlyZWN0aW9ucyBmYXZvcmluZyBncmVhdGVyIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2lkZUF4aXMgPT09ICd5JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLm1hcChkID0+IFtkLnBsYWNlbWVudCwgZC5vdmVyZmxvd3MuZmlsdGVyKG92ZXJmbG93ID0+IG92ZXJmbG93ID4gMCkucmVkdWNlKChhY2MsIG92ZXJmbG93KSA9PiBhY2MgKyBvdmVyZmxvdywgMCldKS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbFBsYWNlbWVudCc6XG4gICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aFxuICB9O1xufVxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBzaWRlcy5zb21lKHNpZGUgPT4gb3ZlcmZsb3dbc2lkZV0gPj0gMCk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaGlkZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHJhdGVneSA9ICdyZWZlcmVuY2VIaWRkZW4nLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgIGNhc2UgJ3JlZmVyZW5jZUhpZGRlbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW46IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZXNjYXBlZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMuZmxvYXRpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGVzY2FwZWRPZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIGVzY2FwZWQ6IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdChyZWN0cykge1xuICBjb25zdCBtaW5YID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICBjb25zdCBtaW5ZID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QudG9wKSk7XG4gIGNvbnN0IG1heFggPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICBjb25zdCBtYXhZID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QuYm90dG9tKSk7XG4gIHJldHVybiB7XG4gICAgeDogbWluWCxcbiAgICB5OiBtaW5ZLFxuICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZWN0c0J5TGluZShyZWN0cykge1xuICBjb25zdCBzb3J0ZWRSZWN0cyA9IHJlY3RzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcbiAgY29uc3QgZ3JvdXBzID0gW107XG4gIGxldCBwcmV2UmVjdCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkUmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByZWN0ID0gc29ydGVkUmVjdHNbaV07XG4gICAgaWYgKCFwcmV2UmVjdCB8fCByZWN0LnkgLSBwcmV2UmVjdC55ID4gcHJldlJlY3QuaGVpZ2h0IC8gMikge1xuICAgICAgZ3JvdXBzLnB1c2goW3JlY3RdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBzW2dyb3Vwcy5sZW5ndGggLSAxXS5wdXNoKHJlY3QpO1xuICAgIH1cbiAgICBwcmV2UmVjdCA9IHJlY3Q7XG4gIH1cbiAgcmV0dXJuIGdyb3Vwcy5tYXAocmVjdCA9PiByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChyZWN0KSkpO1xufVxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdpbmxpbmUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgLy8gQSBNb3VzZUV2ZW50J3MgY2xpZW50e1gsWX0gY29vcmRzIGNhbiBiZSB1cCB0byAyIHBpeGVscyBvZmYgYVxuICAgICAgLy8gQ2xpZW50UmVjdCdzIGJvdW5kcywgZGVzcGl0ZSB0aGUgZXZlbnQgbGlzdGVuZXIgYmVpbmcgdHJpZ2dlcmVkLiBBXG4gICAgICAvLyBwYWRkaW5nIG9mIDIgc2VlbXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZGRpbmcgPSAyLFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgbmF0aXZlQ2xpZW50UmVjdHMgPSBBcnJheS5mcm9tKChhd2FpdCAocGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldENsaWVudFJlY3RzKGVsZW1lbnRzLnJlZmVyZW5jZSkpKSB8fCBbXSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IGdldFJlY3RzQnlMaW5lKG5hdGl2ZUNsaWVudFJlY3RzKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QobmF0aXZlQ2xpZW50UmVjdHMpKTtcbiAgICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWQuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0ICYmIHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByZWN0IGluIHdoaWNoIHRoZSBwb2ludCBpcyBmdWxseSBpbnNpZGUuXG4gICAgICAgICAgcmV0dXJuIGNsaWVudFJlY3RzLmZpbmQocmVjdCA9PiB4ID4gcmVjdC5sZWZ0IC0gcGFkZGluZ09iamVjdC5sZWZ0ICYmIHggPCByZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCAmJiB5ID4gcmVjdC50b3AgLSBwYWRkaW5nT2JqZWN0LnRvcCAmJiB5IDwgcmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgfHwgZmFsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBhcmUgMiBvciBtb3JlIGNvbm5lY3RlZCByZWN0cy5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgaWYgKGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaXNUb3AgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICd0b3AnO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTGVmdFNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICdsZWZ0JztcbiAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IG1heCguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gICAgICAgICAgY29uc3QgbWluTGVmdCA9IG1pbiguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIocmVjdCA9PiBpc0xlZnRTaWRlID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0IDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICAgICAgY29uc3QgbGVmdCA9IG1pbkxlZnQ7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBtYXhSaWdodDtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzZXRSZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZWxlbWVudHMuZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWN0cy5yZWZlcmVuY2UueCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueCB8fCByZWN0cy5yZWZlcmVuY2UueSAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueSB8fCByZWN0cy5yZWZlcmVuY2Uud2lkdGggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLndpZHRoIHx8IHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogcmVzZXRSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBvcmlnaW5TaWRlcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnbGVmdCcsICd0b3AnXSk7XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBvcmlnaW5TaWRlcy5oYXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUubWFpbkF4aXMgfHwgMCxcbiAgICBjcm9zc0F4aXM6IHJhd1ZhbHVlLmNyb3NzQXhpcyB8fCAwLFxuICAgIGFsaWdubWVudEF4aXM6IHJhd1ZhbHVlLmFsaWdubWVudEF4aXNcbiAgfTtcbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuICByZXR1cm4gaXNWZXJ0aWNhbCA/IHtcbiAgICB4OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aSxcbiAgICB5OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGlcbiAgfSA6IHtcbiAgICB4OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGksXG4gICAgeTogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGlcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJGFycm93O1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB0aGUgcGxhY2VtZW50IGlzIHRoZSBzYW1lIGFuZCB0aGUgYXJyb3cgY2F1c2VkIGFuIGFsaWdubWVudCBvZmZzZXRcbiAgICAgIC8vIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uaW5nIGNvb3JkaW5hdGVzLlxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UucGxhY2VtZW50KSAmJiAoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uZGlmZkNvb3JkcyxcbiAgICAgICAgICBwbGFjZW1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NoaWZ0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogX3JlZiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbiwgY3Jvc3NBeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geSxcbiAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICBbbWFpbkF4aXNdOiBjaGVja01haW5BeGlzLFxuICAgICAgICAgICAgW2Nyb3NzQXhpc106IGNoZWNrQ3Jvc3NBeGlzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSBldmFsdWF0ZShvZmZzZXQsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkT2Zmc2V0ID0gdHlwZW9mIHJhd09mZnNldCA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgIG1haW5BeGlzOiByYXdPZmZzZXQsXG4gICAgICAgIGNyb3NzQXhpczogMFxuICAgICAgfSA6IHtcbiAgICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICAgIGNyb3NzQXhpczogMCxcbiAgICAgICAgLi4ucmF3T2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRvZmZzZTI7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IG9yaWdpblNpZGVzLmhhcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZVtjcm9zc0F4aXNdKSB8fCAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSB8fCAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLCBfc3RhdGUkbWlkZGxld2FyZURhdGEyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHkgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSByZWN0cy5mbG9hdGluZztcbiAgICAgIGxldCBoZWlnaHRTaWRlO1xuICAgICAgbGV0IHdpZHRoU2lkZTtcbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ1dpZHRoID0gd2lkdGggLSBvdmVyZmxvdy5sZWZ0IC0gb3ZlcmZsb3cucmlnaHQ7XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IG1pbihoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXSwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSBtaW4od2lkdGggLSBvdmVyZmxvd1t3aWR0aFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCk7XG4gICAgICBjb25zdCBub1NoaWZ0ID0gIXN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0O1xuICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gb3ZlcmZsb3dBdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmICgoX3N0YXRlJG1pZGRsZXdhcmVEYXRhID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLmVuYWJsZWQueCkge1xuICAgICAgICBhdmFpbGFibGVXaWR0aCA9IG1heGltdW1DbGlwcGluZ1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEyID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhMi5lbmFibGVkLnkpIHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbWF4aW11bUNsaXBwaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9O1xuIl0sIm5hbWVzIjpbImdldFNpZGVBeGlzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlIiwiZ2V0QWxpZ25tZW50IiwiZXZhbHVhdGUiLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsIm1pbiIsImNsYW1wIiwicGxhY2VtZW50cyIsImdldEFsaWdubWVudFNpZGVzIiwiZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJzaWRlcyIsIm1heCIsImdldE9wcG9zaXRlQXhpcyIsImNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50IiwiX3JlZiIsInBsYWNlbWVudCIsInJ0bCIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwic2lkZUF4aXMiLCJhbGlnbm1lbnRBeGlzIiwiYWxpZ25MZW5ndGgiLCJzaWRlIiwiaXNWZXJ0aWNhbCIsImNvbW1vblgiLCJ4Iiwid2lkdGgiLCJjb21tb25ZIiwieSIsImhlaWdodCIsImNvbW1vbkFsaWduIiwiY29vcmRzIiwiY29tcHV0ZVBvc2l0aW9uIiwiY29uZmlnIiwic3RyYXRlZ3kiLCJtaWRkbGV3YXJlIiwicGxhdGZvcm0iLCJ2YWxpZE1pZGRsZXdhcmUiLCJmaWx0ZXIiLCJCb29sZWFuIiwiaXNSVEwiLCJyZWN0cyIsImdldEVsZW1lbnRSZWN0cyIsInN0YXRlZnVsUGxhY2VtZW50IiwibWlkZGxld2FyZURhdGEiLCJyZXNldENvdW50IiwiaSIsImxlbmd0aCIsIm5hbWUiLCJmbiIsIm5leHRYIiwibmV4dFkiLCJkYXRhIiwicmVzZXQiLCJpbml0aWFsUGxhY2VtZW50IiwiZWxlbWVudHMiLCJkZXRlY3RPdmVyZmxvdyIsInN0YXRlIiwib3B0aW9ucyIsIl9hd2FpdCRwbGF0Zm9ybSRpc0VsZSIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwiZWxlbWVudENvbnRleHQiLCJhbHRCb3VuZGFyeSIsInBhZGRpbmciLCJwYWRkaW5nT2JqZWN0IiwiYWx0Q29udGV4dCIsImVsZW1lbnQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJnZXRDbGlwcGluZ1JlY3QiLCJpc0VsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldERvY3VtZW50RWxlbWVudCIsInJlY3QiLCJvZmZzZXRQYXJlbnQiLCJnZXRPZmZzZXRQYXJlbnQiLCJvZmZzZXRTY2FsZSIsImdldFNjYWxlIiwiZWxlbWVudENsaWVudFJlY3QiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImFycm93IiwiYXhpcyIsImFycm93RGltZW5zaW9ucyIsImdldERpbWVuc2lvbnMiLCJpc1lBeGlzIiwibWluUHJvcCIsIm1heFByb3AiLCJjbGllbnRQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNlbnRlclRvUmVmZXJlbmNlIiwibGFyZ2VzdFBvc3NpYmxlUGFkZGluZyIsIm1pblBhZGRpbmciLCJtYXhQYWRkaW5nIiwibWluJDEiLCJjZW50ZXIiLCJvZmZzZXQiLCJzaG91bGRBZGRPZmZzZXQiLCJhbGlnbm1lbnRPZmZzZXQiLCJjZW50ZXJPZmZzZXQiLCJnZXRQbGFjZW1lbnRMaXN0IiwiYWxpZ25tZW50IiwiYXV0b0FsaWdubWVudCIsImFsbG93ZWRQbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCIsImF1dG9QbGFjZW1lbnQiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AyIiwiX3BsYWNlbWVudHNUaGF0Rml0T25FIiwiY3Jvc3NBeGlzIiwiZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIiwicGxhY2VtZW50cyQxIiwidW5kZWZpbmVkIiwib3ZlcmZsb3ciLCJjdXJyZW50SW5kZXgiLCJpbmRleCIsImN1cnJlbnRQbGFjZW1lbnQiLCJhbGlnbm1lbnRTaWRlcyIsImN1cnJlbnRPdmVyZmxvd3MiLCJhbGxPdmVyZmxvd3MiLCJvdmVyZmxvd3MiLCJuZXh0UGxhY2VtZW50IiwicGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlIiwibWFwIiwiZCIsInNsaWNlIiwicmVkdWNlIiwiYWNjIiwidiIsInNvcnQiLCJhIiwiYiIsInBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSIsImV2ZXJ5IiwicmVzZXRQbGFjZW1lbnQiLCJmbGlwIiwiX21pZGRsZXdhcmVEYXRhJGFycm93IiwiX21pZGRsZXdhcmVEYXRhJGZsaXAiLCJtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJjaGVja0Nyb3NzQXhpcyIsImZhbGxiYWNrUGxhY2VtZW50cyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrU3RyYXRlZ3kiLCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwiZmxpcEFsaWdubWVudCIsImluaXRpYWxTaWRlQXhpcyIsImlzQmFzZVBsYWNlbWVudCIsImhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24iLCJwdXNoIiwib3ZlcmZsb3dzRGF0YSIsIl9taWRkbGV3YXJlRGF0YSRmbGlwMiIsIl9vdmVyZmxvd3NEYXRhJGZpbHRlciIsIm5leHRJbmRleCIsImlnbm9yZUNyb3NzQXhpc092ZXJmbG93IiwiX292ZXJmbG93c0RhdGEkZmlsdGVyMiIsImN1cnJlbnRTaWRlQXhpcyIsImdldFNpZGVPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic29tZSIsImhpZGUiLCJvZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuT2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbiIsImVzY2FwZWRPZmZzZXRzIiwiZXNjYXBlZCIsImdldEJvdW5kaW5nUmVjdCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJnZXRSZWN0c0J5TGluZSIsInNvcnRlZFJlY3RzIiwiZ3JvdXBzIiwicHJldlJlY3QiLCJpbmxpbmUiLCJuYXRpdmVDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldENsaWVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJmYWxsYmFjayIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImZpbmQiLCJmaXJzdFJlY3QiLCJsYXN0UmVjdCIsImlzVG9wIiwiaXNMZWZ0U2lkZSIsIm1heFJpZ2h0IiwibWluTGVmdCIsIm1lYXN1cmVSZWN0cyIsInJlc2V0UmVjdHMiLCJvcmlnaW5TaWRlcyIsIlNldCIsImNvbnZlcnRWYWx1ZVRvQ29vcmRzIiwibWFpbkF4aXNNdWx0aSIsImhhcyIsImNyb3NzQXhpc011bHRpIiwicmF3VmFsdWUiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UiLCJkaWZmQ29vcmRzIiwic2hpZnQiLCJsaW1pdGVyIiwibWFpbkF4aXNDb29yZCIsImNyb3NzQXhpc0Nvb3JkIiwibWluU2lkZSIsIm1heFNpZGUiLCJsaW1pdGVkQ29vcmRzIiwiZW5hYmxlZCIsImxpbWl0U2hpZnQiLCJyYXdPZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImxlbiIsImxpbWl0TWluIiwibGltaXRNYXgiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UyIiwiaXNPcmlnaW5TaWRlIiwic2l6ZSIsIl9zdGF0ZSRtaWRkbGV3YXJlRGF0YSIsIl9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIiLCJhcHBseSIsImhlaWdodFNpZGUiLCJ3aWR0aFNpZGUiLCJtYXhpbXVtQ2xpcHBpbmdIZWlnaHQiLCJtYXhpbXVtQ2xpcHBpbmdXaWR0aCIsIm92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0Iiwib3ZlcmZsb3dBdmFpbGFibGVXaWR0aCIsIm5vU2hpZnQiLCJhdmFpbGFibGVIZWlnaHQiLCJhdmFpbGFibGVXaWR0aCIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJuZXh0RGltZW5zaW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\nfunction getCssDimensions(element) {\n    const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width,\n        height,\n        $: shouldFallback\n    };\n}\nfunction unwrapElement(element) {\n    return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(domElement)) {\n        return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const { width, height, $ } = getCssDimensions(domElement);\n    let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) : rect.width) / width;\n    let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) {\n        x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n        y = 1;\n    }\n    return {\n        x,\n        y\n    };\n}\nconst noOffsets = /*#__PURE__*/ (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\nfunction getVisualOffsets(element) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)() || !win.visualViewport) {\n        return noOffsets;\n    }\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element)) {\n        return false;\n    }\n    return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent)) {\n                scale = getScale(offsetParent);\n            }\n        } else {\n            scale = getScale(element);\n        }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(domElement);\n        const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(offsetParent) : offsetParent;\n        let currentWin = win;\n        let currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n        while(currentIFrame && offsetParent && offsetWin !== currentWin){\n            const iframeScale = getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(currentIFrame);\n            currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n        }\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)({\n        width,\n        height,\n        x,\n        y\n    });\n}\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n    const leftScroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element).scrollLeft;\n    if (!rect) {\n        return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element)).left + leftScroll;\n    }\n    return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n    if (ignoreScrollbarX === void 0) {\n        ignoreScrollbarX = false;\n    }\n    const htmlRect = documentElement.getBoundingClientRect();\n    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect));\n    const y = htmlRect.top + scroll.scrollTop;\n    return {\n        x,\n        y\n    };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { elements, rect, offsetParent, strategy } = _ref;\n    const isFixed = strategy === \"fixed\";\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n    const topLayer = elements ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(elements.floating) : false;\n    if (offsetParent === documentElement || topLayer && isFixed) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n        }\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent);\n            scale = getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n    };\n}\nfunction getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element);\n    const body = element.ownerDocument.body;\n    const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(body).direction === \"rtl\") {\n        x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)();\n        if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nconst absoluteOrFixed = /*#__PURE__*/ new Set([\n    \"absolute\",\n    \"fixed\"\n]);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === \"viewport\") {\n        rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === \"document\") {\n        rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element));\n    } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(clippingAncestor)) {\n        rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n        const visualOffsets = getVisualOffsets(element);\n        rect = {\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y,\n            width: clippingAncestor.width,\n            height: clippingAncestor.height\n        };\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n    if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(parentNode)) {\n        return false;\n    }\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(element, [], false).filter((el)=>(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(el) !== \"body\");\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"fixed\";\n    let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(currentNode)){\n        const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentNode);\n        const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n            currentContainingBlockComputedStyle = null;\n        }\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) {\n            // Drop non-containing blocks.\n            result = result.filter((ancestor)=>ancestor !== currentNode);\n        } else {\n            // Record last containing block for next iteration.\n            currentContainingBlockComputedStyle = computedStyle;\n        }\n        currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const elementClippingAncestors = boundary === \"clippingAncestors\" ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.top, accRect.top);\n        accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.right, accRect.right);\n        accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.bottom, accRect.bottom);\n        accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction getDimensions(element) {\n    const { width, height } = getCssDimensions(element);\n    return {\n        width,\n        height\n    };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n    const isFixed = strategy === \"fixed\";\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n    // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n    function setLeftRTLScrollbarOffset() {\n        offsets.x = getWindowScrollBarX(documentElement);\n    }\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n        }\n        if (isOffsetParentAnElement) {\n            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            setLeftRTLScrollbarOffset();\n        }\n    }\n    if (isFixed && !isOffsetParentAnElement && documentElement) {\n        setLeftRTLScrollbarOffset();\n    }\n    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n    return {\n        x,\n        y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction isStaticPositioned(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === \"fixed\") {\n        return null;\n    }\n    if (polyfill) {\n        return polyfill(element);\n    }\n    let rawOffsetParent = element.offsetParent;\n    // Firefox returns the <html> element as the offsetParent if it's non-static,\n    // while Chrome and Safari return the <body> element. The <body> element must\n    // be used to perform the correct calculations even if the <html> element is\n    // non-static.\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element) === rawOffsetParent) {\n        rawOffsetParent = rawOffsetParent.ownerDocument.body;\n    }\n    return rawOffsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element)) {\n        return win;\n    }\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n        let svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n        while(svgOffsetParent && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(svgOffsetParent)){\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n                return svgOffsetParent;\n            }\n            svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(svgOffsetParent);\n        }\n        return win;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTableElement)(offsetParent) && isStaticPositioned(offsetParent)){\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(offsetParent) && isStaticPositioned(offsetParent) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(offsetParent)) {\n        return win;\n    }\n    return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getContainingBlock)(element) || win;\n}\nconst getElementRects = async function(data) {\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    const floatingDimensions = await getDimensionsFn(data.floating);\n    return {\n        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            width: floatingDimensions.width,\n            height: floatingDimensions.height\n        }\n    };\n};\nfunction isRTL(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).direction === \"rtl\";\n}\nconst platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement,\n    isRTL\n};\nfunction rectsAreEqual(a, b) {\n    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n    function cleanup() {\n        var _io;\n        clearTimeout(timeoutId);\n        (_io = io) == null || _io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) {\n            skip = false;\n        }\n        if (threshold === void 0) {\n            threshold = 1;\n        }\n        cleanup();\n        const elementRectForRootMargin = element.getBoundingClientRect();\n        const { left, top, width, height } = elementRectForRootMargin;\n        if (!skip) {\n            onMove();\n        }\n        if (!width || !height) {\n            return;\n        }\n        const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(top);\n        const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientWidth - (left + width));\n        const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientHeight - (top + height));\n        const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin,\n            threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) {\n                    return refresh();\n                }\n                if (!ratio) {\n                    // If the reference is clipped, the ratio is 0. Throttle the refresh\n                    // to prevent an infinite loop of updates.\n                    timeoutId = setTimeout(()=>{\n                        refresh(false, 1e-7);\n                    }, 1000);\n                } else {\n                    refresh(false, ratio);\n                }\n            }\n            if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n                // It's possible that even though the ratio is reported as 1, the\n                // element is not actually fully within the IntersectionObserver's root\n                // area anymore. This can happen under performance constraints. This may\n                // be a bug in the browser's IntersectionObserver implementation. To\n                // work around this, we compare the element's bounding rect now with\n                // what it was at the time we created the IntersectionObserver. If they\n                // are not equal then the element moved, so we refresh.\n                refresh();\n            }\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (_e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === \"function\", layoutShift = typeof IntersectionObserver === \"function\", animationFrame = false } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(referenceEl) : [],\n        ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    var _resizeObserver;\n                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) {\n            resizeObserver.observe(referenceEl);\n        }\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        var _resizeObserver2;\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        cleanupIo == null || cleanupIo();\n        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n        resizeObserver = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ const detectOverflow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.detectOverflow;\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.offset;\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.autoPlacement;\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.shift;\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.flip;\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.size;\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.hide;\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.arrow;\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.inline;\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.limitShift;\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */ const computePosition = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeVQ7QUFDL087QUFDa1A7QUFDOVA7QUFFOUQsU0FBUzZDLGlCQUFpQkMsT0FBTztJQUMvQixNQUFNQyxNQUFNbkIsd0VBQWdCQSxDQUFDa0I7SUFDN0IseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSxJQUFJRSxRQUFRQyxXQUFXRixJQUFJQyxLQUFLLEtBQUs7SUFDckMsSUFBSUUsU0FBU0QsV0FBV0YsSUFBSUcsTUFBTSxLQUFLO0lBQ3ZDLE1BQU1DLFlBQVl0QixxRUFBYUEsQ0FBQ2lCO0lBQ2hDLE1BQU1NLGNBQWNELFlBQVlMLFFBQVFNLFdBQVcsR0FBR0o7SUFDdEQsTUFBTUssZUFBZUYsWUFBWUwsUUFBUU8sWUFBWSxHQUFHSDtJQUN4RCxNQUFNSSxpQkFBaUIvQix5REFBS0EsQ0FBQ3lCLFdBQVdJLGVBQWU3Qix5REFBS0EsQ0FBQzJCLFlBQVlHO0lBQ3pFLElBQUlDLGdCQUFnQjtRQUNsQk4sUUFBUUk7UUFDUkYsU0FBU0c7SUFDWDtJQUNBLE9BQU87UUFDTEw7UUFDQUU7UUFDQUssR0FBR0Q7SUFDTDtBQUNGO0FBRUEsU0FBU0UsY0FBY1YsT0FBTztJQUM1QixPQUFPLENBQUNoQixpRUFBU0EsQ0FBQ2dCLFdBQVdBLFFBQVFXLGNBQWMsR0FBR1g7QUFDeEQ7QUFFQSxTQUFTWSxTQUFTWixPQUFPO0lBQ3ZCLE1BQU1hLGFBQWFILGNBQWNWO0lBQ2pDLElBQUksQ0FBQ2pCLHFFQUFhQSxDQUFDOEIsYUFBYTtRQUM5QixPQUFPbkMsZ0VBQVlBLENBQUM7SUFDdEI7SUFDQSxNQUFNb0MsT0FBT0QsV0FBV0UscUJBQXFCO0lBQzdDLE1BQU0sRUFDSmIsS0FBSyxFQUNMRSxNQUFNLEVBQ05LLENBQUMsRUFDRixHQUFHVixpQkFBaUJjO0lBQ3JCLElBQUlHLElBQUksQ0FBQ1AsSUFB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QUFVO1FBQzFFbUMsaUJBQWlCO1FBQ2pCLElBQUlSLGdCQUFnQjtZQUNsQlkscUJBQXFCRztRQUN2QjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsTUFBTXBPLGlCQUFpQkMsNkRBQWdCQTtBQUV2Qzs7Ozs7O0NBTUMsR0FDRCxNQUFNUyxTQUFTQyxxREFBUUE7QUFFdkI7Ozs7O0NBS0MsR0FDRCxNQUFNYixnQkFBZ0JDLDREQUFlQTtBQUVyQzs7OztDQUlDLEdBQ0QsTUFBTWEsUUFBUUMsb0RBQU9BO0FBRXJCOzs7OztDQUtDLEdBQ0QsTUFBTVgsT0FBT0MsbURBQU1BO0FBRW5COzs7OztDQUtDLEdBQ0QsTUFBTVcsT0FBT0MsbURBQU1BO0FBRW5COzs7O0NBSUMsR0FDRCxNQUFNWCxPQUFPQyxtREFBTUE7QUFFbkI7Ozs7Q0FJQyxHQUNELE1BQU1ULFFBQVFDLG9EQUFPQTtBQUVyQjs7OztDQUlDLEdBQ0QsTUFBTVMsU0FBU0MscURBQVFBO0FBRXZCOztDQUVDLEdBQ0QsTUFBTUMsYUFBYUMseURBQVlBO0FBRS9COzs7Q0FHQyxHQUNELE1BQU1PLGtCQUFrQixDQUFDNEosV0FBV3ZFLFVBQVUrRjtJQUM1QywyRUFBMkU7SUFDM0Usd0VBQXdFO0lBQ3hFLDZFQUE2RTtJQUM3RSxNQUFNbEUsUUFBUSxJQUFJd0c7SUFDbEIsTUFBTUMsZ0JBQWdCO1FBQ3BCN0Q7UUFDQSxHQUFHc0IsT0FBTztJQUNaO0lBQ0EsTUFBTXdDLG9CQUFvQjtRQUN4QixHQUFHRCxjQUFjN0QsUUFBUTtRQUN6QnpCLElBQUluQjtJQUNOO0lBQ0EsT0FBT2pILGtFQUFpQkEsQ0FBQzJKLFdBQVd2RSxVQUFVO1FBQzVDLEdBQUdzSSxhQUFhO1FBQ2hCN0QsVUFBVThEO0lBQ1o7QUFDRjtBQUU0SSIsInNvdXJjZXMiOlsid2VicGFjazovL25ndC1jbGluaWMvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanM/M2ZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBhcnJvdyBhcyBhcnJvdyQxLCBhdXRvUGxhY2VtZW50IGFzIGF1dG9QbGFjZW1lbnQkMSwgZGV0ZWN0T3ZlcmZsb3cgYXMgZGV0ZWN0T3ZlcmZsb3ckMSwgZmxpcCBhcyBmbGlwJDEsIGhpZGUgYXMgaGlkZSQxLCBpbmxpbmUgYXMgaW5saW5lJDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBvZmZzZXQgYXMgb2Zmc2V0JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIHNpemUgYXMgc2l6ZSQxLCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5pbXBvcnQgeyByb3VuZCwgY3JlYXRlQ29vcmRzLCBtYXgsIG1pbiwgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNIVE1MRWxlbWVudCwgaXNFbGVtZW50LCBnZXRXaW5kb3csIGlzV2ViS2l0LCBnZXRGcmFtZUVsZW1lbnQsIGdldE5vZGVTY3JvbGwsIGdldERvY3VtZW50RWxlbWVudCwgaXNUb3BMYXllciwgZ2V0Tm9kZU5hbWUsIGlzT3ZlcmZsb3dFbGVtZW50LCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc0NvbnRhaW5pbmdCbG9jaywgaXNUYWJsZUVsZW1lbnQsIGdldENvbnRhaW5pbmdCbG9jayB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuZXhwb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIC8vIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzLCB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBhcmUgZW1wdHlcbiAgLy8gc3RyaW5ncyBmb3IgU1ZHIGVsZW1lbnRzLCByZXR1cm5pbmcgTmFOLiBGYWxsYmFjayB0byBgMGAgaW4gdGhpcyBjYXNlLlxuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuICFpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LmNvbnRleHRFbGVtZW50IDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuXG4gIC8vIDAsIE5hTiwgb3IgSW5maW5pdHkgc2hvdWxkIGFsd2F5cyBmYWxsYmFjayB0byAxLlxuXG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBub09mZnNldHMgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29vcmRzKDApO1xuZnVuY3Rpb24gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc1dlYktpdCgpIHx8ICF3aW4udmlzdWFsVmlld3BvcnQpIHtcbiAgICByZXR1cm4gbm9PZmZzZXRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcFxuICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhlbGVtZW50LCBpc0ZpeGVkLCBmbG9hdGluZ09mZnNldFBhcmVudCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG4gIGlmICghZmxvYXRpbmdPZmZzZXRQYXJlbnQgfHwgaXNGaXhlZCAmJiBmbG9hdGluZ09mZnNldFBhcmVudCAhPT0gZ2V0V2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRXaW4gPSB3aW47XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gY3VycmVudFdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRXaW4gPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSk7XG4gICAgICBjdXJyZW50SUZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGN1cnJlbnRXaW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbn1cblxuLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuLy8gaW5jb3JyZWN0IGZvciBSVEwuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQsIHJlY3QpIHtcbiAgY29uc3QgbGVmdFNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBsZWZ0U2Nyb2xsO1xuICB9XG4gIHJldHVybiByZWN0LmxlZnQgKyBsZWZ0U2Nyb2xsO1xufVxuXG5mdW5jdGlvbiBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCBpZ25vcmVTY3JvbGxiYXJYKSB7XG4gIGlmIChpZ25vcmVTY3JvbGxiYXJYID09PSB2b2lkIDApIHtcbiAgICBpZ25vcmVTY3JvbGxiYXJYID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgaHRtbFJlY3QgPSBkb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHggPSBodG1sUmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSAoaWdub3JlU2Nyb2xsYmFyWCA/IDAgOlxuICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhci5cbiAgZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQsIGh0bWxSZWN0KSk7XG4gIGNvbnN0IHkgPSBodG1sUmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHRvcExheWVyID0gZWxlbWVudHMgPyBpc1RvcExheWVyKGVsZW1lbnRzLmZsb2F0aW5nKSA6IGZhbHNlO1xuICBpZiAob2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQgfHwgdG9wTGF5ZXIgJiYgaXNGaXhlZCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCwgdHJ1ZSkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggKiBzY2FsZS54LFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBzY2FsZS55LFxuICAgIHg6IHJlY3QueCAqIHNjYWxlLnggLSBzY3JvbGwuc2Nyb2xsTGVmdCAqIHNjYWxlLnggKyBvZmZzZXRzLnggKyBodG1sT2Zmc2V0LngsXG4gICAgeTogcmVjdC55ICogc2NhbGUueSAtIHNjcm9sbC5zY3JvbGxUb3AgKiBzY2FsZS55ICsgb2Zmc2V0cy55ICsgaHRtbE9mZnNldC55XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5nZXRDbGllbnRSZWN0cygpKTtcbn1cblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZS5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBhYnNvbHV0ZU9yRml4ZWQgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2Fic29sdXRlJywgJ2ZpeGVkJ10pO1xuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIHg6IGNsaXBwaW5nQW5jZXN0b3IueCAtIHZpc3VhbE9mZnNldHMueCxcbiAgICAgIHk6IGNsaXBwaW5nQW5jZXN0b3IueSAtIHZpc3VhbE9mZnNldHMueSxcbiAgICAgIHdpZHRoOiBjbGlwcGluZ0FuY2VzdG9yLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjbGlwcGluZ0FuY2VzdG9yLmhlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QocmVjdCk7XG59XG5mdW5jdGlvbiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgc3RvcE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmIChwYXJlbnROb2RlID09PSBzdG9wTm9kZSB8fCAhaXNFbGVtZW50KHBhcmVudE5vZGUpIHx8IGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IocGFyZW50Tm9kZSwgc3RvcE5vZGUpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBgb3ZlcmZsb3dgIGVsZW1lbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIGNoaWxkIGVsZW1lbnRzLiBUaGlzIHJldHVybnMgYWxsIGNsaXBwaW5nIGFuY2VzdG9yc1xuLy8gb2YgdGhlIGdpdmVuIGVsZW1lbnQgdXAgdGhlIHRyZWUuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCwgW10sIGZhbHNlKS5maWx0ZXIoZWwgPT4gaXNFbGVtZW50KGVsKSAmJiBnZXROb2RlTmFtZShlbCkgIT09ICdib2R5Jyk7XG4gIGxldCBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gIGNvbnN0IGVsZW1lbnRJc0ZpeGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbiAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIDogZWxlbWVudDtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICB3aGlsZSAoaXNFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlzQ29udGFpbmluZyA9IGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkRHJvcEN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICEhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgJiYgYWJzb2x1dGVPckZpeGVkLmhhcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBpc1RvcExheWVyKGVsZW1lbnQpID8gW10gOiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuXG4gIC8vIElmIHRoZSA8Ym9keT4gc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgKGUuZy4gUlRMIHN5c3RlbXMpLiBVc2VcbiAgLy8gRmlyZWZveCB3aXRoIGxheW91dC5zY3JvbGxiYXIuc2lkZSA9IDMgaW4gYWJvdXQ6Y29uZmlnIHRvIHRlc3QgdGhpcy5cbiAgZnVuY3Rpb24gc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpIHtcbiAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gIH1cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBzZXRMZWZ0UlRMU2Nyb2xsYmFyT2Zmc2V0KCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0ZpeGVkICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiBkb2N1bWVudEVsZW1lbnQpIHtcbiAgICBzZXRMZWZ0UlRMU2Nyb2xsYmFyT2Zmc2V0KCk7XG4gIH1cbiAgY29uc3QgaHRtbE9mZnNldCA9IGRvY3VtZW50RWxlbWVudCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQgPyBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgY29uc3QgeCA9IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54IC0gaHRtbE9mZnNldC54O1xuICBjb25zdCB5ID0gcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55IC0gaHRtbE9mZnNldC55O1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljUG9zaXRpb25lZChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJztcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwb2x5ZmlsbCkge1xuICAgIHJldHVybiBwb2x5ZmlsbChlbGVtZW50KTtcbiAgfVxuICBsZXQgcmF3T2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG5cbiAgLy8gRmlyZWZveCByZXR1cm5zIHRoZSA8aHRtbD4gZWxlbWVudCBhcyB0aGUgb2Zmc2V0UGFyZW50IGlmIGl0J3Mgbm9uLXN0YXRpYyxcbiAgLy8gd2hpbGUgQ2hyb21lIGFuZCBTYWZhcmkgcmV0dXJuIHRoZSA8Ym9keT4gZWxlbWVudC4gVGhlIDxib2R5PiBlbGVtZW50IG11c3RcbiAgLy8gYmUgdXNlZCB0byBwZXJmb3JtIHRoZSBjb3JyZWN0IGNhbGN1bGF0aW9ucyBldmVuIGlmIHRoZSA8aHRtbD4gZWxlbWVudCBpc1xuICAvLyBub24tc3RhdGljLlxuICBpZiAoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpID09PSByYXdPZmZzZXRQYXJlbnQpIHtcbiAgICByYXdPZmZzZXRQYXJlbnQgPSByYXdPZmZzZXRQYXJlbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG4gIHJldHVybiByYXdPZmZzZXRQYXJlbnQ7XG59XG5cbi8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoaXNUb3BMYXllcihlbGVtZW50KSkge1xuICAgIHJldHVybiB3aW47XG4gIH1cbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgbGV0IHN2Z09mZnNldFBhcmVudCA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gICAgd2hpbGUgKHN2Z09mZnNldFBhcmVudCAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKHN2Z09mZnNldFBhcmVudCkpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQoc3ZnT2Zmc2V0UGFyZW50KSAmJiAhaXNTdGF0aWNQb3NpdGlvbmVkKHN2Z09mZnNldFBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHN2Z09mZnNldFBhcmVudDtcbiAgICAgIH1cbiAgICAgIHN2Z09mZnNldFBhcmVudCA9IGdldFBhcmVudE5vZGUoc3ZnT2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCk7XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSkge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50LCBwb2x5ZmlsbCk7XG4gIH1cbiAgaWYgKG9mZnNldFBhcmVudCAmJiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUob2Zmc2V0UGFyZW50KSAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkge1xuICAgIHJldHVybiB3aW47XG4gIH1cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luO1xufVxuXG5jb25zdCBnZXRFbGVtZW50UmVjdHMgPSBhc3luYyBmdW5jdGlvbiAoZGF0YSkge1xuICBjb25zdCBnZXRPZmZzZXRQYXJlbnRGbiA9IHRoaXMuZ2V0T2Zmc2V0UGFyZW50IHx8IGdldE9mZnNldFBhcmVudDtcbiAgY29uc3QgZ2V0RGltZW5zaW9uc0ZuID0gdGhpcy5nZXREaW1lbnNpb25zO1xuICBjb25zdCBmbG9hdGluZ0RpbWVuc2lvbnMgPSBhd2FpdCBnZXREaW1lbnNpb25zRm4oZGF0YS5mbG9hdGluZyk7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChkYXRhLnJlZmVyZW5jZSwgYXdhaXQgZ2V0T2Zmc2V0UGFyZW50Rm4oZGF0YS5mbG9hdGluZyksIGRhdGEuc3RyYXRlZ3kpLFxuICAgIGZsb2F0aW5nOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBmbG9hdGluZ0RpbWVuc2lvbnMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGZsb2F0aW5nRGltZW5zaW9ucy5oZWlnaHRcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc1JUTChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG59XG5cbmNvbnN0IHBsYXRmb3JtID0ge1xuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRDbGlwcGluZ1JlY3QsXG4gIGdldE9mZnNldFBhcmVudCxcbiAgZ2V0RWxlbWVudFJlY3RzLFxuICBnZXRDbGllbnRSZWN0cyxcbiAgZ2V0RGltZW5zaW9ucyxcbiAgZ2V0U2NhbGUsXG4gIGlzRWxlbWVudCxcbiAgaXNSVExcbn07XG5cbmZ1bmN0aW9uIHJlY3RzQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnkgJiYgYS53aWR0aCA9PT0gYi53aWR0aCAmJiBhLmhlaWdodCA9PT0gYi5oZWlnaHQ7XG59XG5cbi8vIGh0dHBzOi8vc2FtdGhvci5hdS8yMDIxL29ic2VydmluZy1kb20vXG5mdW5jdGlvbiBvYnNlcnZlTW92ZShlbGVtZW50LCBvbk1vdmUpIHtcbiAgbGV0IGlvID0gbnVsbDtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgY29uc3Qgcm9vdCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICB2YXIgX2lvO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIChfaW8gPSBpbykgPT0gbnVsbCB8fCBfaW8uZGlzY29ubmVjdCgpO1xuICAgIGlvID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoKHNraXAsIHRocmVzaG9sZCkge1xuICAgIGlmIChza2lwID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgY29uc3QgZWxlbWVudFJlY3RGb3JSb290TWFyZ2luID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZWxlbWVudFJlY3RGb3JSb290TWFyZ2luO1xuICAgIGlmICghc2tpcCkge1xuICAgICAgb25Nb3ZlKCk7XG4gICAgfVxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnNldFRvcCA9IGZsb29yKHRvcCk7XG4gICAgY29uc3QgaW5zZXRSaWdodCA9IGZsb29yKHJvb3QuY2xpZW50V2lkdGggLSAobGVmdCArIHdpZHRoKSk7XG4gICAgY29uc3QgaW5zZXRCb3R0b20gPSBmbG9vcihyb290LmNsaWVudEhlaWdodCAtICh0b3AgKyBoZWlnaHQpKTtcbiAgICBjb25zdCBpbnNldExlZnQgPSBmbG9vcihsZWZ0KTtcbiAgICBjb25zdCByb290TWFyZ2luID0gLWluc2V0VG9wICsgXCJweCBcIiArIC1pbnNldFJpZ2h0ICsgXCJweCBcIiArIC1pbnNldEJvdHRvbSArIFwicHggXCIgKyAtaW5zZXRMZWZ0ICsgXCJweFwiO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkOiBtYXgoMCwgbWluKDEsIHRocmVzaG9sZCkpIHx8IDFcbiAgICB9O1xuICAgIGxldCBpc0ZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVPYnNlcnZlKGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gZW50cmllc1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChyYXRpbyAhPT0gdGhyZXNob2xkKSB7XG4gICAgICAgIGlmICghaXNGaXJzdFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybiByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYXRpbykge1xuICAgICAgICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgY2xpcHBlZCwgdGhlIHJhdGlvIGlzIDAuIFRocm90dGxlIHRoZSByZWZyZXNoXG4gICAgICAgICAgLy8gdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIHVwZGF0ZXMuXG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWZyZXNoKGZhbHNlLCAxZS03KTtcbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZyZXNoKGZhbHNlLCByYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyYXRpbyA9PT0gMSAmJiAhcmVjdHNBcmVFcXVhbChlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4sIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKSB7XG4gICAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCBldmVuIHRob3VnaCB0aGUgcmF0aW8gaXMgcmVwb3J0ZWQgYXMgMSwgdGhlXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgbm90IGFjdHVhbGx5IGZ1bGx5IHdpdGhpbiB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIncyByb290XG4gICAgICAgIC8vIGFyZWEgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIHVuZGVyIHBlcmZvcm1hbmNlIGNvbnN0cmFpbnRzLiBUaGlzIG1heVxuICAgICAgICAvLyBiZSBhIGJ1ZyBpbiB0aGUgYnJvd3NlcidzIEludGVyc2VjdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uLiBUb1xuICAgICAgICAvLyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSBjb21wYXJlIHRoZSBlbGVtZW50J3MgYm91bmRpbmcgcmVjdCBub3cgd2l0aFxuICAgICAgICAvLyB3aGF0IGl0IHdhcyBhdCB0aGUgdGltZSB3ZSBjcmVhdGVkIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlci4gSWYgdGhleVxuICAgICAgICAvLyBhcmUgbm90IGVxdWFsIHRoZW4gdGhlIGVsZW1lbnQgbW92ZWQsIHNvIHdlIHJlZnJlc2guXG4gICAgICAgIHJlZnJlc2goKTtcbiAgICAgIH1cbiAgICAgIGlzRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBPbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IGEgYGRvY3VtZW50YCBhcyB0aGUgcm9vdCBhbmQgd2lsbCB0aHJvdyBhblxuICAgIC8vIGVycm9yLlxuICAgIHRyeSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogcm9vdC5vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlvLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmVmcmVzaCh0cnVlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIG5lY2Vzc2FyeS5cbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG1vdW50ZWQgb24gdGhlIERPTSBvclxuICogdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQHJldHVybnMgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9yIGhpZGRlbiBmcm9tIHRoZSBzY3JlZW4uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbCA9IHRydWUsXG4gICAgYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihyZWZlcmVuY2VFbCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZUVsKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfcmVmID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdXBkYXRlIGxvb3BzIHdoZW4gdXNpbmcgdGhlIGBzaXplYCBtaWRkbGV3YXJlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3NDBcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAhcmVjdHNBcmVFcXVhbChwcmV2UmVmUmVjdCwgbmV4dFJlZlJlY3QpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5jb25zdCBkZXRlY3RPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93JDE7XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IG9mZnNldCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGF1dG9QbGFjZW1lbnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gc2hpZnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmbGlwJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IHNpemUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBoaWRlJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gYXJyb3ckMTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gaW5saW5lJDE7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBsaW1pdFNoaWZ0JDE7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4ge1xuICAvLyBUaGlzIGNhY2hlcyB0aGUgZXhwZW5zaXZlIGBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnNgIGZ1bmN0aW9uIHNvIHRoYXRcbiAgLy8gbXVsdGlwbGUgbGlmZWN5Y2xlIHJlc2V0cyByZS11c2UgdGhlIHNhbWUgcmVzdWx0LiBJdCBvbmx5IGxpdmVzIGZvciBhXG4gIC8vIHNpbmdsZSBjYWxsLiBJZiBvdGhlciBmdW5jdGlvbnMgYmVjb21lIGV4cGVuc2l2ZSwgd2UgY2FuIGFkZCB0aGVtIGFzIHdlbGwuXG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH07XG4iXSwibmFtZXMiOlsicmVjdFRvQ2xpZW50UmVjdCIsImFycm93IiwiYXJyb3ckMSIsImF1dG9QbGFjZW1lbnQiLCJhdXRvUGxhY2VtZW50JDEiLCJkZXRlY3RPdmVyZmxvdyIsImRldGVjdE92ZXJmbG93JDEiLCJmbGlwIiwiZmxpcCQxIiwiaGlkZSIsImhpZGUkMSIsImlubGluZSIsImlubGluZSQxIiwibGltaXRTaGlmdCIsImxpbWl0U2hpZnQkMSIsIm9mZnNldCIsIm9mZnNldCQxIiwic2hpZnQiLCJzaGlmdCQxIiwic2l6ZSIsInNpemUkMSIsImNvbXB1dGVQb3NpdGlvbiIsImNvbXB1dGVQb3NpdGlvbiQxIiwicm91bmQiLCJjcmVhdGVDb29yZHMiLCJtYXgiLCJtaW4iLCJmbG9vciIsImdldENvbXB1dGVkU3R5bGUiLCJpc0hUTUxFbGVtZW50IiwiaXNFbGVtZW50IiwiZ2V0V2luZG93IiwiaXNXZWJLaXQiLCJnZXRGcmFtZUVsZW1lbnQiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiaXNUb3BMYXllciIsImdldE5vZGVOYW1lIiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJpc0NvbnRhaW5pbmdCbG9jayIsImlzVGFibGVFbGVtZW50IiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiZ2V0Q3NzRGltZW5zaW9ucyIsImVsZW1lbnQiLCJjc3MiLCJ3aWR0aCIsInBhcnNlRmxvYXQiLCJoZWlnaHQiLCJoYXNPZmZzZXQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInNob3VsZEZhbGxiYWNrIiwiJCIsInVud3JhcEVsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldFNjYWxlIiwiZG9tRWxlbWVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwieSIsIk51bWJlciIsImlzRmluaXRlIiwibm9PZmZzZXRzIiwiZ2V0VmlzdWFsT2Zmc2V0cyIsIndpbiIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsInNob3VsZEFkZFZpc3VhbE9mZnNldHMiLCJpc0ZpeGVkIiwiZmxvYXRpbmdPZmZzZXRQYXJlbnQiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJvZmZzZXRQYXJlbnQiLCJjbGllbnRSZWN0Iiwic2NhbGUiLCJ2aXN1YWxPZmZzZXRzIiwibGVmdCIsInRvcCIsIm9mZnNldFdpbiIsImN1cnJlbnRXaW4iLCJjdXJyZW50SUZyYW1lIiwiaWZyYW1lU2NhbGUiLCJpZnJhbWVSZWN0IiwiY2xpZW50TGVmdCIsInBhZGRpbmdMZWZ0IiwiY2xpZW50VG9wIiwicGFkZGluZ1RvcCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJsZWZ0U2Nyb2xsIiwic2Nyb2xsTGVmdCIsImdldEhUTUxPZmZzZXQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGwiLCJpZ25vcmVTY3JvbGxiYXJYIiwiaHRtbFJlY3QiLCJzY3JvbGxUb3AiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJlbGVtZW50cyIsInN0cmF0ZWd5IiwidG9wTGF5ZXIiLCJmbG9hdGluZyIsIm9mZnNldHMiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFJlY3QiLCJodG1sT2Zmc2V0IiwiZ2V0Q2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXREb2N1bWVudFJlY3QiLCJodG1sIiwiYm9keSIsIm93bmVyRG9jdW1lbnQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZGlyZWN0aW9uIiwiZ2V0Vmlld3BvcnRSZWN0IiwidmlzdWFsVmlld3BvcnRCYXNlZCIsImFic29sdXRlT3JGaXhlZCIsIlNldCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdBbmNlc3RvciIsImhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvciIsInN0b3BOb2RlIiwicGFyZW50Tm9kZSIsInBvc2l0aW9uIiwiZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzIiwiY2FjaGUiLCJjYWNoZWRSZXN1bHQiLCJnZXQiLCJyZXN1bHQiLCJmaWx0ZXIiLCJlbCIsImN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIiwiZWxlbWVudElzRml4ZWQiLCJjdXJyZW50Tm9kZSIsImNvbXB1dGVkU3R5bGUiLCJjdXJyZW50Tm9kZUlzQ29udGFpbmluZyIsInNob3VsZERyb3BDdXJyZW50Tm9kZSIsImhhcyIsImFuY2VzdG9yIiwic2V0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMiLCJfYyIsImNvbmNhdCIsImNsaXBwaW5nQW5jZXN0b3JzIiwiZmlyc3RDbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdSZWN0IiwicmVkdWNlIiwiYWNjUmVjdCIsInJpZ2h0IiwiYm90dG9tIiwiZ2V0RGltZW5zaW9ucyIsImdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50Iiwic2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCIsImlzU3RhdGljUG9zaXRpb25lZCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJwb2x5ZmlsbCIsInJhd09mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsInN2Z09mZnNldFBhcmVudCIsImdldEVsZW1lbnRSZWN0cyIsImRhdGEiLCJnZXRPZmZzZXRQYXJlbnRGbiIsImdldERpbWVuc2lvbnNGbiIsImZsb2F0aW5nRGltZW5zaW9ucyIsInJlZmVyZW5jZSIsImlzUlRMIiwicGxhdGZvcm0iLCJyZWN0c0FyZUVxdWFsIiwiYSIsImIiLCJvYnNlcnZlTW92ZSIsIm9uTW92ZSIsImlvIiwidGltZW91dElkIiwicm9vdCIsImNsZWFudXAiLCJfaW8iLCJjbGVhclRpbWVvdXQiLCJkaXNjb25uZWN0IiwicmVmcmVzaCIsInNraXAiLCJ0aHJlc2hvbGQiLCJlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4iLCJpbnNldFRvcCIsImluc2V0UmlnaHQiLCJpbnNldEJvdHRvbSIsImluc2V0TGVmdCIsInJvb3RNYXJnaW4iLCJvcHRpb25zIiwiaXNGaXJzdFVwZGF0ZSIsImhhbmRsZU9ic2VydmUiLCJlbnRyaWVzIiwicmF0aW8iLCJpbnRlcnNlY3Rpb25SYXRpbyIsInNldFRpbWVvdXQiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIl9lIiwib2JzZXJ2ZSIsImF1dG9VcGRhdGUiLCJ1cGRhdGUiLCJhbmNlc3RvclNjcm9sbCIsImFuY2VzdG9yUmVzaXplIiwiZWxlbWVudFJlc2l6ZSIsIlJlc2l6ZU9ic2VydmVyIiwibGF5b3V0U2hpZnQiLCJhbmltYXRpb25GcmFtZSIsInJlZmVyZW5jZUVsIiwiYW5jZXN0b3JzIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiY2xlYW51cElvIiwicmVvYnNlcnZlRnJhbWUiLCJyZXNpemVPYnNlcnZlciIsImZpcnN0RW50cnkiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9yZXNpemVPYnNlcnZlciIsImZyYW1lSWQiLCJwcmV2UmVmUmVjdCIsImZyYW1lTG9vcCIsIm5leHRSZWZSZWN0IiwiX3Jlc2l6ZU9ic2VydmVyMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJNYXAiLCJtZXJnZWRPcHRpb25zIiwicGxhdGZvcm1XaXRoQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\nvar isClient = typeof document !== \"undefined\";\nvar noop = function noop() {};\nvar index = isClient ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : noop;\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (typeof a === \"function\" && a.toString() === b.toString()) {\n        return true;\n    }\n    let length;\n    let i;\n    let keys;\n    if (a && b && typeof a === \"object\") {\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length !== b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!deepEqual(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n            return false;\n        }\n        for(i = length; i-- !== 0;){\n            if (!({}).hasOwnProperty.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for(i = length; i-- !== 0;){\n            const key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nfunction getDPR(element) {\n    if (true) {\n        return 1;\n    }\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options;\n    const [data, setData] = react__WEBPACK_IMPORTED_MODULE_2__.useState({\n        x: 0,\n        y: 0,\n        strategy,\n        placement,\n        middlewareData: {},\n        isPositioned: false\n    });\n    const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_2__.useState(middleware);\n    if (!deepEqual(latestMiddleware, middleware)) {\n        setLatestMiddleware(middleware);\n    }\n    const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n    const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_2__.useCallback((node)=>{\n        if (node !== referenceRef.current) {\n            referenceRef.current = node;\n            _setReference(node);\n        }\n    }, []);\n    const setFloating = react__WEBPACK_IMPORTED_MODULE_2__.useCallback((node)=>{\n        if (node !== floatingRef.current) {\n            floatingRef.current = node;\n            _setFloating(node);\n        }\n    }, []);\n    const referenceEl = externalReference || _reference;\n    const floatingEl = externalFloating || _floating;\n    const referenceRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const floatingRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(data);\n    const hasWhileElementsMounted = whileElementsMounted != null;\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const platformRef = useLatestRef(platform);\n    const openRef = useLatestRef(open);\n    const update = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(()=>{\n        if (!referenceRef.current || !floatingRef.current) {\n            return;\n        }\n        const config = {\n            placement,\n            strategy,\n            middleware: latestMiddleware\n        };\n        if (platformRef.current) {\n            config.platform = platformRef.current;\n        }\n        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then((data)=>{\n            const fullData = {\n                ...data,\n                // The floating element's position may be recomputed while it's closed\n                // but still mounted (such as when transitioning out). To ensure\n                // `isPositioned` will be `false` initially on the next open, avoid\n                // setting it to `true` when `open === false` (must be specified).\n                isPositioned: openRef.current !== false\n            };\n            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n                dataRef.current = fullData;\n                react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync(()=>{\n                    setData(fullData);\n                });\n            }\n        });\n    }, [\n        latestMiddleware,\n        placement,\n        strategy,\n        platformRef,\n        openRef\n    ]);\n    index(()=>{\n        if (open === false && dataRef.current.isPositioned) {\n            dataRef.current.isPositioned = false;\n            setData((data)=>({\n                    ...data,\n                    isPositioned: false\n                }));\n        }\n    }, [\n        open\n    ]);\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);\n    index(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    index(()=>{\n        if (referenceEl) referenceRef.current = referenceEl;\n        if (floatingEl) floatingRef.current = floatingEl;\n        if (referenceEl && floatingEl) {\n            if (whileElementsMountedRef.current) {\n                return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n            }\n            update();\n        }\n    }, [\n        referenceEl,\n        floatingEl,\n        update,\n        whileElementsMountedRef,\n        hasWhileElementsMounted\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            reference: referenceRef,\n            floating: floatingRef,\n            setReference,\n            setFloating\n        }), [\n        setReference,\n        setFloating\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            reference: referenceEl,\n            floating: floatingEl\n        }), [\n        referenceEl,\n        floatingEl\n    ]);\n    const floatingStyles = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>{\n        const initialStyles = {\n            position: strategy,\n            left: 0,\n            top: 0\n        };\n        if (!elements.floating) {\n            return initialStyles;\n        }\n        const x = roundByDPR(elements.floating, data.x);\n        const y = roundByDPR(elements.floating, data.y);\n        if (transform) {\n            return {\n                ...initialStyles,\n                transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n                ...getDPR(elements.floating) >= 1.5 && {\n                    willChange: \"transform\"\n                }\n            };\n        }\n        return {\n            position: strategy,\n            left: x,\n            top: y\n        };\n    }, [\n        strategy,\n        transform,\n        elements.floating,\n        data.x,\n        data.y\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>({\n            ...data,\n            update,\n            refs,\n            elements,\n            floatingStyles\n        }), [\n        data,\n        update,\n        refs,\n        elements,\n        floatingStyles\n    ]);\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow$1 = (options)=>{\n    function isRef(value) {\n        return ({}).hasOwnProperty.call(value, \"current\");\n    }\n    return {\n        name: \"arrow\",\n        options,\n        fn (state) {\n            const { element, padding } = typeof options === \"function\" ? options(state) : options;\n            if (element && isRef(element)) {\n                if (element.current != null) {\n                    return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                        element: element.current,\n                        padding\n                    }).fn(state);\n                }\n                return {};\n            }\n            if (element) {\n                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                    element,\n                    padding\n                }).fn(state);\n            }\n            return {};\n        }\n    };\n};\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = (options, deps)=>({\n        ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline)(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options, deps)=>({\n        ...arrow$1(options),\n        options: [\n            options,\n            deps\n        ]\n    });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2TztBQUM5SDtBQUNoRjtBQUNTO0FBQ0Y7QUFFdEMsSUFBSTBCLFdBQVcsT0FBT0MsYUFBYTtBQUVuQyxJQUFJQyxPQUFPLFNBQVNBLFFBQVE7QUFDNUIsSUFBSUMsUUFBUUgsV0FBV0Ysa0RBQWVBLEdBQUdJO0FBRXpDLGdGQUFnRjtBQUNoRixZQUFZO0FBQ1osU0FBU0UsVUFBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JCLElBQUlELE1BQU1DLEdBQUc7UUFDWCxPQUFPO0lBQ1Q7SUFDQSxJQUFJLE9BQU9ELE1BQU0sT0FBT0MsR0FBRztRQUN6QixPQUFPO0lBQ1Q7SUFDQSxJQUFJLE9BQU9ELE1BQU0sY0FBY0EsRUFBRUUsUUFBUSxPQUFPRCxFQUFFQyxRQUFRLElBQUk7UUFDNUQsT0FBTztJQUNUO0lBQ0EsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUwsS0FBS0MsS0FBSyxPQUFPRCxNQUFNLFVBQVU7UUFDbkMsSUFBSU0sTUFBTUMsT0FBTyxDQUFDUCxJQUFJO1lBQ3BCRyxTQUFTSCxFQUFFRyxNQUFNO1lBQ2pCLElBQUlBLFdBQVdGLEVBQUVFLE1BQU0sRUFBRSxPQUFPO1lBQ2hDLElBQUtDLElBQUlELFFBQVFDLFFBQVEsR0FBSTtnQkFDM0IsSUFBSSxDQUFDTCxVQUFVQyxDQUFDLENBQUNJLEVBQUUsRUFBRUgsQ0FBQyxDQUFDRyxFQUFFLEdBQUc7b0JBQzFCLE9BQU87Z0JBQ1Q7WUFDRjtZQUNBLE9BQU87UUFDVDtRQUNBQyxPQUFPRyxPQUFPSCxJQUFJLENBQUNMO1FBQ25CRyxTQUFTRSxLQUFLRixNQUFNO1FBQ3BCLElBQUlBLFdBQVdLLE9BQU9ILElBQUksQ0FBQ0osR0FBR0UsTUFBTSxFQUFFO1lBQ3BDLE9BQU87UUFDVDtR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O0lBQzFCO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNdEgsUUFBUSxDQUFDNEQsU0FBUzBELE9BQVU7UUFDaEMsR0FBR04sUUFBUXBELFFBQVE7UUFDbkJBLFNBQVM7WUFBQ0E7WUFBUzBEO1NBQUs7SUFDMUI7QUFFa0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZ3QtY2xpbmljLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC1kb20vZGlzdC9mbG9hdGluZy11aS5yZWFjdC1kb20ubWpzP2M3OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tcHV0ZVBvc2l0aW9uLCBhcnJvdyBhcyBhcnJvdyQyLCBhdXRvUGxhY2VtZW50IGFzIGF1dG9QbGFjZW1lbnQkMSwgZmxpcCBhcyBmbGlwJDEsIGhpZGUgYXMgaGlkZSQxLCBpbmxpbmUgYXMgaW5saW5lJDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBvZmZzZXQgYXMgb2Zmc2V0JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIHNpemUgYXMgc2l6ZSQxIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5leHBvcnQgeyBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgcGxhdGZvcm0gfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbnZhciBpc0NsaWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIGluZGV4ID0gaXNDbGllbnQgPyB1c2VMYXlvdXRFZmZlY3QgOiBub29wO1xuXG4vLyBGb3JrIG9mIGBmYXN0LWRlZXAtZXF1YWxgIHRoYXQgb25seSBkb2VzIHRoZSBjb21wYXJpc29ucyB3ZSBuZWVkIGFuZCBjb21wYXJlc1xuLy8gZnVuY3Rpb25zXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICYmIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IGxlbmd0aDtcbiAgbGV0IGk7XG4gIGxldCBrZXlzO1xuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gJ19vd25lcicgJiYgYS4kJHR5cGVvZikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbmZ1bmN0aW9uIGdldERQUihlbGVtZW50KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGNvbnN0IHdpbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xufVxuXG5mdW5jdGlvbiByb3VuZEJ5RFBSKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRwciA9IGdldERQUihlbGVtZW50KTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBkcHIpIC8gZHByO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZsb2F0aW5nXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlOiBleHRlcm5hbFJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nOiBleHRlcm5hbEZsb2F0aW5nXG4gICAgfSA9IHt9LFxuICAgIHRyYW5zZm9ybSA9IHRydWUsXG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQsXG4gICAgb3BlblxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBzdHJhdGVneSxcbiAgICBwbGFjZW1lbnQsXG4gICAgbWlkZGxld2FyZURhdGE6IHt9LFxuICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IFtsYXRlc3RNaWRkbGV3YXJlLCBzZXRMYXRlc3RNaWRkbGV3YXJlXSA9IFJlYWN0LnVzZVN0YXRlKG1pZGRsZXdhcmUpO1xuICBpZiAoIWRlZXBFcXVhbChsYXRlc3RNaWRkbGV3YXJlLCBtaWRkbGV3YXJlKSkge1xuICAgIHNldExhdGVzdE1pZGRsZXdhcmUobWlkZGxld2FyZSk7XG4gIH1cbiAgY29uc3QgW19yZWZlcmVuY2UsIF9zZXRSZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtfZmxvYXRpbmcsIF9zZXRGbG9hdGluZ10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IHJlZmVyZW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICByZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzZXRGbG9hdGluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSBmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICBmbG9hdGluZ1JlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIF9zZXRGbG9hdGluZyhub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSBleHRlcm5hbFJlZmVyZW5jZSB8fCBfcmVmZXJlbmNlO1xuICBjb25zdCBmbG9hdGluZ0VsID0gZXh0ZXJuYWxGbG9hdGluZyB8fCBfZmxvYXRpbmc7XG4gIGNvbnN0IHJlZmVyZW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZmxvYXRpbmdSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoZGF0YSk7XG4gIGNvbnN0IGhhc1doaWxlRWxlbWVudHNNb3VudGVkID0gd2hpbGVFbGVtZW50c01vdW50ZWQgIT0gbnVsbDtcbiAgY29uc3Qgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYgPSB1c2VMYXRlc3RSZWYod2hpbGVFbGVtZW50c01vdW50ZWQpO1xuICBjb25zdCBwbGF0Zm9ybVJlZiA9IHVzZUxhdGVzdFJlZihwbGF0Zm9ybSk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3Blbik7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZVJlZi5jdXJyZW50IHx8ICFmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZTogbGF0ZXN0TWlkZGxld2FyZVxuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbmZpZy5wbGF0Zm9ybSA9IHBsYXRmb3JtUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGNvbXB1dGVQb3NpdGlvbihyZWZlcmVuY2VSZWYuY3VycmVudCwgZmxvYXRpbmdSZWYuY3VycmVudCwgY29uZmlnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3QgZnVsbERhdGEgPSB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIC8vIFRoZSBmbG9hdGluZyBlbGVtZW50J3MgcG9zaXRpb24gbWF5IGJlIHJlY29tcHV0ZWQgd2hpbGUgaXQncyBjbG9zZWRcbiAgICAgICAgLy8gYnV0IHN0aWxsIG1vdW50ZWQgKHN1Y2ggYXMgd2hlbiB0cmFuc2l0aW9uaW5nIG91dCkuIFRvIGVuc3VyZVxuICAgICAgICAvLyBgaXNQb3NpdGlvbmVkYCB3aWxsIGJlIGBmYWxzZWAgaW5pdGlhbGx5IG9uIHRoZSBuZXh0IG9wZW4sIGF2b2lkXG4gICAgICAgIC8vIHNldHRpbmcgaXQgdG8gYHRydWVgIHdoZW4gYG9wZW4gPT09IGZhbHNlYCAobXVzdCBiZSBzcGVjaWZpZWQpLlxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IG9wZW5SZWYuY3VycmVudCAhPT0gZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgIWRlZXBFcXVhbChkYXRhUmVmLmN1cnJlbnQsIGZ1bGxEYXRhKSkge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQgPSBmdWxsRGF0YTtcbiAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBzZXREYXRhKGZ1bGxEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtsYXRlc3RNaWRkbGV3YXJlLCBwbGFjZW1lbnQsIHN0cmF0ZWd5LCBwbGF0Zm9ybVJlZiwgb3BlblJlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4gPT09IGZhbHNlICYmIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQpIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICAgIHNldERhdGEoZGF0YSA9PiAoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChyZWZlcmVuY2VFbCkgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSByZWZlcmVuY2VFbDtcbiAgICBpZiAoZmxvYXRpbmdFbCkgZmxvYXRpbmdSZWYuY3VycmVudCA9IGZsb2F0aW5nRWw7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmIGZsb2F0aW5nRWwpIHtcbiAgICAgIGlmICh3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KHJlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUpO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9LCBbcmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSwgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYsIGhhc1doaWxlRWxlbWVudHNNb3VudGVkXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VSZWYsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nUmVmLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRGbG9hdGluZ1xuICB9KSwgW3NldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmddKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VFbCxcbiAgICBmbG9hdGluZzogZmxvYXRpbmdFbFxuICB9KSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsXSk7XG4gIGNvbnN0IGZsb2F0aW5nU3R5bGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGlmICghZWxlbWVudHMuZmxvYXRpbmcpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3R5bGVzO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS54KTtcbiAgICBjb25zdCB5ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS55KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbml0aWFsU3R5bGVzLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIsXG4gICAgICAgIC4uLihnZXREUFIoZWxlbWVudHMuZmxvYXRpbmcpID49IDEuNSAmJiB7XG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybSdcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5XG4gICAgfTtcbiAgfSwgW3N0cmF0ZWd5LCB0cmFuc2Zvcm0sIGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngsIGRhdGEueV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmRhdGEsXG4gICAgdXBkYXRlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdTdHlsZXNcbiAgfSksIFtkYXRhLCB1cGRhdGUsIHJlZnMsIGVsZW1lbnRzLCBmbG9hdGluZ1N0eWxlc10pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3ckMSA9IG9wdGlvbnMgPT4ge1xuICBmdW5jdGlvbiBpc1JlZih2YWx1ZSkge1xuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY3VycmVudCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHBhZGRpbmdcbiAgICAgIH0gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMoc3RhdGUpIDogb3B0aW9ucztcbiAgICAgIGlmIChlbGVtZW50ICYmIGlzUmVmKGVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcnJvdyQyKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFycm93JDIoe1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcGFkZGluZ1xuICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLm9mZnNldCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uc2hpZnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5saW1pdFNoaWZ0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmZsaXAkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLnNpemUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uYXV0b1BsYWNlbWVudCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5oaWRlJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5pbmxpbmUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBUaGlzIHdyYXBzIHRoZSBjb3JlIGBhcnJvd2AgbWlkZGxld2FyZSB0byBhbGxvdyBSZWFjdCByZWZzIGFzIHRoZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmFycm93JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2hpZnQsIHNpemUsIHVzZUZsb2F0aW5nIH07XG4iXSwibmFtZXMiOlsiY29tcHV0ZVBvc2l0aW9uIiwiYXJyb3ciLCJhcnJvdyQyIiwiYXV0b1BsYWNlbWVudCIsImF1dG9QbGFjZW1lbnQkMSIsImZsaXAiLCJmbGlwJDEiLCJoaWRlIiwiaGlkZSQxIiwiaW5saW5lIiwiaW5saW5lJDEiLCJsaW1pdFNoaWZ0IiwibGltaXRTaGlmdCQxIiwib2Zmc2V0Iiwib2Zmc2V0JDEiLCJzaGlmdCIsInNoaWZ0JDEiLCJzaXplIiwic2l6ZSQxIiwiYXV0b1VwZGF0ZSIsImRldGVjdE92ZXJmbG93IiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJwbGF0Zm9ybSIsIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiUmVhY3RET00iLCJpc0NsaWVudCIsImRvY3VtZW50Iiwibm9vcCIsImluZGV4IiwiZGVlcEVxdWFsIiwiYSIsImIiLCJ0b1N0cmluZyIsImxlbmd0aCIsImkiLCJrZXlzIiwiQXJyYXkiLCJpc0FycmF5IiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwia2V5IiwiJCR0eXBlb2YiLCJnZXREUFIiLCJlbGVtZW50Iiwid2luIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInJvdW5kQnlEUFIiLCJ2YWx1ZSIsImRwciIsIk1hdGgiLCJyb3VuZCIsInVzZUxhdGVzdFJlZiIsInJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJ1c2VGbG9hdGluZyIsIm9wdGlvbnMiLCJwbGFjZW1lbnQiLCJzdHJhdGVneSIsIm1pZGRsZXdhcmUiLCJlbGVtZW50cyIsInJlZmVyZW5jZSIsImV4dGVybmFsUmVmZXJlbmNlIiwiZmxvYXRpbmciLCJleHRlcm5hbEZsb2F0aW5nIiwidHJhbnNmb3JtIiwid2hpbGVFbGVtZW50c01vdW50ZWQiLCJvcGVuIiwiZGF0YSIsInNldERhdGEiLCJ1c2VTdGF0ZSIsIngiLCJ5IiwibWlkZGxld2FyZURhdGEiLCJpc1Bvc2l0aW9uZWQiLCJsYXRlc3RNaWRkbGV3YXJlIiwic2V0TGF0ZXN0TWlkZGxld2FyZSIsIl9yZWZlcmVuY2UiLCJfc2V0UmVmZXJlbmNlIiwiX2Zsb2F0aW5nIiwiX3NldEZsb2F0aW5nIiwic2V0UmVmZXJlbmNlIiwidXNlQ2FsbGJhY2siLCJub2RlIiwicmVmZXJlbmNlUmVmIiwic2V0RmxvYXRpbmciLCJmbG9hdGluZ1JlZiIsInJlZmVyZW5jZUVsIiwiZmxvYXRpbmdFbCIsImRhdGFSZWYiLCJoYXNXaGlsZUVsZW1lbnRzTW91bnRlZCIsIndoaWxlRWxlbWVudHNNb3VudGVkUmVmIiwicGxhdGZvcm1SZWYiLCJvcGVuUmVmIiwidXBkYXRlIiwiY29uZmlnIiwidGhlbiIsImZ1bGxEYXRhIiwiaXNNb3VudGVkUmVmIiwiZmx1c2hTeW5jIiwicmVmcyIsInVzZU1lbW8iLCJmbG9hdGluZ1N0eWxlcyIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJ3aWxsQ2hhbmdlIiwiYXJyb3ckMSIsImlzUmVmIiwibmFtZSIsImZuIiwic3RhdGUiLCJwYWRkaW5nIiwiZGVwcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   NextFloatingDelayGroup: () => (/* binding */ NextFloatingDelayGroup),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingRootContext: () => (/* binding */ useFloatingRootContext),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useNextDelayGroup: () => (/* binding */ useNextDelayGroup),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */ function useMergeRefs(refs) {\n    const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance)=>{\n        const cleanups = refs.map((ref)=>{\n            if (ref == null) {\n                return;\n            }\n            if (typeof ref === \"function\") {\n                const refCallback = ref;\n                const refCleanup = refCallback(instance);\n                return typeof refCleanup === \"function\" ? refCleanup : ()=>{\n                    refCallback(null);\n                };\n            }\n            ref.current = instance;\n            return ()=>{\n                ref.current = null;\n            };\n        });\n        return ()=>{\n            cleanups.forEach((refCleanup)=>refCleanup == null ? void 0 : refCleanup());\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (refs.every((ref)=>ref == null)) {\n            return null;\n        }\n        return (value)=>{\n            if (cleanupRef.current) {\n                cleanupRef.current();\n                cleanupRef.current = undefined;\n            }\n            if (value != null) {\n                cleanupRef.current = refEffect(value);\n            }\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n}\nfunction sortByDocumentPosition(a, b) {\n    const position = a.compareDocumentPosition(b);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n        return -1;\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n        return 1;\n    }\n    return 0;\n}\nconst FloatingListContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    register: ()=>{},\n    unregister: ()=>{},\n    map: /*#__PURE__*/ new Map(),\n    elementsRef: {\n        current: []\n    }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */ function FloatingList(props) {\n    const { children, elementsRef, labelsRef } = props;\n    const [nodes, setNodes] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new Set());\n    const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setNodes((prevSet)=>new Set(prevSet).add(node));\n    }, []);\n    const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setNodes((prevSet)=>{\n            const set = new Set(prevSet);\n            set.delete(node);\n            return set;\n        });\n    }, []);\n    const map = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const newMap = new Map();\n        const sortedNodes = Array.from(nodes.keys()).sort(sortByDocumentPosition);\n        sortedNodes.forEach((node, index)=>{\n            newMap.set(node, index);\n        });\n        return newMap;\n    }, [\n        nodes\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingListContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                register,\n                unregister,\n                map,\n                elementsRef,\n                labelsRef\n            }), [\n            register,\n            unregister,\n            map,\n            elementsRef,\n            labelsRef\n        ]),\n        children: children\n    });\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */ function useListItem(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { label } = props;\n    const { register, unregister, map, elementsRef, labelsRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n    const [index, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        componentRef.current = node;\n        if (index !== null) {\n            elementsRef.current[index] = node;\n            if (labelsRef) {\n                var _node$textContent;\n                const isLabelDefined = label !== undefined;\n                labelsRef.current[index] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n            }\n        }\n    }, [\n        index,\n        elementsRef,\n        labelsRef,\n        label\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        const node = componentRef.current;\n        if (node) {\n            register(node);\n            return ()=>{\n                unregister(node);\n            };\n        }\n    }, [\n        register,\n        unregister\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        const index = componentRef.current ? map.get(componentRef.current) : null;\n        if (index != null) {\n            setIndex(index);\n        }\n    }, [\n        map\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ref,\n            index: index == null ? -1 : index\n        }), [\n        index,\n        ref\n    ]);\n}\nconst FOCUSABLE_ATTRIBUTE = \"data-floating-ui-focusable\";\nconst ACTIVE_KEY = \"active\";\nconst SELECTED_KEY = \"selected\";\nconst ARROW_LEFT = \"ArrowLeft\";\nconst ARROW_RIGHT = \"ArrowRight\";\nconst ARROW_UP = \"ArrowUp\";\nconst ARROW_DOWN = \"ArrowDown\";\nfunction renderJsx(render, computedProps) {\n    if (typeof render === \"function\") {\n        return render(computedProps);\n    }\n    if (render) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n    }\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ...computedProps\n    });\n}\nconst CompositeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    activeIndex: 0,\n    onNavigate: ()=>{}\n});\nconst horizontalKeys = [\n    ARROW_LEFT,\n    ARROW_RIGHT\n];\nconst verticalKeys = [\n    ARROW_UP,\n    ARROW_DOWN\n];\nconst allKeys = [\n    ...horizontalKeys,\n    ...verticalKeys\n];\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that arenâ€™t part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */ const Composite = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(props, forwardedRef) {\n    const { render, orientation = \"both\", loop = true, rtl = false, cols = 1, disabledIndices, activeIndex: externalActiveIndex, onNavigate: externalSetActiveIndex, itemSizes, dense = false, ...domProps } = props;\n    const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n    const onNavigate = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n    const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            activeIndex,\n            onNavigate\n        }), [\n        activeIndex,\n        onNavigate\n    ]);\n    const isGrid = cols > 1;\n    function handleKeyDown(event) {\n        if (!allKeys.includes(event.key)) return;\n        let nextIndex = activeIndex;\n        const minIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMinListIndex)(elementsRef, disabledIndices);\n        const maxIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMaxListIndex)(elementsRef, disabledIndices);\n        const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;\n        const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;\n        if (isGrid) {\n            const sizes = itemSizes || Array.from({\n                length: elementsRef.current.length\n            }, ()=>({\n                    width: 1,\n                    height: 1\n                }));\n            // To calculate movements on the grid, we use hypothetical cell indices\n            // as if every item was 1x1, then convert back to real indices.\n            const cellMap = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.createGridCellMap)(sizes, cols, dense);\n            const minGridIndex = cellMap.findIndex((index)=>index != null && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(elementsRef, index, disabledIndices));\n            // last enabled index\n            const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex)=>index != null && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(elementsRef, index, disabledIndices) ? cellIndex : foundIndex, -1);\n            const maybeNextIndex = cellMap[(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridNavigatedIndex)({\n                current: cellMap.map((itemIndex)=>itemIndex ? elementsRef.current[itemIndex] : null)\n            }, {\n                event,\n                orientation,\n                loop,\n                rtl,\n                cols,\n                // treat undefined (empty grid spaces) as disabled indices so we\n                // don't end up in them\n                disabledIndices: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridCellIndices)([\n                    ...(typeof disabledIndices !== \"function\" ? disabledIndices : null) || elementsRef.current.map((_, index)=>(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(elementsRef, index, disabledIndices) ? index : undefined),\n                    undefined\n                ], cellMap),\n                minIndex: minGridIndex,\n                maxIndex: maxGridIndex,\n                prevIndex: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridCellIndexOfCorner)(activeIndex > maxIndex ? minIndex : activeIndex, sizes, cellMap, cols, // use a corner matching the edge closest to the direction we're\n                // moving in so we don't end up in the same item. Prefer\n                // top/left over bottom/right.\n                event.key === ARROW_DOWN ? \"bl\" : event.key === horizontalEndKey ? \"tr\" : \"tl\")\n            })];\n            if (maybeNextIndex != null) {\n                nextIndex = maybeNextIndex;\n            }\n        }\n        const toEndKeys = {\n            horizontal: [\n                horizontalEndKey\n            ],\n            vertical: [\n                ARROW_DOWN\n            ],\n            both: [\n                horizontalEndKey,\n                ARROW_DOWN\n            ]\n        }[orientation];\n        const toStartKeys = {\n            horizontal: [\n                horizontalStartKey\n            ],\n            vertical: [\n                ARROW_UP\n            ],\n            both: [\n                horizontalStartKey,\n                ARROW_UP\n            ]\n        }[orientation];\n        const preventedKeys = isGrid ? allKeys : ({\n            horizontal: horizontalKeys,\n            vertical: verticalKeys,\n            both: allKeys\n        })[orientation];\n        if (nextIndex === activeIndex && [\n            ...toEndKeys,\n            ...toStartKeys\n        ].includes(event.key)) {\n            if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n                nextIndex = minIndex;\n            } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n                nextIndex = maxIndex;\n            } else {\n                nextIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(elementsRef, {\n                    startingIndex: nextIndex,\n                    decrement: toStartKeys.includes(event.key),\n                    disabledIndices\n                });\n            }\n        }\n        if (nextIndex !== activeIndex && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isIndexOutOfListBounds)(elementsRef, nextIndex)) {\n            var _elementsRef$current$;\n            event.stopPropagation();\n            if (preventedKeys.includes(event.key)) {\n                event.preventDefault();\n            }\n            onNavigate(nextIndex);\n            (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();\n        }\n    }\n    const computedProps = {\n        ...domProps,\n        ...renderElementProps,\n        ref: forwardedRef,\n        \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n        onKeyDown (e) {\n            domProps.onKeyDown == null || domProps.onKeyDown(e);\n            renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n            handleKeyDown(e);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositeContext.Provider, {\n        value: contextValue,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingList, {\n            elementsRef: elementsRef,\n            children: renderJsx(render, computedProps)\n        })\n    });\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */ const CompositeItem = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(props, forwardedRef) {\n    const { render, ...domProps } = props;\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const { activeIndex, onNavigate } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n    const { ref, index } = useListItem();\n    const mergedRef = useMergeRefs([\n        ref,\n        forwardedRef,\n        renderElementProps.ref\n    ]);\n    const isActive = activeIndex === index;\n    const computedProps = {\n        ...domProps,\n        ...renderElementProps,\n        ref: mergedRef,\n        tabIndex: isActive ? 0 : -1,\n        \"data-active\": isActive ? \"\" : undefined,\n        onFocus (e) {\n            domProps.onFocus == null || domProps.onFocus(e);\n            renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n            onNavigate(index);\n        }\n    };\n    return renderJsx(render, computedProps);\n});\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nconst SafeReact = {\n    .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n};\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = ()=>// on <React 18\n    \"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++;\nfunction useFloatingId() {\n    const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>serverHandoffComplete ? genId() : undefined);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (id == null) {\n            setId(genId());\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        serverHandoffComplete = true;\n    }, []);\n    return id;\n}\nconst useReactId = SafeReact.useId;\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */ const useId = useReactId || useFloatingId;\nlet devMessageSet;\nif (true) {\n    devMessageSet = /*#__PURE__*/ new Set();\n}\nfunction warn() {\n    var _devMessageSet;\n    for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n        messages[_key] = arguments[_key];\n    }\n    const message = \"Floating UI: \" + messages.join(\" \");\n    if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n        var _devMessageSet2;\n        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);\n        console.warn(message);\n    }\n}\nfunction error() {\n    var _devMessageSet3;\n    for(var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n        messages[_key2] = arguments[_key2];\n    }\n    const message = \"Floating UI: \" + messages.join(\" \");\n    if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n        var _devMessageSet4;\n        (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);\n        console.error(message);\n    }\n}\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */ const FloatingArrow = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(props, ref) {\n    const { context: { placement, elements: { floating }, middlewareData: { arrow, shift } }, width = 14, height = 7, tipRadius = 0, strokeWidth = 0, staticOffset, stroke, d, style: { transform, ...restStyle } = {}, ...rest } = props;\n    if (true) {\n        if (!ref) {\n            warn(\"The `ref` prop is required for `FloatingArrow`.\");\n        }\n    }\n    const clipPathId = useId();\n    const [isRTL, setIsRTL] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    // https://github.com/floating-ui/floating-ui/issues/2932\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!floating) return;\n        const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getComputedStyle)(floating).direction === \"rtl\";\n        if (isRTL) {\n            setIsRTL(true);\n        }\n    }, [\n        floating\n    ]);\n    if (!floating) {\n        return null;\n    }\n    const [side, alignment] = placement.split(\"-\");\n    const isVerticalSide = side === \"top\" || side === \"bottom\";\n    let computedStaticOffset = staticOffset;\n    if (isVerticalSide && shift != null && shift.x || !isVerticalSide && shift != null && shift.y) {\n        computedStaticOffset = null;\n    }\n    // Strokes must be double the border width, this ensures the stroke's width\n    // works as you'd expect.\n    const computedStrokeWidth = strokeWidth * 2;\n    const halfStrokeWidth = computedStrokeWidth / 2;\n    const svgX = width / 2 * (tipRadius / -8 + 1);\n    const svgY = height / 2 * tipRadius / 4;\n    const isCustomShape = !!d;\n    const yOffsetProp = computedStaticOffset && alignment === \"end\" ? \"bottom\" : \"top\";\n    let xOffsetProp = computedStaticOffset && alignment === \"end\" ? \"right\" : \"left\";\n    if (computedStaticOffset && isRTL) {\n        xOffsetProp = alignment === \"end\" ? \"left\" : \"right\";\n    }\n    const arrowX = (arrow == null ? void 0 : arrow.x) != null ? computedStaticOffset || arrow.x : \"\";\n    const arrowY = (arrow == null ? void 0 : arrow.y) != null ? computedStaticOffset || arrow.y : \"\";\n    const dValue = d || \"M0,0\" + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + \" Z\";\n    const rotation = {\n        top: isCustomShape ? \"rotate(180deg)\" : \"\",\n        left: isCustomShape ? \"rotate(90deg)\" : \"rotate(-90deg)\",\n        bottom: isCustomShape ? \"\" : \"rotate(180deg)\",\n        right: isCustomShape ? \"rotate(-90deg)\" : \"rotate(90deg)\"\n    }[side];\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"svg\", {\n        ...rest,\n        \"aria-hidden\": true,\n        ref: ref,\n        width: isCustomShape ? width : width + computedStrokeWidth,\n        height: width,\n        viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n        style: {\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            [xOffsetProp]: arrowX,\n            [yOffsetProp]: arrowY,\n            [side]: isVerticalSide || isCustomShape ? \"100%\" : \"calc(100% - \" + computedStrokeWidth / 2 + \"px)\",\n            transform: [\n                rotation,\n                transform\n            ].filter((t)=>!!t).join(\" \"),\n            ...restStyle\n        },\n        children: [\n            computedStrokeWidth > 0 && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n                clipPath: \"url(#\" + clipPathId + \")\",\n                fill: \"none\",\n                stroke: stroke,\n                strokeWidth: computedStrokeWidth + (d ? 0 : 1),\n                d: dValue\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n                stroke: computedStrokeWidth && !d ? rest.fill : \"none\",\n                d: dValue\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"clipPath\", {\n                id: clipPathId,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"rect\", {\n                    x: -halfStrokeWidth,\n                    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n                    width: width + computedStrokeWidth,\n                    height: width\n                })\n            })\n        ]\n    });\n});\nfunction createEventEmitter() {\n    const map = new Map();\n    return {\n        emit (event, data) {\n            var _map$get;\n            (_map$get = map.get(event)) == null || _map$get.forEach((listener)=>listener(data));\n        },\n        on (event, listener) {\n            if (!map.has(event)) {\n                map.set(event, new Set());\n            }\n            map.get(event).add(listener);\n        },\n        off (event, listener) {\n            var _map$get2;\n            (_map$get2 = map.get(event)) == null || _map$get2.delete(listener);\n        }\n    };\n}\nconst FloatingNodeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */ const useFloatingParentNodeId = ()=>{\n    var _React$useContext;\n    return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n/**\n * Returns the nearest floating tree context, if available.\n */ const useFloatingTree = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function useFloatingNodeId(customParentId) {\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!id) return;\n        const node = {\n            id,\n            parentId\n        };\n        tree == null || tree.addNode(node);\n        return ()=>{\n            tree == null || tree.removeNode(node);\n        };\n    }, [\n        tree,\n        id,\n        parentId\n    ]);\n    return id;\n}\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingNode(props) {\n    const { children, id } = props;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingNodeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                id,\n                parentId\n            }), [\n            id,\n            parentId\n        ]),\n        children: children\n    });\n}\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingTree(props) {\n    const { children } = props;\n    const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = [\n            ...nodesRef.current,\n            node\n        ];\n    }, []);\n    const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = nodesRef.current.filter((n)=>n !== node);\n    }, []);\n    const [events] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createEventEmitter());\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingTreeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                nodesRef,\n                addNode,\n                removeNode,\n                events\n            }), [\n            addNode,\n            removeNode,\n            events\n        ]),\n        children: children\n    });\n}\nfunction createAttribute(name) {\n    return \"data-floating-ui-\" + name;\n}\nfunction clearTimeoutIfSet(timeoutRef) {\n    if (timeoutRef.current !== -1) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = -1;\n    }\n}\nconst safePolygonIdentifier = /*#__PURE__*/ createAttribute(\"safe-polygon\");\nfunction getDelay(value, prop, pointerType) {\n    if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType)) {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    if (typeof value === \"function\") {\n        const result = value();\n        if (typeof result === \"number\") {\n            return result;\n        }\n        return result == null ? void 0 : result[prop];\n    }\n    return value == null ? void 0 : value[prop];\n}\nfunction getRestMs(value) {\n    if (typeof value === \"function\") {\n        return value();\n    }\n    return value;\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */ function useHover(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, events, elements } = context;\n    const { enabled = true, delay = 0, handleClose = null, mouseOnly = false, restMs = 0, move = true } = props;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(handleClose);\n    const delayRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(delay);\n    const openRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(open);\n    const restMsRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(restMs);\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{});\n    const restTimeoutPendingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isHoverOpen = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(()=>{\n        var _dataRef$current$open;\n        const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n        return (type == null ? void 0 : type.includes(\"mouse\")) && type !== \"mousedown\";\n    });\n    // When closing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        function onOpenChange(_ref) {\n            let { open } = _ref;\n            if (!open) {\n                clearTimeoutIfSet(timeoutRef);\n                clearTimeoutIfSet(restTimeoutRef);\n                blockMouseMoveRef.current = true;\n                restTimeoutPendingRef.current = false;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        enabled,\n        events\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        if (!handleCloseRef.current) return;\n        if (!open) return;\n        function onLeave(event) {\n            if (isHoverOpen()) {\n                onOpenChange(false, event, \"hover\");\n            }\n        }\n        const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating).documentElement;\n        html.addEventListener(\"mouseleave\", onLeave);\n        return ()=>{\n            html.removeEventListener(\"mouseleave\", onLeave);\n        };\n    }, [\n        elements.floating,\n        open,\n        onOpenChange,\n        enabled,\n        handleCloseRef,\n        isHoverOpen\n    ]);\n    const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event, runElseBranch, reason) {\n        if (runElseBranch === void 0) {\n            runElseBranch = true;\n        }\n        if (reason === void 0) {\n            reason = \"hover\";\n        }\n        const closeDelay = getDelay(delayRef.current, \"close\", pointerTypeRef.current);\n        if (closeDelay && !handlerRef.current) {\n            clearTimeoutIfSet(timeoutRef);\n            timeoutRef.current = window.setTimeout(()=>onOpenChange(false, event, reason), closeDelay);\n        } else if (runElseBranch) {\n            clearTimeoutIfSet(timeoutRef);\n            onOpenChange(false, event, reason);\n        }\n    }, [\n        delayRef,\n        onOpenChange\n    ]);\n    const cleanupMouseMoveHandler = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(()=>{\n        unbindMouseMoveRef.current();\n        handlerRef.current = undefined;\n    });\n    const clearPointerEvents = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(()=>{\n        if (performedPointerEventsMutationRef.current) {\n            const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating).body;\n            body.style.pointerEvents = \"\";\n            body.removeAttribute(safePolygonIdentifier);\n            performedPointerEventsMutationRef.current = false;\n        }\n    });\n    const isClickLikeOpenEvent = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(()=>{\n        return dataRef.current.openEvent ? [\n            \"click\",\n            \"mousedown\"\n        ].includes(dataRef.current.openEvent.type) : false;\n    });\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        function onReferenceMouseEnter(event) {\n            clearTimeoutIfSet(timeoutRef);\n            blockMouseMoveRef.current = false;\n            if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, \"open\")) {\n                return;\n            }\n            const openDelay = getDelay(delayRef.current, \"open\", pointerTypeRef.current);\n            if (openDelay) {\n                timeoutRef.current = window.setTimeout(()=>{\n                    if (!openRef.current) {\n                        onOpenChange(true, event, \"hover\");\n                    }\n                }, openDelay);\n            } else if (!open) {\n                onOpenChange(true, event, \"hover\");\n            }\n        }\n        function onReferenceMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                clearPointerEvents();\n                return;\n            }\n            unbindMouseMoveRef.current();\n            const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating);\n            clearTimeoutIfSet(restTimeoutRef);\n            restTimeoutPendingRef.current = false;\n            if (handleCloseRef.current && dataRef.current.floatingContext) {\n                // Prevent clearing `onScrollMouseLeave` timeout.\n                if (!open) {\n                    clearTimeoutIfSet(timeoutRef);\n                }\n                handlerRef.current = handleCloseRef.current({\n                    ...dataRef.current.floatingContext,\n                    tree,\n                    x: event.clientX,\n                    y: event.clientY,\n                    onClose () {\n                        clearPointerEvents();\n                        cleanupMouseMoveHandler();\n                        if (!isClickLikeOpenEvent()) {\n                            closeWithDelay(event, true, \"safe-polygon\");\n                        }\n                    }\n                });\n                const handler = handlerRef.current;\n                doc.addEventListener(\"mousemove\", handler);\n                unbindMouseMoveRef.current = ()=>{\n                    doc.removeEventListener(\"mousemove\", handler);\n                };\n                return;\n            }\n            // Allow interactivity without `safePolygon` on touch devices. With a\n            // pointer, a short close delay is an alternative, so it should work\n            // consistently.\n            const shouldClose = pointerTypeRef.current === \"touch\" ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, event.relatedTarget) : true;\n            if (shouldClose) {\n                closeWithDelay(event);\n            }\n        }\n        // Ensure the floating element closes after scrolling even if the pointer\n        // did not move.\n        // https://github.com/floating-ui/floating-ui/discussions/1692\n        function onScrollMouseLeave(event) {\n            if (isClickLikeOpenEvent()) return;\n            if (!dataRef.current.floatingContext) return;\n            handleCloseRef.current == null || handleCloseRef.current({\n                ...dataRef.current.floatingContext,\n                tree,\n                x: event.clientX,\n                y: event.clientY,\n                onClose () {\n                    clearPointerEvents();\n                    cleanupMouseMoveHandler();\n                    if (!isClickLikeOpenEvent()) {\n                        closeWithDelay(event);\n                    }\n                }\n            })(event);\n        }\n        function onFloatingMouseEnter() {\n            clearTimeoutIfSet(timeoutRef);\n        }\n        function onFloatingMouseLeave(event) {\n            if (!isClickLikeOpenEvent()) {\n                closeWithDelay(event, false);\n            }\n        }\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.domReference)) {\n            const reference = elements.domReference;\n            const floating = elements.floating;\n            if (open) {\n                reference.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            }\n            if (move) {\n                reference.addEventListener(\"mousemove\", onReferenceMouseEnter, {\n                    once: true\n                });\n            }\n            reference.addEventListener(\"mouseenter\", onReferenceMouseEnter);\n            reference.addEventListener(\"mouseleave\", onReferenceMouseLeave);\n            if (floating) {\n                floating.addEventListener(\"mouseleave\", onScrollMouseLeave);\n                floating.addEventListener(\"mouseenter\", onFloatingMouseEnter);\n                floating.addEventListener(\"mouseleave\", onFloatingMouseLeave);\n            }\n            return ()=>{\n                if (open) {\n                    reference.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                }\n                if (move) {\n                    reference.removeEventListener(\"mousemove\", onReferenceMouseEnter);\n                }\n                reference.removeEventListener(\"mouseenter\", onReferenceMouseEnter);\n                reference.removeEventListener(\"mouseleave\", onReferenceMouseLeave);\n                if (floating) {\n                    floating.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                    floating.removeEventListener(\"mouseenter\", onFloatingMouseEnter);\n                    floating.removeEventListener(\"mouseleave\", onFloatingMouseLeave);\n                }\n            };\n        }\n    }, [\n        elements,\n        enabled,\n        context,\n        mouseOnly,\n        move,\n        closeWithDelay,\n        cleanupMouseMoveHandler,\n        clearPointerEvents,\n        onOpenChange,\n        open,\n        openRef,\n        tree,\n        delayRef,\n        handleCloseRef,\n        dataRef,\n        isClickLikeOpenEvent,\n        restMsRef\n    ]);\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        var _handleCloseRef$curre;\n        if (!enabled) return;\n        if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && (_handleCloseRef$curre = _handleCloseRef$curre.__options) != null && _handleCloseRef$curre.blockPointerEvents && isHoverOpen()) {\n            performedPointerEventsMutationRef.current = true;\n            const floatingEl = elements.floating;\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.domReference) && floatingEl) {\n                var _tree$nodesRef$curren;\n                const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating).body;\n                body.setAttribute(safePolygonIdentifier, \"\");\n                const ref = elements.domReference;\n                const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n                if (parentFloating) {\n                    parentFloating.style.pointerEvents = \"\";\n                }\n                body.style.pointerEvents = \"none\";\n                ref.style.pointerEvents = \"auto\";\n                floatingEl.style.pointerEvents = \"auto\";\n                return ()=>{\n                    body.style.pointerEvents = \"\";\n                    ref.style.pointerEvents = \"\";\n                    floatingEl.style.pointerEvents = \"\";\n                };\n            }\n        }\n    }, [\n        enabled,\n        open,\n        parentId,\n        elements,\n        tree,\n        handleCloseRef,\n        isHoverOpen\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!open) {\n            pointerTypeRef.current = undefined;\n            restTimeoutPendingRef.current = false;\n            cleanupMouseMoveHandler();\n            clearPointerEvents();\n        }\n    }, [\n        open,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            cleanupMouseMoveHandler();\n            clearTimeoutIfSet(timeoutRef);\n            clearTimeoutIfSet(restTimeoutRef);\n            clearPointerEvents();\n        };\n    }, [\n        enabled,\n        elements.domReference,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function setPointerRef(event) {\n            pointerTypeRef.current = event.pointerType;\n        }\n        return {\n            onPointerDown: setPointerRef,\n            onPointerEnter: setPointerRef,\n            onMouseMove (event) {\n                const { nativeEvent } = event;\n                function handleMouseMove() {\n                    if (!blockMouseMoveRef.current && !openRef.current) {\n                        onOpenChange(true, nativeEvent, \"hover\");\n                    }\n                }\n                if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current)) {\n                    return;\n                }\n                if (open || getRestMs(restMsRef.current) === 0) {\n                    return;\n                }\n                // Ignore insignificant movements to account for tremors.\n                if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {\n                    return;\n                }\n                clearTimeoutIfSet(restTimeoutRef);\n                if (pointerTypeRef.current === \"touch\") {\n                    handleMouseMove();\n                } else {\n                    restTimeoutPendingRef.current = true;\n                    restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current));\n                }\n            }\n        };\n    }, [\n        mouseOnly,\n        onOpenChange,\n        open,\n        openRef,\n        restMsRef\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference\n        } : {}, [\n        enabled,\n        reference\n    ]);\n}\nconst NOOP = ()=>{};\nconst FloatingDelayGroupContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: NOOP,\n    setState: NOOP,\n    isInstantPhase: false\n});\n/**\n * @deprecated\n * Use the return value of `useDelayGroup()` instead.\n */ const useDelayGroupContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ function FloatingDelayGroup(props) {\n    const { children, delay, timeoutMs = 0 } = props;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next)=>({\n            ...prev,\n            ...next\n        }), {\n        delay,\n        timeoutMs,\n        initialDelay: delay,\n        currentId: null,\n        isInstantPhase: false\n    });\n    const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((currentId)=>{\n        setState({\n            currentId\n        });\n    }, []);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (state.currentId) {\n            if (initialCurrentIdRef.current === null) {\n                initialCurrentIdRef.current = state.currentId;\n            } else if (!state.isInstantPhase) {\n                setState({\n                    isInstantPhase: true\n                });\n            }\n        } else {\n            if (state.isInstantPhase) {\n                setState({\n                    isInstantPhase: false\n                });\n            }\n            initialCurrentIdRef.current = null;\n        }\n    }, [\n        state.currentId,\n        state.isInstantPhase\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingDelayGroupContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                ...state,\n                setState,\n                setCurrentId\n            }), [\n            state,\n            setCurrentId\n        ]),\n        children: children\n    });\n}\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ function useDelayGroup(context, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { open, onOpenChange, floatingId } = context;\n    const { id: optionId, enabled = true } = options;\n    const id = optionId != null ? optionId : floatingId;\n    const groupContext = useDelayGroupContext();\n    const { currentId, setCurrentId, initialDelay, setState, timeoutMs } = groupContext;\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!enabled) return;\n        if (!currentId) return;\n        setState({\n            delay: {\n                open: 1,\n                close: getDelay(initialDelay, \"close\")\n            }\n        });\n        if (currentId !== id) {\n            onOpenChange(false);\n        }\n    }, [\n        enabled,\n        id,\n        onOpenChange,\n        setState,\n        currentId,\n        initialDelay\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        function unset() {\n            onOpenChange(false);\n            setState({\n                delay: initialDelay,\n                currentId: null\n            });\n        }\n        if (!enabled) return;\n        if (!currentId) return;\n        if (!open && currentId === id) {\n            if (timeoutMs) {\n                const timeout = window.setTimeout(unset, timeoutMs);\n                return ()=>{\n                    clearTimeout(timeout);\n                };\n            }\n            unset();\n        }\n    }, [\n        enabled,\n        open,\n        setState,\n        currentId,\n        id,\n        onOpenChange,\n        initialDelay,\n        timeoutMs\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!enabled) return;\n        if (setCurrentId === NOOP || !open) return;\n        setCurrentId(id);\n    }, [\n        enabled,\n        open,\n        setCurrentId,\n        id\n    ]);\n    return groupContext;\n}\nconst NextFloatingDelayGroupContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    hasProvider: false,\n    timeoutMs: 0,\n    delayRef: {\n        current: 0\n    },\n    initialDelayRef: {\n        current: 0\n    },\n    timeoutIdRef: {\n        current: -1\n    },\n    currentIdRef: {\n        current: null\n    },\n    currentContextRef: {\n        current: null\n    }\n});\n/**\n * Experimental next version of `FloatingDelayGroup` to become the default\n * in the future. This component is not yet stable.\n * Provides context for a group of floating elements that should share a\n * `delay`. Unlike `FloatingDelayGroup`, `useNextDelayGroup` with this\n * component does not cause a re-render of unrelated consumers of the\n * context when the delay changes.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ function NextFloatingDelayGroup(props) {\n    const { children, delay, timeoutMs = 0 } = props;\n    const delayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(delay);\n    const initialDelayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(delay);\n    const currentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const currentContextRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NextFloatingDelayGroupContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                hasProvider: true,\n                delayRef,\n                initialDelayRef,\n                currentIdRef,\n                timeoutMs,\n                currentContextRef,\n                timeoutIdRef\n            }), [\n            timeoutMs\n        ]),\n        children: children\n    });\n}\n/**\n * Enables grouping when called inside a component that's a child of a\n * `NextFloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ function useNextDelayGroup(context, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { open, onOpenChange, floatingId } = context;\n    const { enabled = true } = options;\n    const groupContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NextFloatingDelayGroupContext);\n    const { currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, hasProvider, timeoutIdRef } = groupContext;\n    const [isInstantPhase, setIsInstantPhase] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        function unset() {\n            var _currentContextRef$cu;\n            setIsInstantPhase(false);\n            (_currentContextRef$cu = currentContextRef.current) == null || _currentContextRef$cu.setIsInstantPhase(false);\n            currentIdRef.current = null;\n            currentContextRef.current = null;\n            delayRef.current = initialDelayRef.current;\n        }\n        if (!enabled) return;\n        if (!currentIdRef.current) return;\n        if (!open && currentIdRef.current === floatingId) {\n            setIsInstantPhase(false);\n            if (timeoutMs) {\n                timeoutIdRef.current = window.setTimeout(unset, timeoutMs);\n                return ()=>{\n                    clearTimeout(timeoutIdRef.current);\n                };\n            }\n            unset();\n        }\n    }, [\n        enabled,\n        open,\n        floatingId,\n        currentIdRef,\n        delayRef,\n        timeoutMs,\n        initialDelayRef,\n        currentContextRef,\n        timeoutIdRef\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!enabled) return;\n        if (!open) return;\n        const prevContext = currentContextRef.current;\n        const prevId = currentIdRef.current;\n        currentContextRef.current = {\n            onOpenChange,\n            setIsInstantPhase\n        };\n        currentIdRef.current = floatingId;\n        delayRef.current = {\n            open: 0,\n            close: getDelay(initialDelayRef.current, \"close\")\n        };\n        if (prevId !== null && prevId !== floatingId) {\n            clearTimeoutIfSet(timeoutIdRef);\n            setIsInstantPhase(true);\n            prevContext == null || prevContext.setIsInstantPhase(true);\n            prevContext == null || prevContext.onOpenChange(false);\n        } else {\n            setIsInstantPhase(false);\n            prevContext == null || prevContext.setIsInstantPhase(false);\n        }\n    }, [\n        enabled,\n        open,\n        floatingId,\n        onOpenChange,\n        currentIdRef,\n        delayRef,\n        timeoutMs,\n        initialDelayRef,\n        currentContextRef,\n        timeoutIdRef\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        return ()=>{\n            currentContextRef.current = null;\n        };\n    }, [\n        currentContextRef\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            hasProvider,\n            delayRef,\n            isInstantPhase\n        }), [\n        hasProvider,\n        delayRef,\n        isInstantPhase\n    ]);\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { preventScroll = false, cancelPrevious = true, sync = false } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = ()=>el == null ? void 0 : el.focus({\n            preventScroll\n        });\n    if (sync) {\n        exec();\n    } else {\n        rafId = requestAnimationFrame(exec);\n    }\n}\nfunction contains(parent, child) {\n    if (!parent || !child) {\n        return false;\n    }\n    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    }\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isShadowRoot)(rootNode)) {\n        let next = child;\n        while(next){\n            if (parent === next) {\n                return true;\n            }\n            // @ts-ignore\n            next = next.parentNode || next.host;\n        }\n    }\n    // Give up, the result is false\n    return false;\n}\nfunction getTarget(event) {\n    if (\"composedPath\" in event) {\n        return event.composedPath()[0];\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n}\nfunction getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n}\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nconst counters = {\n    inert: /*#__PURE__*/ new WeakMap(),\n    \"aria-hidden\": /*#__PURE__*/ new WeakMap(),\n    none: /*#__PURE__*/ new WeakMap()\n};\nfunction getCounterMap(control) {\n    if (control === \"inert\") return counters.inert;\n    if (control === \"aria-hidden\") return counters[\"aria-hidden\"];\n    return counters.none;\n}\nlet uncontrolledElementsSet = /*#__PURE__*/ new WeakSet();\nlet markerMap = {};\nlet lockCount$1 = 0;\nconst supportsInert = ()=>typeof HTMLElement !== \"undefined\" && \"inert\" in HTMLElement.prototype;\nconst unwrapHost = (node)=>node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets)=>targets.map((target)=>{\n        if (parent.contains(target)) {\n            return target;\n        }\n        const correctedTarget = unwrapHost(target);\n        if (parent.contains(correctedTarget)) {\n            return correctedTarget;\n        }\n        return null;\n    }).filter((x)=>x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n    const markerName = \"data-floating-ui-inert\";\n    const controlAttribute = inert ? \"inert\" : ariaHidden ? \"aria-hidden\" : null;\n    const avoidElements = correctElements(body, uncorrectedAvoidElements);\n    const elementsToKeep = new Set();\n    const elementsToStop = new Set(avoidElements);\n    const hiddenElements = [];\n    if (!markerMap[markerName]) {\n        markerMap[markerName] = new WeakMap();\n    }\n    const markerCounter = markerMap[markerName];\n    avoidElements.forEach(keep);\n    deep(body);\n    elementsToKeep.clear();\n    function keep(el) {\n        if (!el || elementsToKeep.has(el)) {\n            return;\n        }\n        elementsToKeep.add(el);\n        el.parentNode && keep(el.parentNode);\n    }\n    function deep(parent) {\n        if (!parent || elementsToStop.has(parent)) {\n            return;\n        }\n        [].forEach.call(parent.children, (node)=>{\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getNodeName)(node) === \"script\") return;\n            if (elementsToKeep.has(node)) {\n                deep(node);\n            } else {\n                const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n                const alreadyHidden = attr !== null && attr !== \"false\";\n                const counterMap = getCounterMap(controlAttribute);\n                const counterValue = (counterMap.get(node) || 0) + 1;\n                const markerValue = (markerCounter.get(node) || 0) + 1;\n                counterMap.set(node, counterValue);\n                markerCounter.set(node, markerValue);\n                hiddenElements.push(node);\n                if (counterValue === 1 && alreadyHidden) {\n                    uncontrolledElementsSet.add(node);\n                }\n                if (markerValue === 1) {\n                    node.setAttribute(markerName, \"\");\n                }\n                if (!alreadyHidden && controlAttribute) {\n                    node.setAttribute(controlAttribute, controlAttribute === \"inert\" ? \"\" : \"true\");\n                }\n            }\n        });\n    }\n    lockCount$1++;\n    return ()=>{\n        hiddenElements.forEach((element)=>{\n            const counterMap = getCounterMap(controlAttribute);\n            const currentCounterValue = counterMap.get(element) || 0;\n            const counterValue = currentCounterValue - 1;\n            const markerValue = (markerCounter.get(element) || 0) - 1;\n            counterMap.set(element, counterValue);\n            markerCounter.set(element, markerValue);\n            if (!counterValue) {\n                if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n                    element.removeAttribute(controlAttribute);\n                }\n                uncontrolledElementsSet.delete(element);\n            }\n            if (!markerValue) {\n                element.removeAttribute(markerName);\n            }\n        });\n        lockCount$1--;\n        if (!lockCount$1) {\n            counters.inert = new WeakMap();\n            counters[\"aria-hidden\"] = new WeakMap();\n            counters.none = new WeakMap();\n            uncontrolledElementsSet = new WeakSet();\n            markerMap = {};\n        }\n    };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n    if (ariaHidden === void 0) {\n        ariaHidden = false;\n    }\n    if (inert === void 0) {\n        inert = false;\n    }\n    const body = getDocument(avoidElements[0]).body;\n    return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live],[role=\"status\"],output'))), body, ariaHidden, inert);\n}\nconst HIDDEN_STYLES = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"fixed\",\n    whiteSpace: \"nowrap\",\n    width: \"1px\",\n    top: 0,\n    left: 0\n};\nconst FocusGuard = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n    const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)()) {\n            // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n            // on VoiceOver does trigger the onFocus event, so we can use the focus\n            // trap element. On Safari, only buttons trigger the onFocus event.\n            // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n            // button role.\n            setRole(\"button\");\n        }\n    }, []);\n    const restProps = {\n        ref,\n        tabIndex: 0,\n        // Role is only for VoiceOver\n        role,\n        \"aria-hidden\": role ? undefined : true,\n        [createAttribute(\"focus-guard\")]: \"\",\n        style: HIDDEN_STYLES\n    };\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n        ...props,\n        ...restProps\n    });\n});\nconst PortalContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst attr = /*#__PURE__*/ createAttribute(\"portal\");\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */ function useFloatingPortalNode(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { id, root } = props;\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const portalNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        return ()=>{\n            portalNode == null || portalNode.remove();\n            // Allow the subsequent layout effects to create a new node on updates.\n            // The portal node will still be cleaned up on unmount.\n            // https://github.com/floating-ui/floating-ui/issues/2454\n            queueMicrotask(()=>{\n                portalNodeRef.current = null;\n            });\n        };\n    }, [\n        portalNode\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        // Wait for the uniqueId to be generated before creating the portal node in\n        // React <18 (using `useFloatingId` instead of the native `useId`).\n        // https://github.com/floating-ui/floating-ui/issues/2778\n        if (!uniqueId) return;\n        if (portalNodeRef.current) return;\n        const existingIdRoot = id ? document.getElementById(id) : null;\n        if (!existingIdRoot) return;\n        const subRoot = document.createElement(\"div\");\n        subRoot.id = uniqueId;\n        subRoot.setAttribute(attr, \"\");\n        existingIdRoot.appendChild(subRoot);\n        portalNodeRef.current = subRoot;\n        setPortalNode(subRoot);\n    }, [\n        id,\n        uniqueId\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        // Wait for the root to exist before creating the portal node. The root must\n        // be stored in state, not a ref, for this to work reactively.\n        if (root === null) return;\n        if (!uniqueId) return;\n        if (portalNodeRef.current) return;\n        let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n        if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(container)) container = container.current;\n        container = container || document.body;\n        let idWrapper = null;\n        if (id) {\n            idWrapper = document.createElement(\"div\");\n            idWrapper.id = id;\n            container.appendChild(idWrapper);\n        }\n        const subRoot = document.createElement(\"div\");\n        subRoot.id = uniqueId;\n        subRoot.setAttribute(attr, \"\");\n        container = idWrapper || container;\n        container.appendChild(subRoot);\n        portalNodeRef.current = subRoot;\n        setPortalNode(subRoot);\n    }, [\n        id,\n        root,\n        uniqueId,\n        portalContext\n    ]);\n    return portalNode;\n}\n/**\n * Portals the floating element into a given container element â€” by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */ function FloatingPortal(props) {\n    const { children, id, root, preserveTabOrder = true } = props;\n    const portalNode = useFloatingPortalNode({\n        id,\n        root\n    });\n    const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const modal = focusManagerState == null ? void 0 : focusManagerState.modal;\n    const open = focusManagerState == null ? void 0 : focusManagerState.open;\n    const shouldRenderGuards = // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState && // Guards are only for non-modal focus management.\n    !focusManagerState.modal && // Don't render if unmount is transitioning.\n    focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!portalNode || !preserveTabOrder || modal) {\n            return;\n        }\n        // Make sure elements inside the portal element are tabbable only when the\n        // portal has already been focused, either by tabbing into a focus trap\n        // element outside or using the mouse.\n        function onFocus(event) {\n            if (portalNode && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event)) {\n                const focusing = event.type === \"focusin\";\n                const manageFocus = focusing ? _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.enableFocusInside : _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.disableFocusInside;\n                manageFocus(portalNode);\n            }\n        }\n        // Listen to the event on the capture phase so they run before the focus\n        // trap elements onFocus prop is called.\n        portalNode.addEventListener(\"focusin\", onFocus, true);\n        portalNode.addEventListener(\"focusout\", onFocus, true);\n        return ()=>{\n            portalNode.removeEventListener(\"focusin\", onFocus, true);\n            portalNode.removeEventListener(\"focusout\", onFocus, true);\n        };\n    }, [\n        portalNode,\n        preserveTabOrder,\n        modal\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!portalNode) return;\n        if (open) return;\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.enableFocusInside)(portalNode);\n    }, [\n        open,\n        portalNode\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(PortalContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                preserveTabOrder,\n                beforeOutsideRef,\n                afterOutsideRef,\n                beforeInsideRef,\n                afterInsideRef,\n                portalNode,\n                setFocusManagerState\n            }), [\n            preserveTabOrder,\n            portalNode\n        ]),\n        children: [\n            shouldRenderGuards && portalNode && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FocusGuard, {\n                \"data-type\": \"outside\",\n                ref: beforeOutsideRef,\n                onFocus: (event)=>{\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event, portalNode)) {\n                        var _beforeInsideRef$curr;\n                        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n                    } else {\n                        const domReference = focusManagerState ? focusManagerState.domReference : null;\n                        const prevTabbable = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPreviousTabbable)(domReference);\n                        prevTabbable == null || prevTabbable.focus();\n                    }\n                }\n            }),\n            shouldRenderGuards && portalNode && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n                \"aria-owns\": portalNode.id,\n                style: HIDDEN_STYLES\n            }),\n            portalNode && /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(children, portalNode),\n            shouldRenderGuards && portalNode && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FocusGuard, {\n                \"data-type\": \"outside\",\n                ref: afterOutsideRef,\n                onFocus: (event)=>{\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event, portalNode)) {\n                        var _afterInsideRef$curre;\n                        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n                    } else {\n                        const domReference = focusManagerState ? focusManagerState.domReference : null;\n                        const nextTabbable = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNextTabbable)(domReference);\n                        nextTabbable == null || nextTabbable.focus();\n                        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, \"focus-out\"));\n                    }\n                }\n            })\n        ]\n    });\n}\nconst usePortalContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\nfunction useLiteMergeRefs(refs) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return (value)=>{\n            refs.forEach((ref)=>{\n                if (ref) {\n                    ref.current = value;\n                }\n            });\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n}\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n    previouslyFocusedElements = previouslyFocusedElements.filter((el)=>el.isConnected);\n    if (element && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getNodeName)(element) !== \"body\") {\n        previouslyFocusedElements.push(element);\n        if (previouslyFocusedElements.length > LIST_LIMIT) {\n            previouslyFocusedElements = previouslyFocusedElements.slice(-20);\n        }\n    }\n}\nfunction getPreviouslyFocusedElement() {\n    return previouslyFocusedElements.slice().reverse().find((el)=>el.isConnected);\n}\nfunction getFirstTabbableElement(container) {\n    const tabbableOptions = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTabbableOptions)();\n    if ((0,tabbable__WEBPACK_IMPORTED_MODULE_7__.isTabbable)(container, tabbableOptions)) {\n        return container;\n    }\n    return (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, tabbableOptions)[0] || container;\n}\nfunction handleTabIndex(floatingFocusElement, orderRef) {\n    var _floatingFocusElement;\n    if (!orderRef.current.includes(\"floating\") && !((_floatingFocusElement = floatingFocusElement.getAttribute(\"role\")) != null && _floatingFocusElement.includes(\"dialog\"))) {\n        return;\n    }\n    const options = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTabbableOptions)();\n    const focusableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.focusable)(floatingFocusElement, options);\n    const tabbableContent = focusableElements.filter((element)=>{\n        const dataTabIndex = element.getAttribute(\"data-tabindex\") || \"\";\n        return (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.isTabbable)(element, options) || element.hasAttribute(\"data-tabindex\") && !dataTabIndex.startsWith(\"-\");\n    });\n    const tabIndex = floatingFocusElement.getAttribute(\"tabindex\");\n    if (orderRef.current.includes(\"floating\") || tabbableContent.length === 0) {\n        if (tabIndex !== \"0\") {\n            floatingFocusElement.setAttribute(\"tabindex\", \"0\");\n        }\n    } else if (tabIndex !== \"-1\" || floatingFocusElement.hasAttribute(\"data-tabindex\") && floatingFocusElement.getAttribute(\"data-tabindex\") !== \"-1\") {\n        floatingFocusElement.setAttribute(\"tabindex\", \"-1\");\n        floatingFocusElement.setAttribute(\"data-tabindex\", \"-1\");\n    }\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        ...props,\n        type: \"button\",\n        ref: ref,\n        tabIndex: -1,\n        style: HIDDEN_STYLES\n    });\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */ function FloatingFocusManager(props) {\n    const { context, children, disabled = false, order = [\n        \"content\"\n    ], guards: _guards = true, initialFocus = 0, returnFocus = true, restoreFocus = false, modal = true, visuallyHiddenDismiss = false, closeOnFocusOut = true, outsideElementsInert = false, getInsideElements: _getInsideElements = ()=>[] } = props;\n    const { open, onOpenChange, events, dataRef, elements: { domReference, floating } } = context;\n    const getNodeId = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(()=>{\n        var _dataRef$current$floa;\n        return (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;\n    });\n    const getInsideElements = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(_getInsideElements);\n    const ignoreInitialFocus = typeof initialFocus === \"number\" && initialFocus < 0;\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n    // Force the guards to be rendered if the `inert` attribute is not supported.\n    const inertSupported = supportsInert();\n    const guards = inertSupported ? _guards : true;\n    const useInert = !guards || inertSupported && outsideElementsInert;\n    const orderRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(order);\n    const initialFocusRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(initialFocus);\n    const returnFocusRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(returnFocus);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n    const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const tabbableIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const isInsidePortal = portalContext != null;\n    const floatingFocusElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getFloatingFocusElement)(floating);\n    const getTabbableContent = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(function(container) {\n        if (container === void 0) {\n            container = floatingFocusElement;\n        }\n        return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTabbableOptions)()) : [];\n    });\n    const getTabbableElements = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((container)=>{\n        const content = getTabbableContent(container);\n        return orderRef.current.map((type)=>{\n            if (domReference && type === \"reference\") {\n                return domReference;\n            }\n            if (floatingFocusElement && type === \"floating\") {\n                return floatingFocusElement;\n            }\n            return content;\n        }).filter(Boolean).flat();\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled) return;\n        if (!modal) return;\n        function onKeyDown(event) {\n            if (event.key === \"Tab\") {\n                // The focus guards have nothing to focus, so we need to stop the event.\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floatingFocusElement, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                }\n                const els = getTabbableElements();\n                const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n                if (orderRef.current[0] === \"reference\" && target === domReference) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    if (event.shiftKey) {\n                        enqueueFocus(els[els.length - 1]);\n                    } else {\n                        enqueueFocus(els[1]);\n                    }\n                }\n                if (orderRef.current[1] === \"floating\" && target === floatingFocusElement && event.shiftKey) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    enqueueFocus(els[0]);\n                }\n            }\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement);\n        doc.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            doc.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        disabled,\n        domReference,\n        floatingFocusElement,\n        modal,\n        orderRef,\n        isUntrappedTypeableCombobox,\n        getTabbableContent,\n        getTabbableElements\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled) return;\n        if (!floating) return;\n        function handleFocusIn(event) {\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            const tabbableContent = getTabbableContent();\n            const tabbableIndex = tabbableContent.indexOf(target);\n            if (tabbableIndex !== -1) {\n                tabbableIndexRef.current = tabbableIndex;\n            }\n        }\n        floating.addEventListener(\"focusin\", handleFocusIn);\n        return ()=>{\n            floating.removeEventListener(\"focusin\", handleFocusIn);\n        };\n    }, [\n        disabled,\n        floating,\n        getTabbableContent\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled) return;\n        if (!closeOnFocusOut) return;\n        // In Safari, buttons lose focus when pressing them.\n        function handlePointerDown() {\n            isPointerDownRef.current = true;\n            setTimeout(()=>{\n                isPointerDownRef.current = false;\n            });\n        }\n        function handleFocusOutside(event) {\n            const relatedTarget = event.relatedTarget;\n            const currentTarget = event.currentTarget;\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            queueMicrotask(()=>{\n                const nodeId = getNodeId();\n                const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) || tree && ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context, _node$context2;\n                    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n                }) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeAncestors)(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context3, _node$context4, _node$context5;\n                    return [\n                        (_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating,\n                        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getFloatingFocusElement)((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.floating)\n                    ].includes(relatedTarget) || ((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.domReference) === relatedTarget;\n                })));\n                if (currentTarget === domReference && floatingFocusElement) {\n                    handleTabIndex(floatingFocusElement, orderRef);\n                }\n                // Restore focus to the previous tabbable element index to prevent\n                // focus from being lost outside the floating tree.\n                if (restoreFocus && currentTarget !== domReference && !(target != null && target.isConnected) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement)) === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement).body) {\n                    // Let `FloatingPortal` effect knows that focus is still inside the\n                    // floating tree.\n                    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(floatingFocusElement)) {\n                        floatingFocusElement.focus();\n                    }\n                    const prevTabbableIndex = tabbableIndexRef.current;\n                    const tabbableContent = getTabbableContent();\n                    const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;\n                    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(nodeToFocus)) {\n                        nodeToFocus.focus();\n                    }\n                }\n                // https://github.com/floating-ui/floating-ui/issues/3060\n                if (dataRef.current.insideReactTree) {\n                    dataRef.current.insideReactTree = false;\n                    return;\n                }\n                // Focus did not move inside the floating tree, and there are no tabbable\n                // portal guards to handle closing.\n                if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.\n                relatedTarget !== getPreviouslyFocusedElement()) {\n                    preventReturnFocusRef.current = true;\n                    onOpenChange(false, event, \"focus-out\");\n                }\n            });\n        }\n        if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(domReference)) {\n            domReference.addEventListener(\"focusout\", handleFocusOutside);\n            domReference.addEventListener(\"pointerdown\", handlePointerDown);\n            floating.addEventListener(\"focusout\", handleFocusOutside);\n            return ()=>{\n                domReference.removeEventListener(\"focusout\", handleFocusOutside);\n                domReference.removeEventListener(\"pointerdown\", handlePointerDown);\n                floating.removeEventListener(\"focusout\", handleFocusOutside);\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        floatingFocusElement,\n        modal,\n        tree,\n        portalContext,\n        onOpenChange,\n        closeOnFocusOut,\n        restoreFocus,\n        getTabbableContent,\n        isUntrappedTypeableCombobox,\n        getNodeId,\n        orderRef,\n        dataRef\n    ]);\n    const beforeGuardRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterGuardRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const mergedBeforeGuardRef = useLiteMergeRefs([\n        beforeGuardRef,\n        portalContext == null ? void 0 : portalContext.beforeInsideRef\n    ]);\n    const mergedAfterGuardRef = useLiteMergeRefs([\n        afterGuardRef,\n        portalContext == null ? void 0 : portalContext.afterInsideRef\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _portalContext$portal, _ancestors$find;\n        if (disabled) return;\n        if (!floating) return;\n        // Don't hide portals nested within the parent portal.\n        const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute(\"portal\") + \"]\")) || []);\n        const ancestors = tree ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeAncestors)(tree.nodesRef.current, getNodeId()) : [];\n        const ancestorFloatingNodes = tree && !modal ? ancestors.map((node)=>{\n            var _node$context6;\n            return (_node$context6 = node.context) == null ? void 0 : _node$context6.elements.floating;\n        }) : [];\n        const rootAncestorComboboxDomReference = (_ancestors$find = ancestors.find((node)=>{\n            var _node$context7;\n            return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(((_node$context7 = node.context) == null ? void 0 : _node$context7.elements.domReference) || null);\n        })) == null || (_ancestors$find = _ancestors$find.context) == null ? void 0 : _ancestors$find.elements.domReference;\n        const insideElements = [\n            floating,\n            rootAncestorComboboxDomReference,\n            ...portalNodes,\n            ...ancestorFloatingNodes,\n            ...getInsideElements(),\n            startDismissButtonRef.current,\n            endDismissButtonRef.current,\n            beforeGuardRef.current,\n            afterGuardRef.current,\n            portalContext == null ? void 0 : portalContext.beforeOutsideRef.current,\n            portalContext == null ? void 0 : portalContext.afterOutsideRef.current,\n            orderRef.current.includes(\"reference\") || isUntrappedTypeableCombobox ? domReference : null\n        ].filter((x)=>x != null);\n        const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, !useInert, useInert) : markOthers(insideElements);\n        return ()=>{\n            cleanup();\n        };\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        portalContext,\n        isUntrappedTypeableCombobox,\n        guards,\n        useInert,\n        tree,\n        getNodeId,\n        getInsideElements\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (disabled || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(floatingFocusElement)) return;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n        // Wait for any layout effect state setters to execute to set `tabIndex`.\n        queueMicrotask(()=>{\n            const focusableElements = getTabbableElements(floatingFocusElement);\n            const initialFocusValue = initialFocusRef.current;\n            const elToFocus = (typeof initialFocusValue === \"number\" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;\n            const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floatingFocusElement, previouslyFocusedElement);\n            if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n                enqueueFocus(elToFocus, {\n                    preventScroll: elToFocus === floatingFocusElement\n                });\n            }\n        });\n    }, [\n        disabled,\n        open,\n        floatingFocusElement,\n        ignoreInitialFocus,\n        getTabbableElements,\n        initialFocusRef\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (disabled || !floatingFocusElement) return;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n        addPreviouslyFocusedElement(previouslyFocusedElement);\n        // Dismissing via outside press should always ignore `returnFocus` to\n        // prevent unwanted scrolling.\n        function onOpenChange(_ref) {\n            let { reason, event, nested } = _ref;\n            if ([\n                \"hover\",\n                \"safe-polygon\"\n            ].includes(reason) && event.type === \"mouseleave\") {\n                preventReturnFocusRef.current = true;\n            }\n            if (reason !== \"outside-press\") return;\n            if (nested) {\n                preventReturnFocusRef.current = false;\n            } else if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event)) {\n                preventReturnFocusRef.current = false;\n            } else {\n                let isPreventScrollSupported = false;\n                document.createElement(\"div\").focus({\n                    get preventScroll () {\n                        isPreventScrollSupported = true;\n                        return false;\n                    }\n                });\n                if (isPreventScrollSupported) {\n                    preventReturnFocusRef.current = false;\n                } else {\n                    preventReturnFocusRef.current = true;\n                }\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        const fallbackEl = doc.createElement(\"span\");\n        fallbackEl.setAttribute(\"tabindex\", \"-1\");\n        fallbackEl.setAttribute(\"aria-hidden\", \"true\");\n        Object.assign(fallbackEl.style, HIDDEN_STYLES);\n        if (isInsidePortal && domReference) {\n            domReference.insertAdjacentElement(\"afterend\", fallbackEl);\n        }\n        function getReturnElement() {\n            if (typeof returnFocusRef.current === \"boolean\") {\n                const el = domReference || getPreviouslyFocusedElement();\n                return el && el.isConnected ? el : fallbackEl;\n            }\n            return returnFocusRef.current.current || fallbackEl;\n        }\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n            const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, activeEl) || tree && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, getNodeId(), false).some((node)=>{\n                var _node$context8;\n                return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context8 = node.context) == null ? void 0 : _node$context8.elements.floating, activeEl);\n            });\n            const returnElement = getReturnElement();\n            queueMicrotask(()=>{\n                // This is `returnElement`, if it's tabbable, or its first tabbable child.\n                const tabbableReturnElement = getFirstTabbableElement(returnElement);\n                if (// eslint-disable-next-line react-hooks/exhaustive-deps\n                returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(tabbableReturnElement) && // If the focus moved somewhere else after mount, avoid returning focus\n                // since it likely entered a different element which should be\n                // respected: https://github.com/floating-ui/floating-ui/issues/2607\n                (tabbableReturnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n                    tabbableReturnElement.focus({\n                        preventScroll: true\n                    });\n                }\n                fallbackEl.remove();\n            });\n        };\n    }, [\n        disabled,\n        floating,\n        floatingFocusElement,\n        returnFocusRef,\n        dataRef,\n        events,\n        tree,\n        isInsidePortal,\n        domReference,\n        getNodeId\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // The `returnFocus` cleanup behavior is inside a microtask; ensure we\n        // wait for it to complete before resetting the flag.\n        queueMicrotask(()=>{\n            preventReturnFocusRef.current = false;\n        });\n    }, [\n        disabled\n    ]);\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (disabled) return;\n        if (!portalContext) return;\n        portalContext.setFocusManagerState({\n            modal,\n            closeOnFocusOut,\n            open,\n            onOpenChange,\n            domReference\n        });\n        return ()=>{\n            portalContext.setFocusManagerState(null);\n        };\n    }, [\n        disabled,\n        portalContext,\n        modal,\n        open,\n        onOpenChange,\n        closeOnFocusOut,\n        domReference\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (disabled) return;\n        if (!floatingFocusElement) return;\n        handleTabIndex(floatingFocusElement, orderRef);\n    }, [\n        disabled,\n        floatingFocusElement,\n        orderRef\n    ]);\n    function renderDismissButton(location) {\n        if (disabled || !visuallyHiddenDismiss || !modal) {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VisuallyHiddenDismiss, {\n            ref: location === \"start\" ? startDismissButtonRef : endDismissButtonRef,\n            onClick: (event)=>onOpenChange(false, event.nativeEvent),\n            children: typeof visuallyHiddenDismiss === \"string\" ? visuallyHiddenDismiss : \"Dismiss\"\n        });\n    }\n    const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n        children: [\n            shouldRenderGuards && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FocusGuard, {\n                \"data-type\": \"inside\",\n                ref: mergedBeforeGuardRef,\n                onFocus: (event)=>{\n                    if (modal) {\n                        const els = getTabbableElements();\n                        enqueueFocus(order[0] === \"reference\" ? els[0] : els[els.length - 1]);\n                    } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                        preventReturnFocusRef.current = false;\n                        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event, portalContext.portalNode)) {\n                            const nextTabbable = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNextTabbable)(domReference);\n                            nextTabbable == null || nextTabbable.focus();\n                        } else {\n                            var _portalContext$before;\n                            (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n                        }\n                    }\n                }\n            }),\n            !isUntrappedTypeableCombobox && renderDismissButton(\"start\"),\n            children,\n            renderDismissButton(\"end\"),\n            shouldRenderGuards && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FocusGuard, {\n                \"data-type\": \"inside\",\n                ref: mergedAfterGuardRef,\n                onFocus: (event)=>{\n                    if (modal) {\n                        enqueueFocus(getTabbableElements()[0]);\n                    } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                        if (closeOnFocusOut) {\n                            preventReturnFocusRef.current = true;\n                        }\n                        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event, portalContext.portalNode)) {\n                            const prevTabbable = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPreviousTabbable)(domReference);\n                            prevTabbable == null || prevTabbable.focus();\n                        } else {\n                            var _portalContext$afterO;\n                            (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n                        }\n                    }\n                }\n            })\n        ]\n    });\n}\nlet lockCount = 0;\nconst scrollbarProperty = \"--floating-ui-scrollbar-width\";\nfunction enableScrollLock() {\n    const platform = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPlatform)();\n    const isIOS = /iP(hone|ad|od)|iOS/.test(platform) || // iPads can claim to be MacIntel\n    platform === \"MacIntel\" && navigator.maxTouchPoints > 1;\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;\n    bodyStyle.overflow = \"hidden\";\n    bodyStyle.setProperty(scrollbarProperty, scrollbarWidth + \"px\");\n    if (scrollbarWidth) {\n        bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n        var _window$visualViewpor, _window$visualViewpor2;\n        // iOS 12 does not support `visualViewport`.\n        const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n        const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n        Object.assign(bodyStyle, {\n            position: \"fixed\",\n            top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n            left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n            right: \"0\"\n        });\n    }\n    return ()=>{\n        Object.assign(bodyStyle, {\n            overflow: \"\",\n            [paddingProp]: \"\"\n        });\n        bodyStyle.removeProperty(scrollbarProperty);\n        if (isIOS) {\n            Object.assign(bodyStyle, {\n                position: \"\",\n                top: \"\",\n                left: \"\",\n                right: \"\"\n            });\n            window.scrollTo(scrollX, scrollY);\n        }\n    };\n}\nlet cleanup = ()=>{};\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */ const FloatingOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(props, ref) {\n    const { lockScroll = false, ...rest } = props;\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!lockScroll) return;\n        lockCount++;\n        if (lockCount === 1) {\n            cleanup = enableScrollLock();\n        }\n        return ()=>{\n            lockCount--;\n            if (lockCount === 0) {\n                cleanup();\n            }\n        };\n    }, [\n        lockScroll\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: ref,\n        ...rest,\n        style: {\n            position: \"fixed\",\n            overflow: \"auto\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            ...rest.style\n        }\n    });\n});\nfunction isButtonTarget(event) {\n    return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(event.target) && event.target.tagName === \"BUTTON\";\n}\nfunction isAnchorTarget(event) {\n    return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(event.target) && event.target.tagName === \"A\";\n}\nfunction isSpaceIgnored(element) {\n    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */ function useClick(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, elements: { domReference } } = context;\n    const { enabled = true, event: eventOption = \"click\", toggle = true, ignoreMouse = false, keyboardHandlers = true, stickIfOpen = true } = props;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onPointerDown (event) {\n                pointerTypeRef.current = event.pointerType;\n            },\n            onMouseDown (event) {\n                const pointerType = pointerTypeRef.current;\n                // Ignore all buttons except for the \"main\" button.\n                // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n                if (event.button !== 0) return;\n                if (eventOption === \"click\") return;\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType, true) && ignoreMouse) return;\n                if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === \"mousedown\" : true)) {\n                    onOpenChange(false, event.nativeEvent, \"click\");\n                } else {\n                    // Prevent stealing focus from the floating element\n                    event.preventDefault();\n                    onOpenChange(true, event.nativeEvent, \"click\");\n                }\n            },\n            onClick (event) {\n                const pointerType = pointerTypeRef.current;\n                if (eventOption === \"mousedown\" && pointerTypeRef.current) {\n                    pointerTypeRef.current = undefined;\n                    return;\n                }\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType, true) && ignoreMouse) return;\n                if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === \"click\" : true)) {\n                    onOpenChange(false, event.nativeEvent, \"click\");\n                } else {\n                    onOpenChange(true, event.nativeEvent, \"click\");\n                }\n            },\n            onKeyDown (event) {\n                pointerTypeRef.current = undefined;\n                if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n                    return;\n                }\n                if (event.key === \" \" && !isSpaceIgnored(domReference)) {\n                    // Prevent scrolling\n                    event.preventDefault();\n                    didKeyDownRef.current = true;\n                }\n                if (isAnchorTarget(event)) {\n                    return;\n                }\n                if (event.key === \"Enter\") {\n                    if (open && toggle) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                }\n            },\n            onKeyUp (event) {\n                if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n                    return;\n                }\n                if (event.key === \" \" && didKeyDownRef.current) {\n                    didKeyDownRef.current = false;\n                    if (open && toggle) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                }\n            }\n        }), [\n        dataRef,\n        domReference,\n        eventOption,\n        ignoreMouse,\n        keyboardHandlers,\n        onOpenChange,\n        open,\n        stickIfOpen,\n        toggle\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference\n        } : {}, [\n        enabled,\n        reference\n    ]);\n}\nfunction createVirtualElement(domElement, data) {\n    let offsetX = null;\n    let offsetY = null;\n    let isAutoUpdateEvent = false;\n    return {\n        contextElement: domElement || undefined,\n        getBoundingClientRect () {\n            var _data$dataRef$current;\n            const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {\n                width: 0,\n                height: 0,\n                x: 0,\n                y: 0\n            };\n            const isXAxis = data.axis === \"x\" || data.axis === \"both\";\n            const isYAxis = data.axis === \"y\" || data.axis === \"both\";\n            const canTrackCursorOnAutoUpdate = [\n                \"mouseenter\",\n                \"mousemove\"\n            ].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || \"\") && data.pointerType !== \"touch\";\n            let width = domRect.width;\n            let height = domRect.height;\n            let x = domRect.x;\n            let y = domRect.y;\n            if (offsetX == null && data.x && isXAxis) {\n                offsetX = domRect.x - data.x;\n            }\n            if (offsetY == null && data.y && isYAxis) {\n                offsetY = domRect.y - data.y;\n            }\n            x -= offsetX || 0;\n            y -= offsetY || 0;\n            width = 0;\n            height = 0;\n            if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n                width = data.axis === \"y\" ? domRect.width : 0;\n                height = data.axis === \"x\" ? domRect.height : 0;\n                x = isXAxis && data.x != null ? data.x : x;\n                y = isYAxis && data.y != null ? data.y : y;\n            } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n                height = data.axis === \"x\" ? domRect.height : height;\n                width = data.axis === \"y\" ? domRect.width : width;\n            }\n            isAutoUpdateEvent = true;\n            return {\n                width,\n                height,\n                x,\n                y,\n                top: y,\n                right: x + width,\n                bottom: y + height,\n                left: x\n            };\n        }\n    };\n}\nfunction isMouseBasedEvent(event) {\n    return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */ function useClientPoint(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, dataRef, elements: { floating, domReference }, refs } = context;\n    const { enabled = true, axis = \"both\", x = null, y = null } = props;\n    const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n    const setReference = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((x, y)=>{\n        if (initialRef.current) return;\n        // Prevent setting if the open event was not a mouse-like one\n        // (e.g. focus to open, then hover over the reference element).\n        // Only apply if the event exists.\n        if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n            return;\n        }\n        refs.setPositionReference(createVirtualElement(domReference, {\n            x,\n            y,\n            axis,\n            dataRef,\n            pointerType\n        }));\n    });\n    const handleReferenceEnterOrMove = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((event)=>{\n        if (x != null || y != null) return;\n        if (!open) {\n            setReference(event.clientX, event.clientY);\n        } else if (!cleanupListenerRef.current) {\n            // If there's no cleanup, there's no listener, but we want to ensure\n            // we add the listener if the cursor landed on the floating element and\n            // then back on the reference (i.e. it's interactive).\n            setReactive([]);\n        }\n    });\n    // If the pointer is a mouse-like pointer, we want to continue following the\n    // mouse even if the floating element is transitioning out. On touch\n    // devices, this is undesirable because the floating element will move to\n    // the dismissal touch point.\n    const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType) ? floating : open;\n    const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n        if (!openCheck || !enabled || x != null || y != null) return;\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getWindow)(floating);\n        function handleMouseMove(event) {\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, target)) {\n                setReference(event.clientX, event.clientY);\n            } else {\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            }\n        }\n        if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n            win.addEventListener(\"mousemove\", handleMouseMove);\n            const cleanup = ()=>{\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            };\n            cleanupListenerRef.current = cleanup;\n            return cleanup;\n        }\n        refs.setPositionReference(domReference);\n    }, [\n        openCheck,\n        enabled,\n        x,\n        y,\n        floating,\n        dataRef,\n        refs,\n        domReference,\n        setReference\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return addListener();\n    }, [\n        addListener,\n        reactive\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (enabled && !floating) {\n            initialRef.current = false;\n        }\n    }, [\n        enabled,\n        floating\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled && open) {\n            initialRef.current = true;\n        }\n    }, [\n        enabled,\n        open\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (enabled && (x != null || y != null)) {\n            initialRef.current = false;\n            setReference(x, y);\n        }\n    }, [\n        enabled,\n        x,\n        y,\n        setReference\n    ]);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function setPointerTypeRef(_ref) {\n            let { pointerType } = _ref;\n            setPointerType(pointerType);\n        }\n        return {\n            onPointerDown: setPointerTypeRef,\n            onPointerEnter: setPointerTypeRef,\n            onMouseMove: handleReferenceEnterOrMove,\n            onMouseEnter: handleReferenceEnterOrMove\n        };\n    }, [\n        handleReferenceEnterOrMove\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference\n        } : {}, [\n        enabled,\n        reference\n    ]);\n}\nconst bubbleHandlerKeys = {\n    pointerdown: \"onPointerDown\",\n    mousedown: \"onMouseDown\",\n    click: \"onClick\"\n};\nconst captureHandlerKeys = {\n    pointerdown: \"onPointerDownCapture\",\n    mousedown: \"onMouseDownCapture\",\n    click: \"onClickCapture\"\n};\nconst normalizeProp = (normalizable)=>{\n    var _normalizable$escapeK, _normalizable$outside;\n    return {\n        escapeKey: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n        outsidePress: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n    };\n};\n/**\n * Closes the floating element when a dismissal is requested â€” by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */ function useDismiss(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, elements, dataRef } = context;\n    const { enabled = true, escapeKey = true, outsidePress: unstable_outsidePress = true, outsidePressEvent = \"pointerdown\", referencePress = false, referencePressEvent = \"pointerdown\", ancestorScroll = false, bubbles, capture } = props;\n    const tree = useFloatingTree();\n    const outsidePressFn = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(typeof unstable_outsidePress === \"function\" ? unstable_outsidePress : ()=>false);\n    const outsidePress = typeof unstable_outsidePress === \"function\" ? outsidePressFn : unstable_outsidePress;\n    const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const { escapeKey: escapeKeyBubbles, outsidePress: outsidePressBubbles } = normalizeProp(bubbles);\n    const { escapeKey: escapeKeyCapture, outsidePress: outsidePressCapture } = normalizeProp(capture);\n    const isComposingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const blurTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const closeOnEscapeKeyDown = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((event)=>{\n        var _dataRef$current$floa;\n        if (!open || !enabled || !escapeKey || event.key !== \"Escape\") {\n            return;\n        }\n        // Wait until IME is settled. Pressing `Escape` while composing should\n        // close the compose menu, but not the floating element.\n        if (isComposingRef.current) {\n            return;\n        }\n        const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;\n        const children = tree ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, nodeId) : [];\n        if (!escapeKeyBubbles) {\n            event.stopPropagation();\n            if (children.length > 0) {\n                let shouldDismiss = true;\n                children.forEach((child)=>{\n                    var _child$context;\n                    if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n                        shouldDismiss = false;\n                        return;\n                    }\n                });\n                if (!shouldDismiss) {\n                    return;\n                }\n            }\n        }\n        onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isReactEvent)(event) ? event.nativeEvent : event, \"escape-key\");\n    });\n    const closeOnEscapeKeyDownCapture = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((event)=>{\n        var _getTarget2;\n        const callback = ()=>{\n            var _getTarget;\n            closeOnEscapeKeyDown(event);\n            (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget.removeEventListener(\"keydown\", callback);\n        };\n        (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget2.addEventListener(\"keydown\", callback);\n    });\n    const closeOnPressOutside = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((event)=>{\n        var _dataRef$current$floa2;\n        // Given developers can stop the propagation of the synthetic event,\n        // we can only be confident with a positive value.\n        const insideReactTree = dataRef.current.insideReactTree;\n        dataRef.current.insideReactTree = false;\n        // When click outside is lazy (`click` event), handle dragging.\n        // Don't close if:\n        // - The click started inside the floating element.\n        // - The click ended inside the floating element.\n        const endedOrStartedInside = endedOrStartedInsideRef.current;\n        endedOrStartedInsideRef.current = false;\n        if (outsidePressEvent === \"click\" && endedOrStartedInside) {\n            return;\n        }\n        if (insideReactTree) {\n            return;\n        }\n        if (typeof outsidePress === \"function\" && !outsidePress(event)) {\n            return;\n        }\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n        const inertSelector = \"[\" + createAttribute(\"inert\") + \"]\";\n        const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating).querySelectorAll(inertSelector);\n        let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(target) ? target : null;\n        while(targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isLastTraversableNode)(targetRootAncestor)){\n            const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getParentNode)(targetRootAncestor);\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(nextParent)) {\n                break;\n            }\n            targetRootAncestor = nextParent;\n        }\n        // Check if the click occurred on a third-party element injected after the\n        // floating element rendered.\n        if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isRootElement)(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).\n        !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(target, elements.floating) && // If the target root element contains none of the markers, then the\n        // element was injected after the floating element rendered.\n        Array.from(markers).every((marker)=>!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(targetRootAncestor, marker))) {\n            return;\n        }\n        // Check if the click occurred on the scrollbar\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(target) && floating) {\n            const lastTraversableNode = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isLastTraversableNode)(target);\n            const style = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getComputedStyle)(target);\n            const scrollRe = /auto|scroll/;\n            const isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX);\n            const isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY);\n            const canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n            const canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n            const isRTL = style.direction === \"rtl\";\n            // Check click position relative to scrollbar.\n            // In some browsers it is possible to change the <body> (or window)\n            // scrollbar to the left side, but is very rare and is difficult to\n            // check for. Plus, for modal dialogs with backdrops, it is more\n            // important that the backdrop is checked but not so much the window.\n            const pressedVerticalScrollbar = canScrollY && (isRTL ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth);\n            const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;\n            if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {\n                return;\n            }\n        }\n        const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;\n        const targetIsInsideChildren = tree && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, nodeId).some((node)=>{\n            var _node$context;\n            return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n        });\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, elements.floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, elements.domReference) || targetIsInsideChildren) {\n            return;\n        }\n        const children = tree ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, nodeId) : [];\n        if (children.length > 0) {\n            let shouldDismiss = true;\n            children.forEach((child)=>{\n                var _child$context2;\n                if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n                    shouldDismiss = false;\n                    return;\n                }\n            });\n            if (!shouldDismiss) {\n                return;\n            }\n        }\n        onOpenChange(false, event, \"outside-press\");\n    });\n    const closeOnPressOutsideCapture = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((event)=>{\n        var _getTarget4;\n        const callback = ()=>{\n            var _getTarget3;\n            closeOnPressOutside(event);\n            (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n        };\n        (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open || !enabled) {\n            return;\n        }\n        dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n        dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n        let compositionTimeout = -1;\n        function onScroll(event) {\n            onOpenChange(false, event, \"ancestor-scroll\");\n        }\n        function handleCompositionStart() {\n            window.clearTimeout(compositionTimeout);\n            isComposingRef.current = true;\n        }\n        function handleCompositionEnd() {\n            // Safari fires `compositionend` before `keydown`, so we need to wait\n            // until the next tick to set `isComposing` to `false`.\n            // https://bugs.webkit.org/show_bug.cgi?id=165004\n            compositionTimeout = window.setTimeout(()=>{\n                isComposingRef.current = false;\n            }, // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.\n            // Only apply to WebKit for the test to remain 0ms.\n            (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isWebKit)() ? 5 : 0);\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating);\n        if (escapeKey) {\n            doc.addEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n            doc.addEventListener(\"compositionstart\", handleCompositionStart);\n            doc.addEventListener(\"compositionend\", handleCompositionEnd);\n        }\n        outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        let ancestors = [];\n        if (ancestorScroll) {\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.domReference)) {\n                ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getOverflowAncestors)(elements.domReference);\n            }\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.floating)) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getOverflowAncestors)(elements.floating));\n            }\n            if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.reference) && elements.reference && elements.reference.contextElement) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getOverflowAncestors)(elements.reference.contextElement));\n            }\n        }\n        // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n        ancestors = ancestors.filter((ancestor)=>{\n            var _doc$defaultView;\n            return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n        });\n        ancestors.forEach((ancestor)=>{\n            ancestor.addEventListener(\"scroll\", onScroll, {\n                passive: true\n            });\n        });\n        return ()=>{\n            if (escapeKey) {\n                doc.removeEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n                doc.removeEventListener(\"compositionstart\", handleCompositionStart);\n                doc.removeEventListener(\"compositionend\", handleCompositionEnd);\n            }\n            outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n            ancestors.forEach((ancestor)=>{\n                ancestor.removeEventListener(\"scroll\", onScroll);\n            });\n            window.clearTimeout(compositionTimeout);\n        };\n    }, [\n        dataRef,\n        elements,\n        escapeKey,\n        outsidePress,\n        outsidePressEvent,\n        open,\n        onOpenChange,\n        ancestorScroll,\n        enabled,\n        escapeKeyBubbles,\n        outsidePressBubbles,\n        closeOnEscapeKeyDown,\n        escapeKeyCapture,\n        closeOnEscapeKeyDownCapture,\n        closeOnPressOutside,\n        outsidePressCapture,\n        closeOnPressOutsideCapture\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        dataRef.current.insideReactTree = false;\n    }, [\n        dataRef,\n        outsidePress,\n        outsidePressEvent\n    ]);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onKeyDown: closeOnEscapeKeyDown,\n            ...referencePress && {\n                [bubbleHandlerKeys[referencePressEvent]]: (event)=>{\n                    onOpenChange(false, event.nativeEvent, \"reference-press\");\n                },\n                ...referencePressEvent !== \"click\" && {\n                    onClick (event) {\n                        onOpenChange(false, event.nativeEvent, \"reference-press\");\n                    }\n                }\n            }\n        }), [\n        closeOnEscapeKeyDown,\n        onOpenChange,\n        referencePress,\n        referencePressEvent\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onKeyDown: closeOnEscapeKeyDown,\n            onMouseDown () {\n                endedOrStartedInsideRef.current = true;\n            },\n            onMouseUp () {\n                endedOrStartedInsideRef.current = true;\n            },\n            [captureHandlerKeys[outsidePressEvent]]: ()=>{\n                dataRef.current.insideReactTree = true;\n            },\n            onBlurCapture () {\n                if (tree) return;\n                clearTimeoutIfSet(blurTimeoutRef);\n                dataRef.current.insideReactTree = true;\n                blurTimeoutRef.current = window.setTimeout(()=>{\n                    dataRef.current.insideReactTree = false;\n                });\n            }\n        }), [\n        closeOnEscapeKeyDown,\n        outsidePressEvent,\n        dataRef,\n        tree\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating\n        } : {}, [\n        enabled,\n        reference,\n        floating\n    ]);\n}\nfunction useFloatingRootContext(options) {\n    const { open = false, onOpenChange: onOpenChangeProp, elements: elementsProp } = options;\n    const floatingId = useId();\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    const [events] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createEventEmitter());\n    const nested = useFloatingParentNodeId() != null;\n    if (true) {\n        const optionDomReference = elementsProp.reference;\n        if (optionDomReference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(optionDomReference)) {\n            error(\"Cannot pass a virtual element to the `elements.reference` option,\", \"as it must be a real DOM element. Use `refs.setPositionReference()`\", \"instead.\");\n        }\n    }\n    const [positionReference, setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(elementsProp.reference);\n    const onOpenChange = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((open, event, reason)=>{\n        dataRef.current.openEvent = open ? event : undefined;\n        events.emit(\"openchange\", {\n            open,\n            event,\n            reason,\n            nested\n        });\n        onOpenChangeProp == null || onOpenChangeProp(open, event, reason);\n    });\n    const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            setPositionReference\n        }), []);\n    const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            reference: positionReference || elementsProp.reference || null,\n            floating: elementsProp.floating || null,\n            domReference: elementsProp.reference\n        }), [\n        positionReference,\n        elementsProp.reference,\n        elementsProp.floating\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            dataRef,\n            open,\n            onOpenChange,\n            elements,\n            events,\n            floatingId,\n            refs\n        }), [\n        open,\n        onOpenChange,\n        elements,\n        events,\n        floatingId,\n        refs\n    ]);\n}\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { nodeId } = options;\n    const internalRootContext = useFloatingRootContext({\n        ...options,\n        elements: {\n            reference: null,\n            floating: null,\n            ...options.elements\n        }\n    });\n    const rootContext = options.rootContext || internalRootContext;\n    const computedElements = rootContext.elements;\n    const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const [positionReference, _setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;\n    const domReference = optionDomReference || _domReference;\n    const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const tree = useFloatingTree();\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (domReference) {\n            domReferenceRef.current = domReference;\n        }\n    }, [\n        domReference\n    ]);\n    const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.useFloating)({\n        ...options,\n        elements: {\n            ...computedElements,\n            ...positionReference && {\n                reference: positionReference\n            }\n        }\n    });\n    const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        const computedPositionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(node) ? {\n            getBoundingClientRect: ()=>node.getBoundingClientRect(),\n            getClientRects: ()=>node.getClientRects(),\n            contextElement: node\n        } : node;\n        // Store the positionReference in state if the DOM reference is specified externally via the\n        // `elements.reference` option. This ensures that it won't be overridden on future renders.\n        _setPositionReference(computedPositionReference);\n        position.refs.setReference(computedPositionReference);\n    }, [\n        position.refs\n    ]);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(node) || node === null) {\n            domReferenceRef.current = node;\n            setDomReference(node);\n        }\n        // Backwards-compatibility for passing a virtual element to `reference`\n        // after it has set the DOM reference.\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n        // `null` to support `positionReference` + an unstable `reference`\n        // callback ref.\n        node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(node)) {\n            position.refs.setReference(node);\n        }\n    }, [\n        position.refs\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.refs,\n            setReference,\n            setPositionReference,\n            domReference: domReferenceRef\n        }), [\n        position.refs,\n        setReference,\n        setPositionReference\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.elements,\n            domReference: domReference\n        }), [\n        position.elements,\n        domReference\n    ]);\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            ...rootContext,\n            refs,\n            elements,\n            nodeId\n        }), [\n        position,\n        refs,\n        elements,\n        nodeId,\n        rootContext\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        rootContext.dataRef.current.floatingContext = context;\n        const node = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.id === nodeId);\n        if (node) {\n            node.context = context;\n        }\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            context,\n            refs,\n            elements\n        }), [\n        position,\n        refs,\n        elements,\n        context\n    ]);\n}\nfunction isMacSafari() {\n    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)();\n}\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */ function useFocus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, events, dataRef, elements } = context;\n    const { enabled = true, visibleOnly = true } = props;\n    const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getWindow)(elements.domReference);\n        // If the reference was focused and the user left the tab/window, and the\n        // floating element was not open, the focus should be blocked when they\n        // return to the tab/window.\n        function onBlur() {\n            if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(elements.domReference) && elements.domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.domReference))) {\n                blockFocusRef.current = true;\n            }\n        }\n        function onKeyDown() {\n            keyboardModalityRef.current = true;\n        }\n        function onPointerDown() {\n            keyboardModalityRef.current = false;\n        }\n        win.addEventListener(\"blur\", onBlur);\n        if (isMacSafari()) {\n            win.addEventListener(\"keydown\", onKeyDown, true);\n            win.addEventListener(\"pointerdown\", onPointerDown, true);\n        }\n        return ()=>{\n            win.removeEventListener(\"blur\", onBlur);\n            if (isMacSafari()) {\n                win.removeEventListener(\"keydown\", onKeyDown, true);\n                win.removeEventListener(\"pointerdown\", onPointerDown, true);\n            }\n        };\n    }, [\n        elements.domReference,\n        open,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        function onOpenChange(_ref) {\n            let { reason } = _ref;\n            if (reason === \"reference-press\" || reason === \"escape-key\") {\n                blockFocusRef.current = true;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        events,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            clearTimeoutIfSet(timeoutRef);\n        };\n    }, []);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onMouseLeave () {\n                blockFocusRef.current = false;\n            },\n            onFocus (event) {\n                if (blockFocusRef.current) return;\n                const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event.nativeEvent);\n                if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(target)) {\n                    // Safari fails to match `:focus-visible` if focus was initially\n                    // outside the document.\n                    if (isMacSafari() && !event.relatedTarget) {\n                        if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(target)) {\n                            return;\n                        }\n                    } else if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.matchesFocusVisible)(target)) {\n                        return;\n                    }\n                }\n                onOpenChange(true, event.nativeEvent, \"focus\");\n            },\n            onBlur (event) {\n                blockFocusRef.current = false;\n                const relatedTarget = event.relatedTarget;\n                const nativeEvent = event.nativeEvent;\n                // Hit the non-modal focus management portal guard. Focus will be\n                // moved into the floating element immediately after.\n                const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) && relatedTarget.getAttribute(\"data-type\") === \"outside\";\n                // Wait for the window blur listener to fire.\n                timeoutRef.current = window.setTimeout(()=>{\n                    var _dataRef$current$floa;\n                    const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(elements.domReference ? elements.domReference.ownerDocument : document);\n                    // Focus left the page, keep it open.\n                    if (!relatedTarget && activeEl === elements.domReference) return;\n                    // When focusing the reference element (e.g. regular click), then\n                    // clicking into the floating element, prevent it from hiding.\n                    // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n                    // We can not rely on relatedTarget to point to the correct element\n                    // as it will only point to the shadow host of the newly focused element\n                    // and not the element that actually has received focus if it is located\n                    // inside a shadow root.\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.domReference, activeEl) || movedToFocusGuard) {\n                        return;\n                    }\n                    onOpenChange(false, nativeEvent, \"focus\");\n                });\n            }\n        }), [\n        dataRef,\n        elements.domReference,\n        onOpenChange,\n        visibleOnly\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference\n        } : {}, [\n        enabled,\n        reference\n    ]);\n}\nfunction mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    const isItem = elementKey === \"item\";\n    let domUserProps = userProps;\n    if (isItem && userProps) {\n        const { [ACTIVE_KEY]: _, [SELECTED_KEY]: __, ...validProps } = userProps;\n        domUserProps = validProps;\n    }\n    return {\n        ...elementKey === \"floating\" && {\n            tabIndex: -1,\n            [FOCUSABLE_ATTRIBUTE]: \"\"\n        },\n        ...domUserProps,\n        ...propsList.map((value)=>{\n            const propsOrGetProps = value ? value[elementKey] : null;\n            if (typeof propsOrGetProps === \"function\") {\n                return userProps ? propsOrGetProps(userProps) : null;\n            }\n            return propsOrGetProps;\n        }).concat(userProps).reduce((acc, props)=>{\n            if (!props) {\n                return acc;\n            }\n            Object.entries(props).forEach((_ref)=>{\n                let [key, value] = _ref;\n                if (isItem && [\n                    ACTIVE_KEY,\n                    SELECTED_KEY\n                ].includes(key)) {\n                    return;\n                }\n                if (key.indexOf(\"on\") === 0) {\n                    if (!map.has(key)) {\n                        map.set(key, []);\n                    }\n                    if (typeof value === \"function\") {\n                        var _map$get;\n                        (_map$get = map.get(key)) == null || _map$get.push(value);\n                        acc[key] = function() {\n                            var _map$get2;\n                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                args[_key] = arguments[_key];\n                            }\n                            return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn)=>fn(...args)).find((val)=>val !== undefined);\n                        };\n                    }\n                } else {\n                    acc[key] = value;\n                }\n            });\n            return acc;\n        }, {})\n    };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */ function useInteractions(propsList) {\n    if (propsList === void 0) {\n        propsList = [];\n    }\n    const referenceDeps = propsList.map((key)=>key == null ? void 0 : key.reference);\n    const floatingDeps = propsList.map((key)=>key == null ? void 0 : key.floating);\n    const itemDeps = propsList.map((key)=>key == null ? void 0 : key.item);\n    const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"reference\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    referenceDeps);\n    const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"floating\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    floatingDeps);\n    const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"item\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    itemDeps);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            getReferenceProps,\n            getFloatingProps,\n            getItemProps\n        }), [\n        getReferenceProps,\n        getFloatingProps,\n        getItemProps\n    ]);\n}\nconst ESCAPE = \"Escape\";\nfunction doSwitch(orientation, vertical, horizontal) {\n    switch(orientation){\n        case \"vertical\":\n            return vertical;\n        case \"horizontal\":\n            return horizontal;\n        default:\n            return vertical || horizontal;\n    }\n}\nfunction isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === \"Enter\" || key === \" \" || key === \"\";\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl, cols) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    if (orientation === \"both\" || orientation === \"horizontal\" && cols && cols > 1) {\n        return key === ESCAPE;\n    }\n    return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */ function useListNavigation(context, props) {\n    const { open, onOpenChange, elements, floatingId } = context;\n    const { listRef, activeIndex, onNavigate: unstable_onNavigate = ()=>{}, enabled = true, selectedIndex = null, allowEscape = false, loop = false, nested = false, rtl = false, virtual = false, focusItemOnOpen = \"auto\", focusItemOnHover = true, openOnArrowKeyDown = true, disabledIndices = undefined, orientation = \"vertical\", parentOrientation, cols = 1, scrollItemIntoView = true, virtualItemRef, itemSizes, dense = false } = props;\n    if (true) {\n        if (allowEscape) {\n            if (!loop) {\n                warn(\"`useListNavigation` looping must be enabled to allow escaping.\");\n            }\n            if (!virtual) {\n                warn(\"`useListNavigation` must be virtual to allow escaping.\");\n            }\n        }\n        if (orientation === \"vertical\" && cols > 1) {\n            warn(\"In grid list navigation mode (`cols` > 1), the `orientation` should\", 'be either \"horizontal\" or \"both\".');\n        }\n    }\n    const floatingFocusElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getFloatingFocusElement)(elements.floating);\n    const floatingFocusElementRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(floatingFocusElement);\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        context.dataRef.current.orientation = orientation;\n    }, [\n        context,\n        orientation\n    ]);\n    const onNavigate = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(()=>{\n        unstable_onNavigate(indexRef.current === -1 ? null : indexRef.current);\n    });\n    const typeableComboboxReference = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(elements.domReference);\n    const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n    const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n    const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!elements.floating);\n    const previousOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(open);\n    const forceSyncFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const disabledIndicesRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(disabledIndices);\n    const latestOpenRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(open);\n    const scrollItemIntoViewRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(scrollItemIntoView);\n    const selectedIndexRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(selectedIndex);\n    const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const focusItem = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(()=>{\n        function runFocus(item) {\n            if (virtual) {\n                var _item$id;\n                if ((_item$id = item.id) != null && _item$id.endsWith(\"-fui-option\")) {\n                    item.id = floatingId + \"-\" + Math.random().toString(16).slice(2, 10);\n                }\n                setActiveId(item.id);\n                tree == null || tree.events.emit(\"virtualfocus\", item);\n                if (virtualItemRef) {\n                    virtualItemRef.current = item;\n                }\n            } else {\n                enqueueFocus(item, {\n                    sync: forceSyncFocusRef.current,\n                    preventScroll: true\n                });\n            }\n        }\n        const initialItem = listRef.current[indexRef.current];\n        const forceScrollIntoView = forceScrollIntoViewRef.current;\n        if (initialItem) {\n            runFocus(initialItem);\n        }\n        const scheduler = forceSyncFocusRef.current ? (v)=>v() : requestAnimationFrame;\n        scheduler(()=>{\n            const waitedItem = listRef.current[indexRef.current] || initialItem;\n            if (!waitedItem) return;\n            if (!initialItem) {\n                runFocus(waitedItem);\n            }\n            const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n            const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n            if (shouldScrollIntoView) {\n                // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n                // by all browsers.\n                waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === \"boolean\" ? {\n                    block: \"nearest\",\n                    inline: \"nearest\"\n                } : scrollIntoViewOptions);\n            }\n        });\n    });\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!enabled) return;\n        if (open && elements.floating) {\n            if (focusItemOnOpenRef.current && selectedIndex != null) {\n                // Regardless of the pointer modality, we want to ensure the selected\n                // item comes into view when the floating element is opened.\n                forceScrollIntoViewRef.current = true;\n                indexRef.current = selectedIndex;\n                onNavigate();\n            }\n        } else if (previousMountedRef.current) {\n            // Since the user can specify `onNavigate` conditionally\n            // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n            // we store and call the previous function.\n            indexRef.current = -1;\n            previousOnNavigateRef.current();\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        selectedIndex,\n        onNavigate\n    ]);\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!enabled) return;\n        if (!open) return;\n        if (!elements.floating) return;\n        if (activeIndex == null) {\n            forceSyncFocusRef.current = false;\n            if (selectedIndexRef.current != null) {\n                return;\n            }\n            // Reset while the floating element was open (e.g. the list changed).\n            if (previousMountedRef.current) {\n                indexRef.current = -1;\n                focusItem();\n            }\n            // Initial sync.\n            if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n                let runs = 0;\n                const waitForListPopulated = ()=>{\n                    if (listRef.current[0] == null) {\n                        // Avoid letting the browser paint if possible on the first try,\n                        // otherwise use rAF. Don't try more than twice, since something\n                        // is wrong otherwise.\n                        if (runs < 2) {\n                            const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                            scheduler(waitForListPopulated);\n                        }\n                        runs++;\n                    } else {\n                        indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMinListIndex)(listRef, disabledIndicesRef.current) : (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMaxListIndex)(listRef, disabledIndicesRef.current);\n                        keyRef.current = null;\n                        onNavigate();\n                    }\n                };\n                waitForListPopulated();\n            }\n        } else if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isIndexOutOfListBounds)(listRef, activeIndex)) {\n            indexRef.current = activeIndex;\n            focusItem();\n            forceScrollIntoViewRef.current = false;\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        activeIndex,\n        selectedIndexRef,\n        nested,\n        listRef,\n        orientation,\n        rtl,\n        onNavigate,\n        focusItem,\n        disabledIndicesRef\n    ]);\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        var _nodes$find;\n        if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {\n            return;\n        }\n        const nodes = tree.nodesRef.current;\n        const parent = (_nodes$find = nodes.find((node)=>node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating));\n        const treeContainsActiveEl = nodes.some((node)=>node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(node.context.elements.floating, activeEl));\n        if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n            parent.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        enabled,\n        elements.floating,\n        tree,\n        parentId,\n        virtual\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!enabled) return;\n        if (!tree) return;\n        if (!virtual) return;\n        if (parentId) return;\n        function handleVirtualFocus(item) {\n            setVirtualId(item.id);\n            if (virtualItemRef) {\n                virtualItemRef.current = item;\n            }\n        }\n        tree.events.on(\"virtualfocus\", handleVirtualFocus);\n        return ()=>{\n            tree.events.off(\"virtualfocus\", handleVirtualFocus);\n        };\n    }, [\n        enabled,\n        tree,\n        virtual,\n        parentId,\n        virtualItemRef\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        previousOnNavigateRef.current = onNavigate;\n        previousOpenRef.current = open;\n        previousMountedRef.current = !!elements.floating;\n    });\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!open) {\n            keyRef.current = null;\n            focusItemOnOpenRef.current = focusItemOnOpen;\n        }\n    }, [\n        open,\n        focusItemOnOpen\n    ]);\n    const hasActiveIndex = activeIndex != null;\n    const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function syncCurrentTarget(currentTarget) {\n            if (!latestOpenRef.current) return;\n            const index = listRef.current.indexOf(currentTarget);\n            if (index !== -1 && indexRef.current !== index) {\n                indexRef.current = index;\n                onNavigate();\n            }\n        }\n        const props = {\n            onFocus (_ref) {\n                let { currentTarget } = _ref;\n                forceSyncFocusRef.current = true;\n                syncCurrentTarget(currentTarget);\n            },\n            onClick: (_ref2)=>{\n                let { currentTarget } = _ref2;\n                return currentTarget.focus({\n                    preventScroll: true\n                });\n            },\n            // Safari\n            ...focusItemOnHover && {\n                onMouseMove (_ref3) {\n                    let { currentTarget } = _ref3;\n                    forceSyncFocusRef.current = true;\n                    forceScrollIntoViewRef.current = false;\n                    syncCurrentTarget(currentTarget);\n                },\n                onPointerLeave (_ref4) {\n                    let { pointerType } = _ref4;\n                    if (!isPointerModalityRef.current || pointerType === \"touch\") {\n                        return;\n                    }\n                    forceSyncFocusRef.current = true;\n                    indexRef.current = -1;\n                    onNavigate();\n                    if (!virtual) {\n                        var _floatingFocusElement;\n                        (_floatingFocusElement = floatingFocusElementRef.current) == null || _floatingFocusElement.focus({\n                            preventScroll: true\n                        });\n                    }\n                }\n            }\n        };\n        return props;\n    }, [\n        latestOpenRef,\n        floatingFocusElementRef,\n        focusItemOnHover,\n        listRef,\n        onNavigate,\n        virtual\n    ]);\n    const getParentOrientation = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        var _tree$nodesRef$curren;\n        return parentOrientation != null ? parentOrientation : tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.dataRef) == null ? void 0 : _tree$nodesRef$curren.current.orientation;\n    }, [\n        parentId,\n        tree,\n        parentOrientation\n    ]);\n    const commonOnKeyDown = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((event)=>{\n        isPointerModalityRef.current = false;\n        forceSyncFocusRef.current = true;\n        // When composing a character, Chrome fires ArrowDown twice. Firefox/Safari\n        // don't appear to suffer from this. `event.isComposing` is avoided due to\n        // Safari not supporting it properly (although it's not needed in the first\n        // place for Safari, just avoiding any possible issues).\n        if (event.which === 229) {\n            return;\n        }\n        // If the floating element is animating out, ignore navigation. Otherwise,\n        // the `activeIndex` gets set to 0 despite not being open so the next time\n        // the user ArrowDowns, the first item won't be focused.\n        if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {\n            return;\n        }\n        if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {\n            // If the nested list's close key is also the parent navigation key,\n            // let the parent navigate. Otherwise, stop propagating the event.\n            if (!isMainOrientationKey(event.key, getParentOrientation())) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            }\n            onOpenChange(false, event.nativeEvent, \"list-navigation\");\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(elements.domReference)) {\n                if (virtual) {\n                    tree == null || tree.events.emit(\"virtualfocus\", elements.domReference);\n                } else {\n                    elements.domReference.focus();\n                }\n            }\n            return;\n        }\n        const currentIndex = indexRef.current;\n        const minIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMinListIndex)(listRef, disabledIndices);\n        const maxIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMaxListIndex)(listRef, disabledIndices);\n        if (!typeableComboboxReference) {\n            if (event.key === \"Home\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                indexRef.current = minIndex;\n                onNavigate();\n            }\n            if (event.key === \"End\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                indexRef.current = maxIndex;\n                onNavigate();\n            }\n        }\n        // Grid navigation.\n        if (cols > 1) {\n            const sizes = itemSizes || Array.from({\n                length: listRef.current.length\n            }, ()=>({\n                    width: 1,\n                    height: 1\n                }));\n            // To calculate movements on the grid, we use hypothetical cell indices\n            // as if every item was 1x1, then convert back to real indices.\n            const cellMap = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.createGridCellMap)(sizes, cols, dense);\n            const minGridIndex = cellMap.findIndex((index)=>index != null && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(listRef, index, disabledIndices));\n            // last enabled index\n            const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex)=>index != null && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(listRef, index, disabledIndices) ? cellIndex : foundIndex, -1);\n            const index = cellMap[(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridNavigatedIndex)({\n                current: cellMap.map((itemIndex)=>itemIndex != null ? listRef.current[itemIndex] : null)\n            }, {\n                event,\n                orientation,\n                loop,\n                rtl,\n                cols,\n                // treat undefined (empty grid spaces) as disabled indices so we\n                // don't end up in them\n                disabledIndices: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridCellIndices)([\n                    ...(typeof disabledIndices !== \"function\" ? disabledIndices : null) || listRef.current.map((_, index)=>(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(listRef, index, disabledIndices) ? index : undefined),\n                    undefined\n                ], cellMap),\n                minIndex: minGridIndex,\n                maxIndex: maxGridIndex,\n                prevIndex: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridCellIndexOfCorner)(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols, // use a corner matching the edge closest to the direction\n                // we're moving in so we don't end up in the same item. Prefer\n                // top/left over bottom/right.\n                event.key === ARROW_DOWN ? \"bl\" : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? \"tr\" : \"tl\"),\n                stopEvent: true\n            })];\n            if (index != null) {\n                indexRef.current = index;\n                onNavigate();\n            }\n            if (orientation === \"both\") {\n                return;\n            }\n        }\n        if (isMainOrientationKey(event.key, orientation)) {\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            // Reset the index if no item is focused.\n            if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n                indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n                onNavigate();\n                return;\n            }\n            if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n                if (loop) {\n                    indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(listRef, {\n                        startingIndex: currentIndex,\n                        disabledIndices\n                    });\n                } else {\n                    indexRef.current = Math.min(maxIndex, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(listRef, {\n                        startingIndex: currentIndex,\n                        disabledIndices\n                    }));\n                }\n            } else {\n                if (loop) {\n                    indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(listRef, {\n                        startingIndex: currentIndex,\n                        decrement: true,\n                        disabledIndices\n                    });\n                } else {\n                    indexRef.current = Math.max(minIndex, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(listRef, {\n                        startingIndex: currentIndex,\n                        decrement: true,\n                        disabledIndices\n                    }));\n                }\n            }\n            if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isIndexOutOfListBounds)(listRef, indexRef.current)) {\n                indexRef.current = -1;\n            }\n            onNavigate();\n        }\n    });\n    const ariaActiveDescendantProp = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return virtual && open && hasActiveIndex && {\n            \"aria-activedescendant\": virtualId || activeId\n        };\n    }, [\n        virtual,\n        open,\n        hasActiveIndex,\n        virtualId,\n        activeId\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n            ...!typeableComboboxReference ? ariaActiveDescendantProp : {},\n            onKeyDown: commonOnKeyDown,\n            onPointerMove () {\n                isPointerModalityRef.current = true;\n            }\n        };\n    }, [\n        ariaActiveDescendantProp,\n        commonOnKeyDown,\n        orientation,\n        typeableComboboxReference\n    ]);\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function checkVirtualMouse(event) {\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        function checkVirtualPointer(event) {\n            // `pointerdown` fires first, reset the state then perform the checks.\n            focusItemOnOpenRef.current = focusItemOnOpen;\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        return {\n            ...ariaActiveDescendantProp,\n            onKeyDown (event) {\n                isPointerModalityRef.current = false;\n                const isArrowKey = event.key.startsWith(\"Arrow\");\n                const isHomeOrEndKey = [\n                    \"Home\",\n                    \"End\"\n                ].includes(event.key);\n                const isMoveKey = isArrowKey || isHomeOrEndKey;\n                const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n                const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl, cols);\n                const isParentCrossOpenKey = isCrossOrientationOpenKey(event.key, getParentOrientation(), rtl);\n                const isMainKey = isMainOrientationKey(event.key, orientation);\n                const isNavigationKey = (nested ? isParentCrossOpenKey : isMainKey) || event.key === \"Enter\" || event.key.trim() === \"\";\n                if (virtual && open) {\n                    const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.parentId == null);\n                    const deepestNode = tree && rootNode ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDeepestNode)(tree.nodesRef.current, rootNode.id) : null;\n                    if (isMoveKey && deepestNode && virtualItemRef) {\n                        const eventObject = new KeyboardEvent(\"keydown\", {\n                            key: event.key,\n                            bubbles: true\n                        });\n                        if (isCrossOpenKey || isCrossCloseKey) {\n                            var _deepestNode$context, _deepestNode$context2;\n                            const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                            const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find((item)=>(item == null ? void 0 : item.id) === activeId) : null;\n                            if (dispatchItem) {\n                                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                                dispatchItem.dispatchEvent(eventObject);\n                                setVirtualId(undefined);\n                            }\n                        }\n                        if ((isMainKey || isHomeOrEndKey) && deepestNode.context) {\n                            if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                                var _deepestNode$context$;\n                                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                                (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                                return;\n                            }\n                        }\n                    }\n                    return commonOnKeyDown(event);\n                }\n                // If a floating element should not open on arrow key down, avoid\n                // setting `activeIndex` while it's closed.\n                if (!open && !openOnArrowKeyDown && isArrowKey) {\n                    return;\n                }\n                if (isNavigationKey) {\n                    const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());\n                    keyRef.current = nested && isParentMainKey ? null : event.key;\n                }\n                if (nested) {\n                    if (isParentCrossOpenKey) {\n                        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                        if (open) {\n                            indexRef.current = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMinListIndex)(listRef, disabledIndicesRef.current);\n                            onNavigate();\n                        } else {\n                            onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                        }\n                    }\n                    return;\n                }\n                if (isMainKey) {\n                    if (selectedIndex != null) {\n                        indexRef.current = selectedIndex;\n                    }\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    if (!open && openOnArrowKeyDown) {\n                        onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                    } else {\n                        commonOnKeyDown(event);\n                    }\n                    if (open) {\n                        onNavigate();\n                    }\n                }\n            },\n            onFocus () {\n                if (open && !virtual) {\n                    indexRef.current = -1;\n                    onNavigate();\n                }\n            },\n            onPointerDown: checkVirtualPointer,\n            onPointerEnter: checkVirtualPointer,\n            onMouseDown: checkVirtualMouse,\n            onClick: checkVirtualMouse\n        };\n    }, [\n        activeId,\n        ariaActiveDescendantProp,\n        cols,\n        commonOnKeyDown,\n        disabledIndicesRef,\n        focusItemOnOpen,\n        listRef,\n        nested,\n        onNavigate,\n        onOpenChange,\n        open,\n        openOnArrowKeyDown,\n        orientation,\n        getParentOrientation,\n        rtl,\n        selectedIndex,\n        tree,\n        virtual,\n        virtualItemRef\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating,\n            item\n        } : {}, [\n        enabled,\n        reference,\n        floating,\n        item\n    ]);\n}\nconst componentRoleToAriaRoleMap = /*#__PURE__*/ new Map([\n    [\n        \"select\",\n        \"listbox\"\n    ],\n    [\n        \"combobox\",\n        \"listbox\"\n    ],\n    [\n        \"label\",\n        false\n    ]\n]);\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */ function useRole(context, props) {\n    var _elements$domReferenc, _componentRoleToAriaR;\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, elements, floatingId: defaultFloatingId } = context;\n    const { enabled = true, role = \"dialog\" } = props;\n    const defaultReferenceId = useId();\n    const referenceId = ((_elements$domReferenc = elements.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId;\n    const floatingId = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        var _getFloatingFocusElem;\n        return ((_getFloatingFocusElem = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getFloatingFocusElement)(elements.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;\n    }, [\n        elements.floating,\n        defaultFloatingId\n    ]);\n    const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n    const parentId = useFloatingParentNodeId();\n    const isNested = parentId != null;\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (ariaRole === \"tooltip\" || role === \"label\") {\n            return {\n                [\"aria-\" + (role === \"label\" ? \"labelledby\" : \"describedby\")]: open ? floatingId : undefined\n            };\n        }\n        return {\n            \"aria-expanded\": open ? \"true\" : \"false\",\n            \"aria-haspopup\": ariaRole === \"alertdialog\" ? \"dialog\" : ariaRole,\n            \"aria-controls\": open ? floatingId : undefined,\n            ...ariaRole === \"listbox\" && {\n                role: \"combobox\"\n            },\n            ...ariaRole === \"menu\" && {\n                id: referenceId\n            },\n            ...ariaRole === \"menu\" && isNested && {\n                role: \"menuitem\"\n            },\n            ...role === \"select\" && {\n                \"aria-autocomplete\": \"none\"\n            },\n            ...role === \"combobox\" && {\n                \"aria-autocomplete\": \"list\"\n            }\n        };\n    }, [\n        ariaRole,\n        floatingId,\n        isNested,\n        open,\n        referenceId,\n        role\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const floatingProps = {\n            id: floatingId,\n            ...ariaRole && {\n                role: ariaRole\n            }\n        };\n        if (ariaRole === \"tooltip\" || role === \"label\") {\n            return floatingProps;\n        }\n        return {\n            ...floatingProps,\n            ...ariaRole === \"menu\" && {\n                \"aria-labelledby\": referenceId\n            }\n        };\n    }, [\n        ariaRole,\n        floatingId,\n        referenceId,\n        role\n    ]);\n    const item = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_ref)=>{\n        let { active, selected } = _ref;\n        const commonProps = {\n            role: \"option\",\n            ...active && {\n                id: floatingId + \"-fui-option\"\n            }\n        };\n        // For `menu`, we are unable to tell if the item is a `menuitemradio`\n        // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n        // avoid defaulting to `menuitem` as it may overwrite custom role props.\n        switch(role){\n            case \"select\":\n                return {\n                    ...commonProps,\n                    \"aria-selected\": active && selected\n                };\n            case \"combobox\":\n                {\n                    return {\n                        ...commonProps,\n                        \"aria-selected\": selected\n                    };\n                }\n        }\n        return {};\n    }, [\n        floatingId,\n        role\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating,\n            item\n        } : {}, [\n        enabled,\n        reference,\n        floating,\n        item\n    ]);\n}\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = (str)=>str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs)=>(ofs ? \"-\" : \"\") + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n    return typeof valueOrFn === \"function\" ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n    const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n    if (open && !isMounted) {\n        setIsMounted(true);\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open && isMounted) {\n            const timeout = setTimeout(()=>setIsMounted(false), durationMs);\n            return ()=>clearTimeout(timeout);\n        }\n    }, [\n        open,\n        isMounted,\n        durationMs\n    ]);\n    return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */ function useTransitionStatus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, elements: { floating } } = context;\n    const { duration = 250 } = props;\n    const isNumberDuration = typeof duration === \"number\";\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"unmounted\");\n    const isMounted = useDelayUnmount(open, closeDuration);\n    if (!isMounted && status === \"close\") {\n        setStatus(\"unmounted\");\n    }\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (!floating) return;\n        if (open) {\n            setStatus(\"initial\");\n            const frame = requestAnimationFrame(()=>{\n                // Ensure it opens before paint. With `FloatingDelayGroup`,\n                // this avoids a flicker when moving between floating elements\n                // to ensure one is always open with no missing frames.\n                react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(()=>{\n                    setStatus(\"open\");\n                });\n            });\n            return ()=>{\n                cancelAnimationFrame(frame);\n            };\n        }\n        setStatus(\"close\");\n    }, [\n        open,\n        floating\n    ]);\n    return {\n        isMounted,\n        status\n    };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */ function useTransitionStyles(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { initial: unstable_initial = {\n        opacity: 0\n    }, open: unstable_open, close: unstable_close, common: unstable_common, duration = 250 } = props;\n    const placement = context.placement;\n    const side = placement.split(\"-\")[0];\n    const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            side,\n            placement\n        }), [\n        side,\n        placement\n    ]);\n    const isNumberDuration = typeof duration === \"number\";\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            ...execWithArgsOrReturn(unstable_common, fnArgs),\n            ...execWithArgsOrReturn(unstable_initial, fnArgs)\n        }));\n    const { isMounted, status } = useTransitionStatus(context, {\n        duration\n    });\n    const initialRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(unstable_initial);\n    const openRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(unstable_open);\n    const closeRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(unstable_close);\n    const commonRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(unstable_common);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n        const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n        const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n        const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key)=>{\n            acc[key] = \"\";\n            return acc;\n        }, {});\n        if (status === \"initial\") {\n            setStyles((styles)=>({\n                    transitionProperty: styles.transitionProperty,\n                    ...commonStyles,\n                    ...initialStyles\n                }));\n        }\n        if (status === \"open\") {\n            setStyles({\n                transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: openDuration + \"ms\",\n                ...commonStyles,\n                ...openStyles\n            });\n        }\n        if (status === \"close\") {\n            const styles = closeStyles || initialStyles;\n            setStyles({\n                transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: closeDuration + \"ms\",\n                ...commonStyles,\n                ...styles\n            });\n        }\n    }, [\n        closeDuration,\n        closeRef,\n        initialRef,\n        openRef,\n        commonRef,\n        openDuration,\n        status,\n        fnArgs\n    ]);\n    return {\n        isMounted,\n        styles\n    };\n}\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */ function useTypeahead(context, props) {\n    var _ref;\n    const { open, dataRef } = context;\n    const { listRef, activeIndex, onMatch: unstable_onMatch, onTypingChange: unstable_onTypingChange, enabled = true, findMatch = null, resetMs = 750, ignoreKeys = [], selectedIndex = null } = props;\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"\");\n    const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n    const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const onMatch = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(unstable_onMatch);\n    const onTypingChange = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(unstable_onTypingChange);\n    const findMatchRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(findMatch);\n    const ignoreKeysRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(ignoreKeys);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        if (open) {\n            clearTimeoutIfSet(timeoutIdRef);\n            matchIndexRef.current = null;\n            stringRef.current = \"\";\n        }\n    }, [\n        open\n    ]);\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(()=>{\n        // Sync arrow key navigation but not typeahead navigation.\n        if (open && stringRef.current === \"\") {\n            var _ref2;\n            prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n        }\n    }, [\n        open,\n        selectedIndex,\n        activeIndex\n    ]);\n    const setTypingChange = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((value)=>{\n        if (value) {\n            if (!dataRef.current.typing) {\n                dataRef.current.typing = value;\n                onTypingChange(value);\n            }\n        } else {\n            if (dataRef.current.typing) {\n                dataRef.current.typing = value;\n                onTypingChange(value);\n            }\n        }\n    });\n    const onKeyDown = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((event)=>{\n        function getMatchingIndex(list, orderedList, string) {\n            const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text)=>(text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n            return str ? list.indexOf(str) : -1;\n        }\n        const listContent = listRef.current;\n        if (stringRef.current.length > 0 && stringRef.current[0] !== \" \") {\n            if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n                setTypingChange(false);\n            } else if (event.key === \" \") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            }\n        }\n        if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.\n        event.key.length !== 1 || // Modifier key.\n        event.ctrlKey || event.metaKey || event.altKey) {\n            return;\n        }\n        if (open && event.key !== \" \") {\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            setTypingChange(true);\n        }\n        // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n        // allow it in this case, too.\n        const allowRapidSuccessionOfFirstLetter = listContent.every((text)=>{\n            var _text$, _text$2;\n            return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n        });\n        // Allows the user to cycle through items that start with the same letter\n        // in rapid succession.\n        if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n            stringRef.current = \"\";\n            prevIndexRef.current = matchIndexRef.current;\n        }\n        stringRef.current += event.key;\n        clearTimeoutIfSet(timeoutIdRef);\n        timeoutIdRef.current = window.setTimeout(()=>{\n            stringRef.current = \"\";\n            prevIndexRef.current = matchIndexRef.current;\n            setTypingChange(false);\n        }, resetMs);\n        const prevIndex = prevIndexRef.current;\n        const index = getMatchingIndex(listContent, [\n            ...listContent.slice((prevIndex || 0) + 1),\n            ...listContent.slice(0, (prevIndex || 0) + 1)\n        ], stringRef.current);\n        if (index !== -1) {\n            onMatch(index);\n            matchIndexRef.current = index;\n        } else if (event.key !== \" \") {\n            stringRef.current = \"\";\n            setTypingChange(false);\n        }\n    });\n    const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onKeyDown\n        }), [\n        onKeyDown\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            onKeyDown,\n            onKeyUp (event) {\n                if (event.key === \" \") {\n                    setTypingChange(false);\n                }\n            }\n        };\n    }, [\n        onKeyDown,\n        setTypingChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            reference,\n            floating\n        } : {}, [\n        enabled,\n        reference,\n        floating\n    ]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n    return {\n        ...state,\n        rects: {\n            ...state.rects,\n            floating: {\n                ...state.rects.floating,\n                height\n            }\n        }\n    };\n}\n/**\n * Positions the floating element such that an inner element inside of it is\n * anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n * @deprecated\n */ const inner = (props)=>({\n        name: \"inner\",\n        options: props,\n        async fn (state) {\n            const { listRef, overflowRef, onFallbackChange, offset: innerOffset = 0, index = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.evaluate)(props, state);\n            const { rects, elements: { floating } } = state;\n            const item = listRef.current[index];\n            const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n            // Valid combinations:\n            // 1. Floating element is the scrollRef and has a border (default)\n            // 2. Floating element is not the scrollRef, floating element has a border\n            // 3. Floating element is not the scrollRef, scrollRef has a border\n            // Floating > {...getFloatingProps()} wrapper > scrollRef > items is not\n            // allowed as VoiceOver doesn't work.\n            const clientTop = floating.clientTop || scrollEl.clientTop;\n            const floatingIsBordered = floating.clientTop !== 0;\n            const scrollElIsBordered = scrollEl.clientTop !== 0;\n            const floatingIsScrollEl = floating === scrollEl;\n            if (true) {\n                if (!state.placement.startsWith(\"bottom\")) {\n                    warn('`placement` side must be \"bottom\" when using the `inner`', \"middleware.\");\n                }\n            }\n            if (!item) {\n                return {};\n            }\n            const nextArgs = {\n                ...state,\n                ...await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)\n            };\n            const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);\n            const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.detectOverflow)(nextArgs, {\n                ...detectOverflowOptions,\n                elementContext: \"reference\"\n            });\n            const diffY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.max)(0, overflow.top);\n            const nextY = nextArgs.y + diffY;\n            const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;\n            const rounder = isScrollable ? (v)=>v : _floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.round;\n            const maxHeight = rounder((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.max)(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.max)(0, overflow.bottom)));\n            scrollEl.style.maxHeight = maxHeight + \"px\";\n            scrollEl.scrollTop = diffY;\n            // There is not enough space, fallback to standard anchored positioning\n            if (onFallbackChange) {\n                const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.min)(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;\n                react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(()=>onFallbackChange(shouldFallback));\n            }\n            if (overflowRef) {\n                overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.detectOverflow)(getArgsWithCustomFloatingHeight({\n                    ...nextArgs,\n                    y: nextY\n                }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);\n            }\n            return {\n                y: nextY\n            };\n        }\n    });\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n * @deprecated\n */ function useInnerOffset(context, props) {\n    const { open, elements } = context;\n    const { enabled = true, overflowRef, scrollRef, onChange: unstable_onChange } = props;\n    const onChange = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(unstable_onChange);\n    const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) return;\n        function onWheel(e) {\n            if (e.ctrlKey || !el || overflowRef.current == null) {\n                return;\n            }\n            const dY = e.deltaY;\n            const isAtTop = overflowRef.current.top >= -0.5;\n            const isAtBottom = overflowRef.current.bottom >= -0.5;\n            const remainingScroll = el.scrollHeight - el.clientHeight;\n            const sign = dY < 0 ? -1 : 1;\n            const method = dY < 0 ? \"max\" : \"min\";\n            if (el.scrollHeight <= el.clientHeight) {\n                return;\n            }\n            if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n                e.preventDefault();\n                react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(()=>{\n                    onChange((d)=>d + Math[method](dY, remainingScroll * sign));\n                });\n            } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getUserAgent)())) {\n                // Needed to propagate scrolling during momentum scrolling phase once\n                // it gets limited by the boundary. UX improvement, not critical.\n                el.scrollTop += dY;\n            }\n        }\n        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n        if (open && el) {\n            el.addEventListener(\"wheel\", onWheel);\n            // Wait for the position to be ready.\n            requestAnimationFrame(()=>{\n                prevScrollTopRef.current = el.scrollTop;\n                if (overflowRef.current != null) {\n                    initialOverflowRef.current = {\n                        ...overflowRef.current\n                    };\n                }\n            });\n            return ()=>{\n                prevScrollTopRef.current = null;\n                initialOverflowRef.current = null;\n                el.removeEventListener(\"wheel\", onWheel);\n            };\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        overflowRef,\n        scrollRef,\n        onChange\n    ]);\n    const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            onKeyDown () {\n                controlledScrollingRef.current = true;\n            },\n            onWheel () {\n                controlledScrollingRef.current = false;\n            },\n            onPointerMove () {\n                controlledScrollingRef.current = false;\n            },\n            onScroll () {\n                const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n                if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n                    return;\n                }\n                if (prevScrollTopRef.current !== null) {\n                    const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n                    if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n                        react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(()=>onChange((d)=>d + scrollDiff));\n                    }\n                }\n                // [Firefox] Wait for the height change to have been applied.\n                requestAnimationFrame(()=>{\n                    prevScrollTopRef.current = el.scrollTop;\n                });\n            }\n        }), [\n        elements.floating,\n        onChange,\n        overflowRef,\n        scrollRef\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>enabled ? {\n            floating\n        } : {}, [\n        enabled,\n        floating\n    ]);\n}\nfunction getNodeChildren(nodes, id, onlyOpenChildren) {\n    if (onlyOpenChildren === void 0) {\n        onlyOpenChildren = true;\n    }\n    const directChildren = nodes.filter((node)=>{\n        var _node$context;\n        return node.parentId === id && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));\n    });\n    return directChildren.flatMap((child)=>[\n            child,\n            ...getNodeChildren(nodes, child.id, onlyOpenChildren)\n        ]);\n}\nfunction isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for(let i = 0, j = length - 1; i < length; j = i++){\n        const [xi, yi] = polygon[i] || [\n            0,\n            0\n        ];\n        const [xj, yj] = polygon[j] || [\n            0,\n            0\n        ];\n        const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\nfunction isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */ function safePolygon(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { buffer = 0.5, blockPointerEvents = false, requireIntent = true } = options;\n    const timeoutRef = {\n        current: -1\n    };\n    let hasLanded = false;\n    let lastX = null;\n    let lastY = null;\n    let lastCursorTime = performance.now();\n    function getCursorSpeed(x, y) {\n        const currentTime = performance.now();\n        const elapsedTime = currentTime - lastCursorTime;\n        if (lastX === null || lastY === null || elapsedTime === 0) {\n            lastX = x;\n            lastY = y;\n            lastCursorTime = currentTime;\n            return null;\n        }\n        const deltaX = x - lastX;\n        const deltaY = y - lastY;\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        const speed = distance / elapsedTime; // px / ms\n        lastX = x;\n        lastY = y;\n        lastCursorTime = currentTime;\n        return speed;\n    }\n    const fn = (_ref)=>{\n        let { x, y, placement, elements, onClose, nodeId, tree } = _ref;\n        return function onMouseMove(event) {\n            function close() {\n                clearTimeoutIfSet(timeoutRef);\n                onClose();\n            }\n            clearTimeoutIfSet(timeoutRef);\n            if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n                return;\n            }\n            const { clientX, clientY } = event;\n            const clientPoint = [\n                clientX,\n                clientY\n            ];\n            const target = getTarget(event);\n            const isLeave = event.type === \"mouseleave\";\n            const isOverFloatingEl = contains(elements.floating, target);\n            const isOverReferenceEl = contains(elements.domReference, target);\n            const refRect = elements.domReference.getBoundingClientRect();\n            const rect = elements.floating.getBoundingClientRect();\n            const side = placement.split(\"-\")[0];\n            const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n            const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n            const isOverReferenceRect = isInside(clientPoint, refRect);\n            const isFloatingWider = rect.width > refRect.width;\n            const isFloatingTaller = rect.height > refRect.height;\n            const left = (isFloatingWider ? refRect : rect).left;\n            const right = (isFloatingWider ? refRect : rect).right;\n            const top = (isFloatingTaller ? refRect : rect).top;\n            const bottom = (isFloatingTaller ? refRect : rect).bottom;\n            if (isOverFloatingEl) {\n                hasLanded = true;\n                if (!isLeave) {\n                    return;\n                }\n            }\n            if (isOverReferenceEl) {\n                hasLanded = false;\n            }\n            if (isOverReferenceEl && !isLeave) {\n                hasLanded = true;\n                return;\n            }\n            // Prevent overlapping floating element from being stuck in an open-close\n            // loop: https://github.com/floating-ui/floating-ui/issues/1910\n            if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n                return;\n            }\n            // If any nested child is open, abort.\n            if (tree && getNodeChildren(tree.nodesRef.current, nodeId).length) {\n                return;\n            }\n            // If the pointer is leaving from the opposite side, the \"buffer\" logic\n            // creates a point where the floating element remains open, but should be\n            // ignored.\n            // A constant of 1 handles floating point rounding errors.\n            if (side === \"top\" && y >= refRect.bottom - 1 || side === \"bottom\" && y <= refRect.top + 1 || side === \"left\" && x >= refRect.right - 1 || side === \"right\" && x <= refRect.left + 1) {\n                return close();\n            }\n            // Ignore when the cursor is within the rectangular trough between the\n            // two elements. Since the triangle is created from the cursor point,\n            // which can start beyond the ref element's edge, traversing back and\n            // forth from the ref to the floating element can cause it to close. This\n            // ensures it always remains open in that case.\n            let rectPoly = [];\n            switch(side){\n                case \"top\":\n                    rectPoly = [\n                        [\n                            left,\n                            refRect.top + 1\n                        ],\n                        [\n                            left,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"bottom\":\n                    rectPoly = [\n                        [\n                            left,\n                            rect.top + 1\n                        ],\n                        [\n                            left,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"left\":\n                    rectPoly = [\n                        [\n                            rect.right - 1,\n                            bottom\n                        ],\n                        [\n                            rect.right - 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n                case \"right\":\n                    rectPoly = [\n                        [\n                            refRect.right - 1,\n                            bottom\n                        ],\n                        [\n                            refRect.right - 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n            }\n            function getPolygon(_ref2) {\n                let [x, y] = _ref2;\n                switch(side){\n                    case \"top\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"bottom\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"left\":\n                        {\n                            const cursorPointOne = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                ...commonPoints,\n                                cursorPointOne,\n                                cursorPointTwo\n                            ];\n                        }\n                    case \"right\":\n                        {\n                            const cursorPointOne = [\n                                x - buffer,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x - buffer,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                }\n            }\n            if (isPointInPolygon([\n                clientX,\n                clientY\n            ], rectPoly)) {\n                return;\n            }\n            if (hasLanded && !isOverReferenceRect) {\n                return close();\n            }\n            if (!isLeave && requireIntent) {\n                const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n                const cursorSpeedThreshold = 0.1;\n                if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n                    return close();\n                }\n            }\n            if (!isPointInPolygon([\n                clientX,\n                clientY\n            ], getPolygon([\n                x,\n                y\n            ]))) {\n                close();\n            } else if (!hasLanded && requireIntent) {\n                timeoutRef.current = window.setTimeout(close, 40);\n            }\n        };\n    };\n    fn.__options = {\n        blockPointerEvents\n    };\n    return fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDc3hCO0FBQzd2QjtBQUNrSDtBQUMvRztBQUNyQjtBQUM4RTtBQUM0RTtBQUNqSTtBQUUvRDs7O0NBR0MsR0FDRCxTQUFTaUYsYUFBYUMsSUFBSTtJQUN4QixNQUFNQyxhQUFhbkYseUNBQVksQ0FBQ3FGO0lBQ2hDLE1BQU1DLFlBQVl0Riw4Q0FBaUIsQ0FBQ3dGLENBQUFBO1FBQ2xDLE1BQU1DLFdBQVdQLEtBQUtRLEdBQUcsQ0FBQ0MsQ0FBQUE7WUFDeEIsSUFBSUEsT0FBTyxNQUFNO2dCQUNmO1lBQ0Y7WUFDQSxJQUFJLE9BQU9BLFFBQVEsWUFBWTtnQkFDN0IsTUFBTUMsY0FBY0Q7Z0JBQ3BCLE1BQU1FLGFBQWFELFlBQVlKO2dCQUMvQixPQUFPLE9BQU9LLGVBQWUsYUFBYUEsYUFBYTtvQkFDckRELFlBQVk7Z0JBQ2Q7WUFDRjtZQUNBRCxJQUFJRyxPQUFPLEdBQUdOO1lBQ2QsT0FBTztnQkFDTEcsSUFBSUcsT0FBTyxHQUFHO1lBQ2hCO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xMLFNBQVNNLE9BQU8sQ0FBQ0YsQ0FBQUEsYUFBY0EsY0FBYyxPQUFPLEtBQUssSUFBSUE7UUFDL0Q7SUFDQSx1REFBdUQ7SUFDekQsR0FBR1g7SUFDSCxPQUFPbEYsMENBQWEsQ0FBQztRQUNuQixJQUFJa0YsS0FBS2UsS0FBSyxDQUFDTixDQUFBQSxNQUFPQSxPQUFPLE9BQU87WUFDbEMsT0FBTztRQUNUO1FBQ0EsT0FBT08sQ0FBQUE7WUFDTCxJQUFJZixXQUFXVyxPQUFPLEVBQUU7Z0JBQ3RCWCxXQUFXVyxPQUFPO2dCQUNsQlgsV0FBV1csT0FBTyxHQUFHVDtZQUN2QjtZQUNBLElBQUlhLFNBQVMsTUFBTTtn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QUNxeUIsd0JBQXdCRyxtQkFBbUIxQixLQUFLN3dCLElBQUksR0FBRyt3QixTQUFTRixLQUFLM3dCLEtBQUssR0FBRzJ3QixLQUFLN3dCLElBQUksR0FBRyt3QjtvQ0FBUUYsS0FBSzV3QixNQUFNO2lDQUFDOzZCQUFDOzRCQUNsUCxPQUFPO2dDQUFDeXlCO2dDQUFnQkM7bUNBQW1CQzs2QkFBYTt3QkFDMUQ7Z0JBQ0o7WUFDRjtZQUNBLElBQUkxQyxpQkFBaUI7Z0JBQUN0cUI7Z0JBQVNDO2FBQVEsRUFBRTJzQixXQUFXO2dCQUNsRDtZQUNGO1lBQ0EsSUFBSXZCLGFBQWEsQ0FBQ29CLHFCQUFxQjtnQkFDckMsT0FBT3pwQjtZQUNUO1lBQ0EsSUFBSSxDQUFDbXBCLFdBQVdmLGVBQWU7Z0JBQzdCLE1BQU02QixjQUFjdEIsZUFBZXY0QixNQUFNNE0sT0FBTyxFQUFFNU0sTUFBTTZNLE9BQU87Z0JBQy9ELE1BQU1pdEIsdUJBQXVCO2dCQUM3QixJQUFJRCxnQkFBZ0IsUUFBUUEsY0FBY0Msc0JBQXNCO29CQUM5RCxPQUFPbHFCO2dCQUNUO1lBQ0Y7WUFDQSxJQUFJLENBQUNzbkIsaUJBQWlCO2dCQUFDdHFCO2dCQUFTQzthQUFRLEVBQUU0c0IsV0FBVztnQkFBQ3Z6QjtnQkFBR0M7YUFBRSxJQUFJO2dCQUM3RHlKO1lBQ0YsT0FBTyxJQUFJLENBQUNxb0IsYUFBYUQsZUFBZTtnQkFDdEMzdUIsV0FBVzVPLE9BQU8sR0FBR3VSLE9BQU9DLFVBQVUsQ0FBQzJELE9BQU87WUFDaEQ7UUFDRjtJQUNGO0lBQ0FzWixHQUFHemIsU0FBUyxHQUFHO1FBQ2JDO0lBQ0Y7SUFDQSxPQUFPd2I7QUFDVDtBQUVzbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZ3QtY2xpbmljLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0Lm1qcz82NmNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU1vZGVybkxheW91dEVmZmVjdCwgdXNlRWZmZWN0RXZlbnQsIGdldE1pbkxpc3RJbmRleCwgZ2V0TWF4TGlzdEluZGV4LCBjcmVhdGVHcmlkQ2VsbE1hcCwgaXNMaXN0SW5kZXhEaXNhYmxlZCwgZ2V0R3JpZE5hdmlnYXRlZEluZGV4LCBnZXRHcmlkQ2VsbEluZGV4T2ZDb3JuZXIsIGdldEdyaWRDZWxsSW5kaWNlcywgZmluZE5vbkRpc2FibGVkTGlzdEluZGV4LCBpc0luZGV4T3V0T2ZMaXN0Qm91bmRzLCB1c2VMYXRlc3RSZWYsIGdldERvY3VtZW50IGFzIGdldERvY3VtZW50JDEsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGNvbnRhaW5zIGFzIGNvbnRhaW5zJDEsIGlzU2FmYXJpLCBlbmFibGVGb2N1c0luc2lkZSwgaXNPdXRzaWRlRXZlbnQsIGdldFByZXZpb3VzVGFiYmFibGUsIGdldE5leHRUYWJiYWJsZSwgZGlzYWJsZUZvY3VzSW5zaWRlLCBpc1R5cGVhYmxlQ29tYm9ib3gsIGdldEZsb2F0aW5nRm9jdXNFbGVtZW50LCBnZXRUYWJiYWJsZU9wdGlvbnMsIGdldE5vZGVBbmNlc3RvcnMsIGFjdGl2ZUVsZW1lbnQsIGdldE5vZGVDaGlsZHJlbiBhcyBnZXROb2RlQ2hpbGRyZW4kMSwgc3RvcEV2ZW50LCBnZXRUYXJnZXQgYXMgZ2V0VGFyZ2V0JDEsIGlzVmlydHVhbENsaWNrLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIGdldFBsYXRmb3JtLCBpc1R5cGVhYmxlRWxlbWVudCwgaXNSZWFjdEV2ZW50LCBpc1Jvb3RFbGVtZW50LCBpc0V2ZW50VGFyZ2V0V2l0aGluLCBtYXRjaGVzRm9jdXNWaXNpYmxlLCBpc01hYywgZ2V0RGVlcGVzdE5vZGUsIGdldFVzZXJBZ2VudCB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC91dGlscyc7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNFbGVtZW50LCBpc1NoYWRvd1Jvb3QsIGdldE5vZGVOYW1lLCBpc0hUTUxFbGVtZW50LCBnZXRXaW5kb3csIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgZ2V0UGFyZW50Tm9kZSwgaXNXZWJLaXQgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmltcG9ydCB7IHRhYmJhYmxlLCBpc1RhYmJhYmxlLCBmb2N1c2FibGUgfSBmcm9tICd0YWJiYWJsZSc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIHVzZUZsb2F0aW5nIGFzIHVzZUZsb2F0aW5nJDEsIG9mZnNldCwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QtZG9tJztcbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC1kb20nO1xuaW1wb3J0IHsgZXZhbHVhdGUsIG1heCwgcm91bmQsIG1pbiB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIHJlZnMgaW50byBhIHNpbmdsZSBtZW1vaXplZCBjYWxsYmFjayByZWYgb3IgYG51bGxgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3JlYWN0LXV0aWxzI3VzZW1lcmdlcmVmc1xuICovXG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICBjb25zdCBjbGVhbnVwUmVmID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gIGNvbnN0IHJlZkVmZmVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKGluc3RhbmNlID0+IHtcbiAgICBjb25zdCBjbGVhbnVwcyA9IHJlZnMubWFwKHJlZiA9PiB7XG4gICAgICBpZiAocmVmID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcmVmQ2FsbGJhY2sgPSByZWY7XG4gICAgICAgIGNvbnN0IHJlZkNsZWFudXAgPSByZWZDYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmQ2xlYW51cCA9PT0gJ2Z1bmN0aW9uJyA/IHJlZkNsZWFudXAgOiAoKSA9PiB7XG4gICAgICAgICAgcmVmQ2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cHMuZm9yRWFjaChyZWZDbGVhbnVwID0+IHJlZkNsZWFudXAgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZkNsZWFudXAoKSk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIHJlZnMpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZnMuZXZlcnkocmVmID0+IHJlZiA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICBpZiAoY2xlYW51cFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCgpO1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSByZWZFZmZlY3QodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCByZWZzKTtcbn1cblxuZnVuY3Rpb24gc29ydEJ5RG9jdW1lbnRQb3NpdGlvbihhLCBiKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKTtcbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyB8fCBwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmNvbnN0IEZsb2F0aW5nTGlzdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHJlZ2lzdGVyOiAoKSA9PiB7fSxcbiAgdW5yZWdpc3RlcjogKCkgPT4ge30sXG4gIG1hcDogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZWxlbWVudHNSZWY6IHtcbiAgICBjdXJyZW50OiBbXVxuICB9XG59KTtcbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgYSBsaXN0IG9mIGl0ZW1zIHdpdGhpbiB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3RcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdMaXN0KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50c1JlZixcbiAgICBsYWJlbHNSZWZcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBTZXQoKSk7XG4gIGNvbnN0IHJlZ2lzdGVyID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgc2V0Tm9kZXMocHJldlNldCA9PiBuZXcgU2V0KHByZXZTZXQpLmFkZChub2RlKSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE5vZGVzKHByZXZTZXQgPT4ge1xuICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldChwcmV2U2V0KTtcbiAgICAgIHNldC5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm4gc2V0O1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IG1hcCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IG5ld01hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBzb3J0ZWROb2RlcyA9IEFycmF5LmZyb20obm9kZXMua2V5cygpKS5zb3J0KHNvcnRCeURvY3VtZW50UG9zaXRpb24pO1xuICAgIHNvcnRlZE5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBuZXdNYXAuc2V0KG5vZGUsIGluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3TWFwO1xuICB9LCBbbm9kZXNdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRmxvYXRpbmdMaXN0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICByZWdpc3RlcixcbiAgICAgIHVucmVnaXN0ZXIsXG4gICAgICBtYXAsXG4gICAgICBlbGVtZW50c1JlZixcbiAgICAgIGxhYmVsc1JlZlxuICAgIH0pLCBbcmVnaXN0ZXIsIHVucmVnaXN0ZXIsIG1hcCwgZWxlbWVudHNSZWYsIGxhYmVsc1JlZl0pLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbi8qKlxuICogVXNlZCB0byByZWdpc3RlciBhIGxpc3QgaXRlbSBhbmQgaXRzIGluZGV4IChET00gcG9zaXRpb24pIGluIHRoZVxuICogYEZsb2F0aW5nTGlzdGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdMaXN0I3VzZWxpc3RpdGVtXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3RJdGVtKHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgbGFiZWxcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgcmVnaXN0ZXIsXG4gICAgdW5yZWdpc3RlcixcbiAgICBtYXAsXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTGlzdENvbnRleHQpO1xuICBjb25zdCBbaW5kZXgsIHNldEluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBjb21wb25lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbXBvbmVudFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnRzUmVmLmN1cnJlbnRbaW5kZXhdID0gbm9kZTtcbiAgICAgIGlmIChsYWJlbHNSZWYpIHtcbiAgICAgICAgdmFyIF9ub2RlJHRleHRDb250ZW50O1xuICAgICAgICBjb25zdCBpc0xhYmVsRGVmaW5lZCA9IGxhYmVsICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGxhYmVsc1JlZi5jdXJyZW50W2luZGV4XSA9IGlzTGFiZWxEZWZpbmVkID8gbGFiZWwgOiAoX25vZGUkdGV4dENvbnRlbnQgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnRleHRDb250ZW50KSAhPSBudWxsID8gX25vZGUkdGV4dENvbnRlbnQgOiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2luZGV4LCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmLCBsYWJlbF0pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBjb21wb25lbnRSZWYuY3VycmVudDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmVnaXN0ZXIobm9kZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtyZWdpc3RlciwgdW5yZWdpc3Rlcl0pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50UmVmLmN1cnJlbnQgPyBtYXAuZ2V0KGNvbXBvbmVudFJlZi5jdXJyZW50KSA6IG51bGw7XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgIHNldEluZGV4KGluZGV4KTtcbiAgICB9XG4gIH0sIFttYXBdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWYsXG4gICAgaW5kZXg6IGluZGV4ID09IG51bGwgPyAtMSA6IGluZGV4XG4gIH0pLCBbaW5kZXgsIHJlZl0pO1xufVxuXG5jb25zdCBGT0NVU0FCTEVfQVRUUklCVVRFID0gJ2RhdGEtZmxvYXRpbmctdWktZm9jdXNhYmxlJztcbmNvbnN0IEFDVElWRV9LRVkgPSAnYWN0aXZlJztcbmNvbnN0IFNFTEVDVEVEX0tFWSA9ICdzZWxlY3RlZCc7XG5jb25zdCBBUlJPV19MRUZUID0gJ0Fycm93TGVmdCc7XG5jb25zdCBBUlJPV19SSUdIVCA9ICdBcnJvd1JpZ2h0JztcbmNvbnN0IEFSUk9XX1VQID0gJ0Fycm93VXAnO1xuY29uc3QgQVJST1dfRE9XTiA9ICdBcnJvd0Rvd24nO1xuXG5mdW5jdGlvbiByZW5kZXJKc3gocmVuZGVyLCBjb21wdXRlZFByb3BzKSB7XG4gIGlmICh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlbmRlcihjb21wdXRlZFByb3BzKTtcbiAgfVxuICBpZiAocmVuZGVyKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocmVuZGVyLCBjb21wdXRlZFByb3BzKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgLi4uY29tcHV0ZWRQcm9wc1xuICB9KTtcbn1cbmNvbnN0IENvbXBvc2l0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGFjdGl2ZUluZGV4OiAwLFxuICBvbk5hdmlnYXRlOiAoKSA9PiB7fVxufSk7XG5jb25zdCBob3Jpem9udGFsS2V5cyA9IFtBUlJPV19MRUZULCBBUlJPV19SSUdIVF07XG5jb25zdCB2ZXJ0aWNhbEtleXMgPSBbQVJST1dfVVAsIEFSUk9XX0RPV05dO1xuY29uc3QgYWxsS2V5cyA9IFsuLi5ob3Jpem9udGFsS2V5cywgLi4udmVydGljYWxLZXlzXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2luZ2xlIHRhYiBzdG9wIHdob3NlIGl0ZW1zIGFyZSBuYXZpZ2F0ZWQgYnkgYXJyb3cga2V5cywgd2hpY2hcbiAqIHByb3ZpZGVzIGxpc3QgbmF2aWdhdGlvbiBvdXRzaWRlIG9mIGZsb2F0aW5nIGVsZW1lbnQgY29udGV4dHMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgdG8gZW5hYmxlIG5hdmlnYXRpb24gb2YgYSBsaXN0IG9mIGl0ZW1zIHRoYXQgYXJlbuKAmXQgcGFydCBvZiBhXG4gKiBmbG9hdGluZyBlbGVtZW50LiBBIG1lbnViYXIgaXMgYW4gZXhhbXBsZSBvZiBhIGNvbXBvc2l0ZSwgd2l0aCBlYWNoIHJlZmVyZW5jZVxuICogZWxlbWVudCBiZWluZyBhbiBpdGVtLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0NvbXBvc2l0ZVxuICovXG5jb25zdCBDb21wb3NpdGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGUocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgcmVuZGVyLFxuICAgIG9yaWVudGF0aW9uID0gJ2JvdGgnLFxuICAgIGxvb3AgPSB0cnVlLFxuICAgIHJ0bCA9IGZhbHNlLFxuICAgIGNvbHMgPSAxLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBhY3RpdmVJbmRleDogZXh0ZXJuYWxBY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiBleHRlcm5hbFNldEFjdGl2ZUluZGV4LFxuICAgIGl0ZW1TaXplcyxcbiAgICBkZW5zZSA9IGZhbHNlLFxuICAgIC4uLmRvbVByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW2ludGVybmFsQWN0aXZlSW5kZXgsIGludGVybmFsU2V0QWN0aXZlSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gZXh0ZXJuYWxBY3RpdmVJbmRleCAhPSBudWxsID8gZXh0ZXJuYWxBY3RpdmVJbmRleCA6IGludGVybmFsQWN0aXZlSW5kZXg7XG4gIGNvbnN0IG9uTmF2aWdhdGUgPSB1c2VFZmZlY3RFdmVudChleHRlcm5hbFNldEFjdGl2ZUluZGV4ICE9IG51bGwgPyBleHRlcm5hbFNldEFjdGl2ZUluZGV4IDogaW50ZXJuYWxTZXRBY3RpdmVJbmRleCk7XG4gIGNvbnN0IGVsZW1lbnRzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudFByb3BzID0gcmVuZGVyICYmIHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicgPyByZW5kZXIucHJvcHMgOiB7fTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGVcbiAgfSksIFthY3RpdmVJbmRleCwgb25OYXZpZ2F0ZV0pO1xuICBjb25zdCBpc0dyaWQgPSBjb2xzID4gMTtcbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmICghYWxsS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSByZXR1cm47XG4gICAgbGV0IG5leHRJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IG1pbkluZGV4ID0gZ2V0TWluTGlzdEluZGV4KGVsZW1lbnRzUmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gZ2V0TWF4TGlzdEluZGV4KGVsZW1lbnRzUmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGNvbnN0IGhvcml6b250YWxFbmRLZXkgPSBydGwgPyBBUlJPV19MRUZUIDogQVJST1dfUklHSFQ7XG4gICAgY29uc3QgaG9yaXpvbnRhbFN0YXJ0S2V5ID0gcnRsID8gQVJST1dfUklHSFQgOiBBUlJPV19MRUZUO1xuICAgIGlmIChpc0dyaWQpIHtcbiAgICAgIGNvbnN0IHNpemVzID0gaXRlbVNpemVzIHx8IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IGVsZW1lbnRzUmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICB9LCAoKSA9PiAoe1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxXG4gICAgICB9KSk7XG4gICAgICAvLyBUbyBjYWxjdWxhdGUgbW92ZW1lbnRzIG9uIHRoZSBncmlkLCB3ZSB1c2UgaHlwb3RoZXRpY2FsIGNlbGwgaW5kaWNlc1xuICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICBjb25zdCBjZWxsTWFwID0gY3JlYXRlR3JpZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKTtcbiAgICAgIGNvbnN0IG1pbkdyaWRJbmRleCA9IGNlbGxNYXAuZmluZEluZGV4KGluZGV4ID0+IGluZGV4ICE9IG51bGwgJiYgIWlzTGlzdEluZGV4RGlzYWJsZWQoZWxlbWVudHNSZWYsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpKTtcbiAgICAgIC8vIGxhc3QgZW5hYmxlZCBpbmRleFxuICAgICAgY29uc3QgbWF4R3JpZEluZGV4ID0gY2VsbE1hcC5yZWR1Y2UoKGZvdW5kSW5kZXgsIGluZGV4LCBjZWxsSW5kZXgpID0+IGluZGV4ICE9IG51bGwgJiYgIWlzTGlzdEluZGV4RGlzYWJsZWQoZWxlbWVudHNSZWYsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpID8gY2VsbEluZGV4IDogZm91bmRJbmRleCwgLTEpO1xuICAgICAgY29uc3QgbWF5YmVOZXh0SW5kZXggPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgIGN1cnJlbnQ6IGNlbGxNYXAubWFwKGl0ZW1JbmRleCA9PiBpdGVtSW5kZXggPyBlbGVtZW50c1JlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgfSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGxvb3AsXG4gICAgICAgIHJ0bCxcbiAgICAgICAgY29scyxcbiAgICAgICAgLy8gdHJlYXQgdW5kZWZpbmVkIChlbXB0eSBncmlkIHNwYWNlcykgYXMgZGlzYWJsZWQgaW5kaWNlcyBzbyB3ZVxuICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICBkaXNhYmxlZEluZGljZXM6IGdldEdyaWRDZWxsSW5kaWNlcyhbLi4uKCh0eXBlb2YgZGlzYWJsZWRJbmRpY2VzICE9PSAnZnVuY3Rpb24nID8gZGlzYWJsZWRJbmRpY2VzIDogbnVsbCkgfHwgZWxlbWVudHNSZWYuY3VycmVudC5tYXAoKF8sIGluZGV4KSA9PiBpc0xpc3RJbmRleERpc2FibGVkKGVsZW1lbnRzUmVmLCBpbmRleCwgZGlzYWJsZWRJbmRpY2VzKSA/IGluZGV4IDogdW5kZWZpbmVkKSksIHVuZGVmaW5lZF0sIGNlbGxNYXApLFxuICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICBtYXhJbmRleDogbWF4R3JpZEluZGV4LFxuICAgICAgICBwcmV2SW5kZXg6IGdldEdyaWRDZWxsSW5kZXhPZkNvcm5lcihhY3RpdmVJbmRleCA+IG1heEluZGV4ID8gbWluSW5kZXggOiBhY3RpdmVJbmRleCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsXG4gICAgICAgIC8vIHVzZSBhIGNvcm5lciBtYXRjaGluZyB0aGUgZWRnZSBjbG9zZXN0IHRvIHRoZSBkaXJlY3Rpb24gd2UncmVcbiAgICAgICAgLy8gbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgLy8gdG9wL2xlZnQgb3ZlciBib3R0b20vcmlnaHQuXG4gICAgICAgIGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTiA/ICdibCcgOiBldmVudC5rZXkgPT09IGhvcml6b250YWxFbmRLZXkgPyAndHInIDogJ3RsJylcbiAgICAgIH0pXTtcbiAgICAgIGlmIChtYXliZU5leHRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG1heWJlTmV4dEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0b0VuZEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbaG9yaXpvbnRhbEVuZEtleV0sXG4gICAgICB2ZXJ0aWNhbDogW0FSUk9XX0RPV05dLFxuICAgICAgYm90aDogW2hvcml6b250YWxFbmRLZXksIEFSUk9XX0RPV05dXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgY29uc3QgdG9TdGFydEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbaG9yaXpvbnRhbFN0YXJ0S2V5XSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfVVBdLFxuICAgICAgYm90aDogW2hvcml6b250YWxTdGFydEtleSwgQVJST1dfVVBdXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgY29uc3QgcHJldmVudGVkS2V5cyA9IGlzR3JpZCA/IGFsbEtleXMgOiB7XG4gICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsS2V5cyxcbiAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEtleXMsXG4gICAgICBib3RoOiBhbGxLZXlzXG4gICAgfVtvcmllbnRhdGlvbl07XG4gICAgaWYgKG5leHRJbmRleCA9PT0gYWN0aXZlSW5kZXggJiYgWy4uLnRvRW5kS2V5cywgLi4udG9TdGFydEtleXNdLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgIGlmIChsb29wICYmIG5leHRJbmRleCA9PT0gbWF4SW5kZXggJiYgdG9FbmRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gbWluSW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGxvb3AgJiYgbmV4dEluZGV4ID09PSBtaW5JbmRleCAmJiB0b1N0YXJ0S2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG1heEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgIGRlY3JlbWVudDogdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXh0SW5kZXggIT09IGFjdGl2ZUluZGV4ICYmICFpc0luZGV4T3V0T2ZMaXN0Qm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICB2YXIgX2VsZW1lbnRzUmVmJGN1cnJlbnQkO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAocHJldmVudGVkS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBvbk5hdmlnYXRlKG5leHRJbmRleCk7XG4gICAgICAoX2VsZW1lbnRzUmVmJGN1cnJlbnQkID0gZWxlbWVudHNSZWYuY3VycmVudFtuZXh0SW5kZXhdKSA9PSBudWxsIHx8IF9lbGVtZW50c1JlZiRjdXJyZW50JC5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLmRvbVByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IG9yaWVudGF0aW9uID09PSAnYm90aCcgPyB1bmRlZmluZWQgOiBvcmllbnRhdGlvbixcbiAgICBvbktleURvd24oZSkge1xuICAgICAgZG9tUHJvcHMub25LZXlEb3duID09IG51bGwgfHwgZG9tUHJvcHMub25LZXlEb3duKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uS2V5RG93biA9PSBudWxsIHx8IHJlbmRlckVsZW1lbnRQcm9wcy5vbktleURvd24oZSk7XG4gICAgICBoYW5kbGVLZXlEb3duKGUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goQ29tcG9zaXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goRmxvYXRpbmdMaXN0LCB7XG4gICAgICBlbGVtZW50c1JlZjogZWxlbWVudHNSZWYsXG4gICAgICBjaGlsZHJlbjogcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcylcbiAgICB9KVxuICB9KTtcbn0pO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvQ29tcG9zaXRlXG4gKi9cbmNvbnN0IENvbXBvc2l0ZUl0ZW0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGVJdGVtKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgY29uc3Qge1xuICAgIHJlbmRlcixcbiAgICAuLi5kb21Qcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbXBvc2l0ZUNvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcmVmLFxuICAgIGluZGV4XG4gIH0gPSB1c2VMaXN0SXRlbSgpO1xuICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgZm9yd2FyZGVkUmVmLCByZW5kZXJFbGVtZW50UHJvcHMucmVmXSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gYWN0aXZlSW5kZXggPT09IGluZGV4O1xuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLmRvbVByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IG1lcmdlZFJlZixcbiAgICB0YWJJbmRleDogaXNBY3RpdmUgPyAwIDogLTEsXG4gICAgJ2RhdGEtYWN0aXZlJzogaXNBY3RpdmUgPyAnJyA6IHVuZGVmaW5lZCxcbiAgICBvbkZvY3VzKGUpIHtcbiAgICAgIGRvbVByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCBkb21Qcm9wcy5vbkZvY3VzKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25Gb2N1cyhlKTtcbiAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWkvbWF0ZXJpYWwtdWkvaXNzdWVzLzQxMTkwI2lzc3VlY29tbWVudC0yMDQwODczMzc5XG5jb25zdCBTYWZlUmVhY3QgPSB7XG4gIC4uLlJlYWN0XG59O1xuXG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG5sZXQgY291bnQgPSAwO1xuY29uc3QgZ2VuSWQgPSAoKSA9PiAvLyBFbnN1cmUgdGhlIGlkIGlzIHVuaXF1ZSB3aXRoIG11bHRpcGxlIGluZGVwZW5kZW50IHZlcnNpb25zIG9mIEZsb2F0aW5nIFVJXG4vLyBvbiA8UmVhY3QgMThcblwiZmxvYXRpbmctdWktXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCA2KSArIGNvdW50Kys7XG5mdW5jdGlvbiB1c2VGbG9hdGluZ0lkKCkge1xuICBjb25zdCBbaWQsIHNldElkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHNlcnZlckhhbmRvZmZDb21wbGV0ZSA/IGdlbklkKCkgOiB1bmRlZmluZWQpO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICBzZXRJZChnZW5JZCgpKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gdHJ1ZTtcbiAgfSwgW10pO1xuICByZXR1cm4gaWQ7XG59XG5jb25zdCB1c2VSZWFjdElkID0gU2FmZVJlYWN0LnVzZUlkO1xuXG4vKipcbiAqIFVzZXMgUmVhY3QgMTgncyBidWlsdC1pbiBgdXNlSWQoKWAgd2hlbiBhdmFpbGFibGUsIG9yIGZhbGxzIGJhY2sgdG8gYVxuICogc2xpZ2h0bHkgbGVzcyBwZXJmb3JtYW50IChyZXF1aXJpbmcgYSBkb3VibGUgcmVuZGVyKSBpbXBsZW1lbnRhdGlvbiBmb3JcbiAqIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvcmVhY3QtdXRpbHMjdXNlaWRcbiAqL1xuY29uc3QgdXNlSWQgPSB1c2VSZWFjdElkIHx8IHVzZUZsb2F0aW5nSWQ7XG5cbmxldCBkZXZNZXNzYWdlU2V0O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBkZXZNZXNzYWdlU2V0ID0gLyojX19QVVJFX18qL25ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gIHZhciBfZGV2TWVzc2FnZVNldDtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1lc3NhZ2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBcIkZsb2F0aW5nIFVJOiBcIiArIG1lc3NhZ2VzLmpvaW4oJyAnKTtcbiAgaWYgKCEoKF9kZXZNZXNzYWdlU2V0ID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldC5oYXMobWVzc2FnZSkpKSB7XG4gICAgdmFyIF9kZXZNZXNzYWdlU2V0MjtcbiAgICAoX2Rldk1lc3NhZ2VTZXQyID0gZGV2TWVzc2FnZVNldCkgPT0gbnVsbCB8fCBfZGV2TWVzc2FnZVNldDIuYWRkKG1lc3NhZ2UpO1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gIHZhciBfZGV2TWVzc2FnZVNldDM7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBtZXNzYWdlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBcIkZsb2F0aW5nIFVJOiBcIiArIG1lc3NhZ2VzLmpvaW4oJyAnKTtcbiAgaWYgKCEoKF9kZXZNZXNzYWdlU2V0MyA9IGRldk1lc3NhZ2VTZXQpICE9IG51bGwgJiYgX2Rldk1lc3NhZ2VTZXQzLmhhcyhtZXNzYWdlKSkpIHtcbiAgICB2YXIgX2Rldk1lc3NhZ2VTZXQ0O1xuICAgIChfZGV2TWVzc2FnZVNldDQgPSBkZXZNZXNzYWdlU2V0KSA9PSBudWxsIHx8IF9kZXZNZXNzYWdlU2V0NC5hZGQobWVzc2FnZSk7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBwb2ludGluZyBhcnJvdyB0cmlhbmdsZS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0Fycm93XG4gKi9cbmNvbnN0IEZsb2F0aW5nQXJyb3cgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGbG9hdGluZ0Fycm93KHByb3BzLCByZWYpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9LFxuICAgICAgbWlkZGxld2FyZURhdGE6IHtcbiAgICAgICAgYXJyb3csXG4gICAgICAgIHNoaWZ0XG4gICAgICB9XG4gICAgfSxcbiAgICB3aWR0aCA9IDE0LFxuICAgIGhlaWdodCA9IDcsXG4gICAgdGlwUmFkaXVzID0gMCxcbiAgICBzdHJva2VXaWR0aCA9IDAsXG4gICAgc3RhdGljT2Zmc2V0LFxuICAgIHN0cm9rZSxcbiAgICBkLFxuICAgIHN0eWxlOiB7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICAuLi5yZXN0U3R5bGVcbiAgICB9ID0ge30sXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIXJlZikge1xuICAgICAgd2FybignVGhlIGByZWZgIHByb3AgaXMgcmVxdWlyZWQgZm9yIGBGbG9hdGluZ0Fycm93YC4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2xpcFBhdGhJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IFtpc1JUTCwgc2V0SXNSVExdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjkzMlxuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZmxvYXRpbmcpIHJldHVybjtcbiAgICBjb25zdCBpc1JUTCA9IGdldENvbXB1dGVkU3R5bGUoZmxvYXRpbmcpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgaWYgKGlzUlRMKSB7XG4gICAgICBzZXRJc1JUTCh0cnVlKTtcbiAgICB9XG4gIH0sIFtmbG9hdGluZ10pO1xuICBpZiAoIWZsb2F0aW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgW3NpZGUsIGFsaWdubWVudF0gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKTtcbiAgY29uc3QgaXNWZXJ0aWNhbFNpZGUgPSBzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJztcbiAgbGV0IGNvbXB1dGVkU3RhdGljT2Zmc2V0ID0gc3RhdGljT2Zmc2V0O1xuICBpZiAoaXNWZXJ0aWNhbFNpZGUgJiYgc2hpZnQgIT0gbnVsbCAmJiBzaGlmdC54IHx8ICFpc1ZlcnRpY2FsU2lkZSAmJiBzaGlmdCAhPSBudWxsICYmIHNoaWZ0LnkpIHtcbiAgICBjb21wdXRlZFN0YXRpY09mZnNldCA9IG51bGw7XG4gIH1cblxuICAvLyBTdHJva2VzIG11c3QgYmUgZG91YmxlIHRoZSBib3JkZXIgd2lkdGgsIHRoaXMgZW5zdXJlcyB0aGUgc3Ryb2tlJ3Mgd2lkdGhcbiAgLy8gd29ya3MgYXMgeW91J2QgZXhwZWN0LlxuICBjb25zdCBjb21wdXRlZFN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggKiAyO1xuICBjb25zdCBoYWxmU3Ryb2tlV2lkdGggPSBjb21wdXRlZFN0cm9rZVdpZHRoIC8gMjtcbiAgY29uc3Qgc3ZnWCA9IHdpZHRoIC8gMiAqICh0aXBSYWRpdXMgLyAtOCArIDEpO1xuICBjb25zdCBzdmdZID0gaGVpZ2h0IC8gMiAqIHRpcFJhZGl1cyAvIDQ7XG4gIGNvbnN0IGlzQ3VzdG9tU2hhcGUgPSAhIWQ7XG4gIGNvbnN0IHlPZmZzZXRQcm9wID0gY29tcHV0ZWRTdGF0aWNPZmZzZXQgJiYgYWxpZ25tZW50ID09PSAnZW5kJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGxldCB4T2Zmc2V0UHJvcCA9IGNvbXB1dGVkU3RhdGljT2Zmc2V0ICYmIGFsaWdubWVudCA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICBpZiAoY29tcHV0ZWRTdGF0aWNPZmZzZXQgJiYgaXNSVEwpIHtcbiAgICB4T2Zmc2V0UHJvcCA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9XG4gIGNvbnN0IGFycm93WCA9IChhcnJvdyA9PSBudWxsID8gdm9pZCAwIDogYXJyb3cueCkgIT0gbnVsbCA/IGNvbXB1dGVkU3RhdGljT2Zmc2V0IHx8IGFycm93LnggOiAnJztcbiAgY29uc3QgYXJyb3dZID0gKGFycm93ID09IG51bGwgPyB2b2lkIDAgOiBhcnJvdy55KSAhPSBudWxsID8gY29tcHV0ZWRTdGF0aWNPZmZzZXQgfHwgYXJyb3cueSA6ICcnO1xuICBjb25zdCBkVmFsdWUgPSBkIHx8ICdNMCwwJyArIChcIiBIXCIgKyB3aWR0aCkgKyAoXCIgTFwiICsgKHdpZHRoIC0gc3ZnWCkgKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAoXCIgUVwiICsgd2lkdGggLyAyICsgXCIsXCIgKyBoZWlnaHQgKyBcIiBcIiArIHN2Z1ggKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAnIFonO1xuICBjb25zdCByb3RhdGlvbiA9IHtcbiAgICB0b3A6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKDE4MGRlZyknIDogJycsXG4gICAgbGVmdDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoOTBkZWcpJyA6ICdyb3RhdGUoLTkwZGVnKScsXG4gICAgYm90dG9tOiBpc0N1c3RvbVNoYXBlID8gJycgOiAncm90YXRlKDE4MGRlZyknLFxuICAgIHJpZ2h0OiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSgtOTBkZWcpJyA6ICdyb3RhdGUoOTBkZWcpJ1xuICB9W3NpZGVdO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeHMoXCJzdmdcIiwge1xuICAgIC4uLnJlc3QsXG4gICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgIHJlZjogcmVmLFxuICAgIHdpZHRoOiBpc0N1c3RvbVNoYXBlID8gd2lkdGggOiB3aWR0aCArIGNvbXB1dGVkU3Ryb2tlV2lkdGgsXG4gICAgaGVpZ2h0OiB3aWR0aCxcbiAgICB2aWV3Qm94OiBcIjAgMCBcIiArIHdpZHRoICsgXCIgXCIgKyAoaGVpZ2h0ID4gd2lkdGggPyBoZWlnaHQgOiB3aWR0aCksXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgW3hPZmZzZXRQcm9wXTogYXJyb3dYLFxuICAgICAgW3lPZmZzZXRQcm9wXTogYXJyb3dZLFxuICAgICAgW3NpZGVdOiBpc1ZlcnRpY2FsU2lkZSB8fCBpc0N1c3RvbVNoYXBlID8gJzEwMCUnIDogXCJjYWxjKDEwMCUgLSBcIiArIGNvbXB1dGVkU3Ryb2tlV2lkdGggLyAyICsgXCJweClcIixcbiAgICAgIHRyYW5zZm9ybTogW3JvdGF0aW9uLCB0cmFuc2Zvcm1dLmZpbHRlcih0ID0+ICEhdCkuam9pbignICcpLFxuICAgICAgLi4ucmVzdFN0eWxlXG4gICAgfSxcbiAgICBjaGlsZHJlbjogW2NvbXB1dGVkU3Ryb2tlV2lkdGggPiAwICYmIC8qI19fUFVSRV9fKi9qc3goXCJwYXRoXCIsIHtcbiAgICAgIGNsaXBQYXRoOiBcInVybCgjXCIgKyBjbGlwUGF0aElkICsgXCIpXCIsXG4gICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgIHN0cm9rZTogc3Ryb2tlXG4gICAgICAvLyBBY2NvdW50IGZvciB0aGUgc3Ryb2tlIG9uIHRoZSBmaWxsIHBhdGggcmVuZGVyZWQgYmVsb3cuXG4gICAgICAsXG4gICAgICBzdHJva2VXaWR0aDogY29tcHV0ZWRTdHJva2VXaWR0aCArIChkID8gMCA6IDEpLFxuICAgICAgZDogZFZhbHVlXG4gICAgfSksIC8qI19fUFVSRV9fKi9qc3goXCJwYXRoXCIsIHtcbiAgICAgIHN0cm9rZTogY29tcHV0ZWRTdHJva2VXaWR0aCAmJiAhZCA/IHJlc3QuZmlsbCA6ICdub25lJyxcbiAgICAgIGQ6IGRWYWx1ZVxuICAgIH0pLCAvKiNfX1BVUkVfXyovanN4KFwiY2xpcFBhdGhcIiwge1xuICAgICAgaWQ6IGNsaXBQYXRoSWQsXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcInJlY3RcIiwge1xuICAgICAgICB4OiAtaGFsZlN0cm9rZVdpZHRoLFxuICAgICAgICB5OiBoYWxmU3Ryb2tlV2lkdGggKiAoaXNDdXN0b21TaGFwZSA/IC0xIDogMSksXG4gICAgICAgIHdpZHRoOiB3aWR0aCArIGNvbXB1dGVkU3Ryb2tlV2lkdGgsXG4gICAgICAgIGhlaWdodDogd2lkdGhcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlcigpIHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9tYXAkZ2V0LmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZGF0YSkpO1xuICAgIH0sXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAoIW1hcC5oYXMoZXZlbnQpKSB7XG4gICAgICAgIG1hcC5zZXQoZXZlbnQsIG5ldyBTZXQoKSk7XG4gICAgICB9XG4gICAgICBtYXAuZ2V0KGV2ZW50KS5hZGQobGlzdGVuZXIpO1xuICAgIH0sXG4gICAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgIChfbWFwJGdldDIgPSBtYXAuZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfbWFwJGdldDIuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IEZsb2F0aW5nTm9kZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IEZsb2F0aW5nVHJlZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnQgbm9kZSBpZCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLCBpZiBhdmFpbGFibGUuXG4gKiBSZXR1cm5zIGBudWxsYCBmb3IgdG9wLWxldmVsIGZsb2F0aW5nIGVsZW1lbnRzLlxuICovXG5jb25zdCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCA9ICgpID0+IHtcbiAgdmFyIF9SZWFjdCR1c2VDb250ZXh0O1xuICByZXR1cm4gKChfUmVhY3QkdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdOb2RlQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfUmVhY3QkdXNlQ29udGV4dC5pZCkgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVhcmVzdCBmbG9hdGluZyB0cmVlIGNvbnRleHQsIGlmIGF2YWlsYWJsZS5cbiAqL1xuY29uc3QgdXNlRmxvYXRpbmdUcmVlID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ1RyZWVDb250ZXh0KTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBub2RlIGludG8gdGhlIGBGbG9hdGluZ1RyZWVgLCByZXR1cm5pbmcgaXRzIGlkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZ05vZGVJZChjdXN0b21QYXJlbnRJZCkge1xuICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcmVhY3RQYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHBhcmVudElkID0gY3VzdG9tUGFyZW50SWQgfHwgcmVhY3RQYXJlbnRJZDtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlkKSByZXR1cm47XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9O1xuICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmFkZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLnJlbW92ZU5vZGUobm9kZSk7XG4gICAgfTtcbiAgfSwgW3RyZWUsIGlkLCBwYXJlbnRJZF0pO1xuICByZXR1cm4gaWQ7XG59XG4vKipcbiAqIFByb3ZpZGVzIHBhcmVudCBub2RlIGNvbnRleHQgZm9yIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1RyZWVcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdOb2RlKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRmxvYXRpbmdOb2RlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBpZCxcbiAgICAgIHBhcmVudElkXG4gICAgfSksIFtpZCwgcGFyZW50SWRdKSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cyB3aGVuIHRoZXkgYXJlIG5vdCBjaGlsZHJlbiBvZlxuICogZWFjaCBvdGhlciBvbiB0aGUgRE9NLlxuICogVGhpcyBpcyBub3QgbmVjZXNzYXJ5IGluIGFsbCBjYXNlcywgZXhjZXB0IHdoZW4gdGhlcmUgbXVzdCBiZSBleHBsaWNpdCBjb21tdW5pY2F0aW9uIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCBmbG9hdGluZyBlbGVtZW50cy4gSXQgaXMgbmVjZXNzYXJ5IGZvcjpcbiAqIC0gVGhlIGBidWJibGVzYCBvcHRpb24gaW4gdGhlIGB1c2VEaXNtaXNzKClgIEhvb2tcbiAqIC0gTmVzdGVkIHZpcnR1YWwgbGlzdCBuYXZpZ2F0aW9uXG4gKiAtIE5lc3RlZCBmbG9hdGluZyBlbGVtZW50cyB0aGF0IGVhY2ggb3BlbiBvbiBob3ZlclxuICogLSBDdXN0b20gY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQgZmxvYXRpbmcgZWxlbWVudHNcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1RyZWVcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdUcmVlKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG5vZGVzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgYWRkTm9kZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBbLi4ubm9kZXNSZWYuY3VycmVudCwgbm9kZV07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVtb3ZlTm9kZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIG5vZGVzUmVmLmN1cnJlbnQgPSBub2Rlc1JlZi5jdXJyZW50LmZpbHRlcihuID0+IG4gIT09IG5vZGUpO1xuICB9LCBbXSk7XG4gIGNvbnN0IFtldmVudHNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlRXZlbnRFbWl0dGVyKCkpO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGbG9hdGluZ1RyZWVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIG5vZGVzUmVmLFxuICAgICAgYWRkTm9kZSxcbiAgICAgIHJlbW92ZU5vZGUsXG4gICAgICBldmVudHNcbiAgICB9KSwgW2FkZE5vZGUsIHJlbW92ZU5vZGUsIGV2ZW50c10pLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlKG5hbWUpIHtcbiAgcmV0dXJuIFwiZGF0YS1mbG9hdGluZy11aS1cIiArIG5hbWU7XG59XG5cbmZ1bmN0aW9uIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRSZWYpIHtcbiAgaWYgKHRpbWVvdXRSZWYuY3VycmVudCAhPT0gLTEpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSAtMTtcbiAgfVxufVxuXG5jb25zdCBzYWZlUG9seWdvbklkZW50aWZpZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdzYWZlLXBvbHlnb24nKTtcbmZ1bmN0aW9uIGdldERlbGF5KHZhbHVlLCBwcm9wLCBwb2ludGVyVHlwZSkge1xuICBpZiAocG9pbnRlclR5cGUgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiByZXN1bHRbcHJvcF07XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZVtwcm9wXTtcbn1cbmZ1bmN0aW9uIGdldFJlc3RNcyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBPcGVucyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGlsZSBob3ZlcmluZyBvdmVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgbGlrZVxuICogQ1NTIGA6aG92ZXJgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUhvdmVyXG4gKi9cbmZ1bmN0aW9uIHVzZUhvdmVyKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZGF0YVJlZixcbiAgICBldmVudHMsXG4gICAgZWxlbWVudHNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBkZWxheSA9IDAsXG4gICAgaGFuZGxlQ2xvc2UgPSBudWxsLFxuICAgIG1vdXNlT25seSA9IGZhbHNlLFxuICAgIHJlc3RNcyA9IDAsXG4gICAgbW92ZSA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgaGFuZGxlQ2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYoaGFuZGxlQ2xvc2UpO1xuICBjb25zdCBkZWxheVJlZiA9IHVzZUxhdGVzdFJlZihkZWxheSk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3Blbik7XG4gIGNvbnN0IHJlc3RNc1JlZiA9IHVzZUxhdGVzdFJlZihyZXN0TXMpO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3QgaGFuZGxlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCByZXN0VGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigtMSk7XG4gIGNvbnN0IGJsb2NrTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB1bmJpbmRNb3VzZU1vdmVSZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge30pO1xuICBjb25zdCByZXN0VGltZW91dFBlbmRpbmdSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc0hvdmVyT3BlbiA9IHVzZUVmZmVjdEV2ZW50KCgpID0+IHtcbiAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRvcGVuO1xuICAgIGNvbnN0IHR5cGUgPSAoX2RhdGFSZWYkY3VycmVudCRvcGVuID0gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUmVmJGN1cnJlbnQkb3Blbi50eXBlO1xuICAgIHJldHVybiAodHlwZSA9PSBudWxsID8gdm9pZCAwIDogdHlwZS5pbmNsdWRlcygnbW91c2UnKSkgJiYgdHlwZSAhPT0gJ21vdXNlZG93bic7XG4gIH0pO1xuXG4gIC8vIFdoZW4gY2xvc2luZyBiZWZvcmUgb3BlbmluZywgY2xlYXIgdGhlIGRlbGF5IHRpbWVvdXRzIHRvIGNhbmNlbCBpdFxuICAvLyBmcm9tIHNob3dpbmcuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIG9wZW5cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRSZWYpO1xuICAgICAgICBjbGVhclRpbWVvdXRJZlNldChyZXN0VGltZW91dFJlZik7XG4gICAgICAgIGJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXN0VGltZW91dFBlbmRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKCFoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgaWYgKCFvcGVuKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25MZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzSG92ZXJPcGVuKCkpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ2hvdmVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudCQxKGVsZW1lbnRzLmZsb2F0aW5nKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGh0bWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTGVhdmUpO1xuICAgIH07XG4gIH0sIFtlbGVtZW50cy5mbG9hdGluZywgb3Blbiwgb25PcGVuQ2hhbmdlLCBlbmFibGVkLCBoYW5kbGVDbG9zZVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgY29uc3QgY2xvc2VXaXRoRGVsYXkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQsIHJ1bkVsc2VCcmFuY2gsIHJlYXNvbikge1xuICAgIGlmIChydW5FbHNlQnJhbmNoID09PSB2b2lkIDApIHtcbiAgICAgIHJ1bkVsc2VCcmFuY2ggPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhc29uID09PSB2b2lkIDApIHtcbiAgICAgIHJlYXNvbiA9ICdob3Zlcic7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnY2xvc2UnLCBwb2ludGVyVHlwZVJlZi5jdXJyZW50KTtcbiAgICBpZiAoY2xvc2VEZWxheSAmJiAhaGFuZGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0UmVmKTtcbiAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsIHJlYXNvbiksIGNsb3NlRGVsYXkpO1xuICAgIH0gZWxzZSBpZiAocnVuRWxzZUJyYW5jaCkge1xuICAgICAgY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dFJlZik7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCByZWFzb24pO1xuICAgIH1cbiAgfSwgW2RlbGF5UmVmLCBvbk9wZW5DaGFuZ2VdKTtcbiAgY29uc3QgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQoKTtcbiAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gIH0pO1xuICBjb25zdCBjbGVhclBvaW50ZXJFdmVudHMgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgaWYgKHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQkMShlbGVtZW50cy5mbG9hdGluZykuYm9keTtcbiAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgYm9keS5yZW1vdmVBdHRyaWJ1dGUoc2FmZVBvbHlnb25JZGVudGlmaWVyKTtcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaXNDbGlja0xpa2VPcGVuRXZlbnQgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgcmV0dXJuIGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPyBbJ2NsaWNrJywgJ21vdXNlZG93biddLmluY2x1ZGVzKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSkgOiBmYWxzZTtcbiAgfSk7XG5cbiAgLy8gUmVnaXN0ZXJpbmcgdGhlIG1vdXNlIGV2ZW50cyBvbiB0aGUgcmVmZXJlbmNlIGRpcmVjdGx5IHRvIGJ5cGFzcyBSZWFjdCdzXG4gIC8vIGRlbGVnYXRpb24gc3lzdGVtLiBJZiB0aGUgY3Vyc29yIHdhcyBvbiBhIGRpc2FibGVkIGVsZW1lbnQgYW5kIHRoZW4gZW50ZXJlZFxuICAvLyB0aGUgcmVmZXJlbmNlIChubyBnYXApLCBgbW91c2VlbnRlcmAgZG9lc24ndCBmaXJlIGluIHRoZSBkZWxlZ2F0aW9uIHN5c3RlbS5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBvblJlZmVyZW5jZU1vdXNlRW50ZXIoZXZlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRSZWYpO1xuICAgICAgYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaWYgKG1vdXNlT25seSAmJiAhaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB8fCBnZXRSZXN0TXMocmVzdE1zUmVmLmN1cnJlbnQpID4gMCAmJiAhZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnb3BlbicsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKG9wZW5EZWxheSkge1xuICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCFvcGVuUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudCwgJ2hvdmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvcGVuRGVsYXkpO1xuICAgICAgfSBlbHNlIGlmICghb3Blbikge1xuICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblJlZmVyZW5jZU1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSB7XG4gICAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQkMShlbGVtZW50cy5mbG9hdGluZyk7XG4gICAgICBjbGVhclRpbWVvdXRJZlNldChyZXN0VGltZW91dFJlZik7XG4gICAgICByZXN0VGltZW91dFBlbmRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaWYgKGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQgJiYgZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCkge1xuICAgICAgICAvLyBQcmV2ZW50IGNsZWFyaW5nIGBvblNjcm9sbE1vdXNlTGVhdmVgIHRpbWVvdXQuXG4gICAgICAgIGlmICghb3Blbikge1xuICAgICAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXJSZWYuY3VycmVudCA9IGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQoe1xuICAgICAgICAgIC4uLmRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQsXG4gICAgICAgICAgdHJlZSxcbiAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgb25DbG9zZSgpIHtcbiAgICAgICAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgICAgICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgICAgICAgIGlmICghaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCwgdHJ1ZSwgJ3NhZmUtcG9seWdvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IGludGVyYWN0aXZpdHkgd2l0aG91dCBgc2FmZVBvbHlnb25gIG9uIHRvdWNoIGRldmljZXMuIFdpdGggYVxuICAgICAgLy8gcG9pbnRlciwgYSBzaG9ydCBjbG9zZSBkZWxheSBpcyBhbiBhbHRlcm5hdGl2ZSwgc28gaXQgc2hvdWxkIHdvcmtcbiAgICAgIC8vIGNvbnNpc3RlbnRseS5cbiAgICAgIGNvbnN0IHNob3VsZENsb3NlID0gcG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gJ3RvdWNoJyA/ICFjb250YWlucyQxKGVsZW1lbnRzLmZsb2F0aW5nLCBldmVudC5yZWxhdGVkVGFyZ2V0KSA6IHRydWU7XG4gICAgICBpZiAoc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBjbG9zZXMgYWZ0ZXIgc2Nyb2xsaW5nIGV2ZW4gaWYgdGhlIHBvaW50ZXJcbiAgICAvLyBkaWQgbm90IG1vdmUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2Rpc2N1c3Npb25zLzE2OTJcbiAgICBmdW5jdGlvbiBvblNjcm9sbE1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSByZXR1cm47XG4gICAgICBpZiAoIWRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpIHJldHVybjtcbiAgICAgIGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQgPT0gbnVsbCB8fCBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KHtcbiAgICAgICAgLi4uZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgb25DbG9zZSgpIHtcbiAgICAgICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgIGlmICghaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkoZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZsb2F0aW5nTW91c2VFbnRlcigpIHtcbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRSZWYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZsb2F0aW5nTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKCFpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSB7XG4gICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlKSkge1xuICAgICAgY29uc3QgcmVmZXJlbmNlID0gZWxlbWVudHMuZG9tUmVmZXJlbmNlO1xuICAgICAgY29uc3QgZmxvYXRpbmcgPSBlbGVtZW50cy5mbG9hdGluZztcbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIHJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIHJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblJlZmVyZW5jZU1vdXNlRW50ZXIsIHtcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvblJlZmVyZW5jZU1vdXNlRW50ZXIpO1xuICAgICAgcmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblJlZmVyZW5jZU1vdXNlTGVhdmUpO1xuICAgICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICAgIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgICBmbG9hdGluZy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25GbG9hdGluZ01vdXNlRW50ZXIpO1xuICAgICAgICBmbG9hdGluZy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25GbG9hdGluZ01vdXNlTGVhdmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICByZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICByZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25SZWZlcmVuY2VNb3VzZUVudGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uUmVmZXJlbmNlTW91c2VFbnRlcik7XG4gICAgICAgIHJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25SZWZlcmVuY2VNb3VzZUxlYXZlKTtcbiAgICAgICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICAgICAgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgICAgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uRmxvYXRpbmdNb3VzZUVudGVyKTtcbiAgICAgICAgICBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25GbG9hdGluZ01vdXNlTGVhdmUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VsZW1lbnRzLCBlbmFibGVkLCBjb250ZXh0LCBtb3VzZU9ubHksIG1vdmUsIGNsb3NlV2l0aERlbGF5LCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciwgY2xlYXJQb2ludGVyRXZlbnRzLCBvbk9wZW5DaGFuZ2UsIG9wZW4sIG9wZW5SZWYsIHRyZWUsIGRlbGF5UmVmLCBoYW5kbGVDbG9zZVJlZiwgZGF0YVJlZiwgaXNDbGlja0xpa2VPcGVuRXZlbnQsIHJlc3RNc1JlZl0pO1xuXG4gIC8vIEJsb2NrIHBvaW50ZXItZXZlbnRzIG9mIGV2ZXJ5IGVsZW1lbnQgb3RoZXIgdGhhbiB0aGUgcmVmZXJlbmNlIGFuZCBmbG9hdGluZ1xuICAvLyB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBvcGVuIGFuZCBoYXMgYSBgaGFuZGxlQ2xvc2VgIGhhbmRsZXIuIEFsc29cbiAgLy8gaGFuZGxlcyBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTcyMlxuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfaGFuZGxlQ2xvc2VSZWYkY3VycmU7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKG9wZW4gJiYgKF9oYW5kbGVDbG9zZVJlZiRjdXJyZSA9IGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQpICE9IG51bGwgJiYgKF9oYW5kbGVDbG9zZVJlZiRjdXJyZSA9IF9oYW5kbGVDbG9zZVJlZiRjdXJyZS5fX29wdGlvbnMpICE9IG51bGwgJiYgX2hhbmRsZUNsb3NlUmVmJGN1cnJlLmJsb2NrUG9pbnRlckV2ZW50cyAmJiBpc0hvdmVyT3BlbigpKSB7XG4gICAgICBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBjb25zdCBmbG9hdGluZ0VsID0gZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgJiYgZmxvYXRpbmdFbCkge1xuICAgICAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuO1xuICAgICAgICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQkMShlbGVtZW50cy5mbG9hdGluZykuYm9keTtcbiAgICAgICAgYm9keS5zZXRBdHRyaWJ1dGUoc2FmZVBvbHlnb25JZGVudGlmaWVyLCAnJyk7XG4gICAgICAgIGNvbnN0IHJlZiA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZTtcbiAgICAgICAgY29uc3QgcGFyZW50RmxvYXRpbmcgPSB0cmVlID09IG51bGwgfHwgKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5lbGVtZW50cy5mbG9hdGluZztcbiAgICAgICAgaWYgKHBhcmVudEZsb2F0aW5nKSB7XG4gICAgICAgICAgcGFyZW50RmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgcmVmLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG4gICAgICAgIGZsb2F0aW5nRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICAgIGZsb2F0aW5nRWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHBhcmVudElkLCBlbGVtZW50cywgdHJlZSwgaGFuZGxlQ2xvc2VSZWYsIGlzSG92ZXJPcGVuXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgcmVzdFRpbWVvdXRQZW5kaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciwgY2xlYXJQb2ludGVyRXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0UmVmKTtcbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHJlc3RUaW1lb3V0UmVmKTtcbiAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCBlbGVtZW50cy5kb21SZWZlcmVuY2UsIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHNdKTtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclJlZihldmVudCkge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb25Qb2ludGVyRG93bjogc2V0UG9pbnRlclJlZixcbiAgICAgIG9uUG9pbnRlckVudGVyOiBzZXRQb2ludGVyUmVmLFxuICAgICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKCkge1xuICAgICAgICAgIGlmICghYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCAmJiAhb3BlblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgbmF0aXZlRXZlbnQsICdob3ZlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcGVuIHx8IGdldFJlc3RNcyhyZXN0TXNSZWYuY3VycmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZ25vcmUgaW5zaWduaWZpY2FudCBtb3ZlbWVudHMgdG8gYWNjb3VudCBmb3IgdHJlbW9ycy5cbiAgICAgICAgaWYgKHJlc3RUaW1lb3V0UGVuZGluZ1JlZi5jdXJyZW50ICYmIGV2ZW50Lm1vdmVtZW50WCAqKiAyICsgZXZlbnQubW92ZW1lbnRZICoqIDIgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dElmU2V0KHJlc3RUaW1lb3V0UmVmKTtcbiAgICAgICAgaWYgKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN0VGltZW91dFBlbmRpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgcmVzdFRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KGhhbmRsZU1vdXNlTW92ZSwgZ2V0UmVzdE1zKHJlc3RNc1JlZi5jdXJyZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbbW91c2VPbmx5LCBvbk9wZW5DaGFuZ2UsIG9wZW4sIG9wZW5SZWYsIHJlc3RNc1JlZl0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZVxuICB9IDoge30sIFtlbmFibGVkLCByZWZlcmVuY2VdKTtcbn1cblxuY29uc3QgTk9PUCA9ICgpID0+IHt9O1xuY29uc3QgRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgZGVsYXk6IDAsXG4gIGluaXRpYWxEZWxheTogMCxcbiAgdGltZW91dE1zOiAwLFxuICBjdXJyZW50SWQ6IG51bGwsXG4gIHNldEN1cnJlbnRJZDogTk9PUCxcbiAgc2V0U3RhdGU6IE5PT1AsXG4gIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxufSk7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIFVzZSB0aGUgcmV0dXJuIHZhbHVlIG9mIGB1c2VEZWxheUdyb3VwKClgIGluc3RlYWQuXG4gKi9cbmNvbnN0IHVzZURlbGF5R3JvdXBDb250ZXh0ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0KTtcbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgYSBncm91cCBvZiBmbG9hdGluZyBlbGVtZW50cyB0aGF0IHNob3VsZCBzaGFyZSBhXG4gKiBgZGVsYXlgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRGVsYXlHcm91cFxuICovXG5mdW5jdGlvbiBGbG9hdGluZ0RlbGF5R3JvdXAocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyA9IDBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVJlZHVjZXIoKHByZXYsIG5leHQpID0+ICh7XG4gICAgLi4ucHJldixcbiAgICAuLi5uZXh0XG4gIH0pLCB7XG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zLFxuICAgIGluaXRpYWxEZWxheTogZGVsYXksXG4gICAgY3VycmVudElkOiBudWxsLFxuICAgIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgaW5pdGlhbEN1cnJlbnRJZFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2V0Q3VycmVudElkID0gUmVhY3QudXNlQ2FsbGJhY2soY3VycmVudElkID0+IHtcbiAgICBzZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50SWRcbiAgICB9KTtcbiAgfSwgW10pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50SWQpIHtcbiAgICAgIGlmIChpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gc3RhdGUuY3VycmVudElkO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUuaXNJbnN0YW50UGhhc2UpIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzSW5zdGFudFBoYXNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuaXNJbnN0YW50UGhhc2UpIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbc3RhdGUuY3VycmVudElkLCBzdGF0ZS5pc0luc3RhbnRQaGFzZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc2V0U3RhdGUsXG4gICAgICBzZXRDdXJyZW50SWRcbiAgICB9KSwgW3N0YXRlLCBzZXRDdXJyZW50SWRdKSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG4vKipcbiAqIEVuYWJsZXMgZ3JvdXBpbmcgd2hlbiBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQncyBhIGNoaWxkIG9mIGFcbiAqIGBGbG9hdGluZ0RlbGF5R3JvdXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRGVsYXlHcm91cFxuICovXG5mdW5jdGlvbiB1c2VEZWxheUdyb3VwKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZmxvYXRpbmdJZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGlkOiBvcHRpb25JZCxcbiAgICBlbmFibGVkID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgaWQgPSBvcHRpb25JZCAhPSBudWxsID8gb3B0aW9uSWQgOiBmbG9hdGluZ0lkO1xuICBjb25zdCBncm91cENvbnRleHQgPSB1c2VEZWxheUdyb3VwQ29udGV4dCgpO1xuICBjb25zdCB7XG4gICAgY3VycmVudElkLFxuICAgIHNldEN1cnJlbnRJZCxcbiAgICBpbml0aWFsRGVsYXksXG4gICAgc2V0U3RhdGUsXG4gICAgdGltZW91dE1zXG4gIH0gPSBncm91cENvbnRleHQ7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKCFjdXJyZW50SWQpIHJldHVybjtcbiAgICBzZXRTdGF0ZSh7XG4gICAgICBkZWxheToge1xuICAgICAgICBvcGVuOiAxLFxuICAgICAgICBjbG9zZTogZ2V0RGVsYXkoaW5pdGlhbERlbGF5LCAnY2xvc2UnKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjdXJyZW50SWQgIT09IGlkKSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIGlkLCBvbk9wZW5DaGFuZ2UsIHNldFN0YXRlLCBjdXJyZW50SWQsIGluaXRpYWxEZWxheV0pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IGluaXRpYWxEZWxheSxcbiAgICAgICAgY3VycmVudElkOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKCFjdXJyZW50SWQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4gJiYgY3VycmVudElkID09PSBpZCkge1xuICAgICAgaWYgKHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodW5zZXQsIHRpbWVvdXRNcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdW5zZXQoKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpZCwgb25PcGVuQ2hhbmdlLCBpbml0aWFsRGVsYXksIHRpbWVvdXRNc10pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmIChzZXRDdXJyZW50SWQgPT09IE5PT1AgfHwgIW9wZW4pIHJldHVybjtcbiAgICBzZXRDdXJyZW50SWQoaWQpO1xuICB9LCBbZW5hYmxlZCwgb3Blbiwgc2V0Q3VycmVudElkLCBpZF0pO1xuICByZXR1cm4gZ3JvdXBDb250ZXh0O1xufVxuXG5jb25zdCBOZXh0RmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgaGFzUHJvdmlkZXI6IGZhbHNlLFxuICB0aW1lb3V0TXM6IDAsXG4gIGRlbGF5UmVmOiB7XG4gICAgY3VycmVudDogMFxuICB9LFxuICBpbml0aWFsRGVsYXlSZWY6IHtcbiAgICBjdXJyZW50OiAwXG4gIH0sXG4gIHRpbWVvdXRJZFJlZjoge1xuICAgIGN1cnJlbnQ6IC0xXG4gIH0sXG4gIGN1cnJlbnRJZFJlZjoge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfSxcbiAgY3VycmVudENvbnRleHRSZWY6IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH1cbn0pO1xuLyoqXG4gKiBFeHBlcmltZW50YWwgbmV4dCB2ZXJzaW9uIG9mIGBGbG9hdGluZ0RlbGF5R3JvdXBgIHRvIGJlY29tZSB0aGUgZGVmYXVsdFxuICogaW4gdGhlIGZ1dHVyZS4gVGhpcyBjb21wb25lbnQgaXMgbm90IHlldCBzdGFibGUuXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBhIGdyb3VwIG9mIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHNoYXJlIGFcbiAqIGBkZWxheWAuIFVubGlrZSBgRmxvYXRpbmdEZWxheUdyb3VwYCwgYHVzZU5leHREZWxheUdyb3VwYCB3aXRoIHRoaXNcbiAqIGNvbXBvbmVudCBkb2VzIG5vdCBjYXVzZSBhIHJlLXJlbmRlciBvZiB1bnJlbGF0ZWQgY29uc3VtZXJzIG9mIHRoZVxuICogY29udGV4dCB3aGVuIHRoZSBkZWxheSBjaGFuZ2VzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRGVsYXlHcm91cFxuICovXG5mdW5jdGlvbiBOZXh0RmxvYXRpbmdEZWxheUdyb3VwKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkZWxheSxcbiAgICB0aW1lb3V0TXMgPSAwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgZGVsYXlSZWYgPSBSZWFjdC51c2VSZWYoZGVsYXkpO1xuICBjb25zdCBpbml0aWFsRGVsYXlSZWYgPSBSZWFjdC51c2VSZWYoZGVsYXkpO1xuICBjb25zdCBjdXJyZW50SWRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGN1cnJlbnRDb250ZXh0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB0aW1lb3V0SWRSZWYgPSBSZWFjdC51c2VSZWYoLTEpO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChOZXh0RmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBoYXNQcm92aWRlcjogdHJ1ZSxcbiAgICAgIGRlbGF5UmVmLFxuICAgICAgaW5pdGlhbERlbGF5UmVmLFxuICAgICAgY3VycmVudElkUmVmLFxuICAgICAgdGltZW91dE1zLFxuICAgICAgY3VycmVudENvbnRleHRSZWYsXG4gICAgICB0aW1lb3V0SWRSZWZcbiAgICB9KSwgW3RpbWVvdXRNc10pLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbi8qKlxuICogRW5hYmxlcyBncm91cGluZyB3aGVuIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCdzIGEgY2hpbGQgb2YgYVxuICogYE5leHRGbG9hdGluZ0RlbGF5R3JvdXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRGVsYXlHcm91cFxuICovXG5mdW5jdGlvbiB1c2VOZXh0RGVsYXlHcm91cChjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGZsb2F0aW5nSWRcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZ3JvdXBDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChOZXh0RmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50SWRSZWYsXG4gICAgZGVsYXlSZWYsXG4gICAgdGltZW91dE1zLFxuICAgIGluaXRpYWxEZWxheVJlZixcbiAgICBjdXJyZW50Q29udGV4dFJlZixcbiAgICBoYXNQcm92aWRlcixcbiAgICB0aW1lb3V0SWRSZWZcbiAgfSA9IGdyb3VwQ29udGV4dDtcbiAgY29uc3QgW2lzSW5zdGFudFBoYXNlLCBzZXRJc0luc3RhbnRQaGFzZV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gdW5zZXQoKSB7XG4gICAgICB2YXIgX2N1cnJlbnRDb250ZXh0UmVmJGN1O1xuICAgICAgc2V0SXNJbnN0YW50UGhhc2UoZmFsc2UpO1xuICAgICAgKF9jdXJyZW50Q29udGV4dFJlZiRjdSA9IGN1cnJlbnRDb250ZXh0UmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2N1cnJlbnRDb250ZXh0UmVmJGN1LnNldElzSW5zdGFudFBoYXNlKGZhbHNlKTtcbiAgICAgIGN1cnJlbnRJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIGN1cnJlbnRDb250ZXh0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgZGVsYXlSZWYuY3VycmVudCA9IGluaXRpYWxEZWxheVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWN1cnJlbnRJZFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgaWYgKCFvcGVuICYmIGN1cnJlbnRJZFJlZi5jdXJyZW50ID09PSBmbG9hdGluZ0lkKSB7XG4gICAgICBzZXRJc0luc3RhbnRQaGFzZShmYWxzZSk7XG4gICAgICBpZiAodGltZW91dE1zKSB7XG4gICAgICAgIHRpbWVvdXRJZFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQodW5zZXQsIHRpbWVvdXRNcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHVuc2V0KCk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZmxvYXRpbmdJZCwgY3VycmVudElkUmVmLCBkZWxheVJlZiwgdGltZW91dE1zLCBpbml0aWFsRGVsYXlSZWYsIGN1cnJlbnRDb250ZXh0UmVmLCB0aW1lb3V0SWRSZWZdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICBjb25zdCBwcmV2Q29udGV4dCA9IGN1cnJlbnRDb250ZXh0UmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcHJldklkID0gY3VycmVudElkUmVmLmN1cnJlbnQ7XG4gICAgY3VycmVudENvbnRleHRSZWYuY3VycmVudCA9IHtcbiAgICAgIG9uT3BlbkNoYW5nZSxcbiAgICAgIHNldElzSW5zdGFudFBoYXNlXG4gICAgfTtcbiAgICBjdXJyZW50SWRSZWYuY3VycmVudCA9IGZsb2F0aW5nSWQ7XG4gICAgZGVsYXlSZWYuY3VycmVudCA9IHtcbiAgICAgIG9wZW46IDAsXG4gICAgICBjbG9zZTogZ2V0RGVsYXkoaW5pdGlhbERlbGF5UmVmLmN1cnJlbnQsICdjbG9zZScpXG4gICAgfTtcbiAgICBpZiAocHJldklkICE9PSBudWxsICYmIHByZXZJZCAhPT0gZmxvYXRpbmdJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dElkUmVmKTtcbiAgICAgIHNldElzSW5zdGFudFBoYXNlKHRydWUpO1xuICAgICAgcHJldkNvbnRleHQgPT0gbnVsbCB8fCBwcmV2Q29udGV4dC5zZXRJc0luc3RhbnRQaGFzZSh0cnVlKTtcbiAgICAgIHByZXZDb250ZXh0ID09IG51bGwgfHwgcHJldkNvbnRleHQub25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXNJbnN0YW50UGhhc2UoZmFsc2UpO1xuICAgICAgcHJldkNvbnRleHQgPT0gbnVsbCB8fCBwcmV2Q29udGV4dC5zZXRJc0luc3RhbnRQaGFzZShmYWxzZSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZmxvYXRpbmdJZCwgb25PcGVuQ2hhbmdlLCBjdXJyZW50SWRSZWYsIGRlbGF5UmVmLCB0aW1lb3V0TXMsIGluaXRpYWxEZWxheVJlZiwgY3VycmVudENvbnRleHRSZWYsIHRpbWVvdXRJZFJlZl0pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50Q29udGV4dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9O1xuICB9LCBbY3VycmVudENvbnRleHRSZWZdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBoYXNQcm92aWRlcixcbiAgICBkZWxheVJlZixcbiAgICBpc0luc3RhbnRQaGFzZVxuICB9KSwgW2hhc1Byb3ZpZGVyLCBkZWxheVJlZiwgaXNJbnN0YW50UGhhc2VdKTtcbn1cblxubGV0IHJhZklkID0gMDtcbmZ1bmN0aW9uIGVucXVldWVGb2N1cyhlbCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBwcmV2ZW50U2Nyb2xsID0gZmFsc2UsXG4gICAgY2FuY2VsUHJldmlvdXMgPSB0cnVlLFxuICAgIHN5bmMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY2FuY2VsUHJldmlvdXMgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICBjb25zdCBleGVjID0gKCkgPT4gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLmZvY3VzKHtcbiAgICBwcmV2ZW50U2Nyb2xsXG4gIH0pO1xuICBpZiAoc3luYykge1xuICAgIGV4ZWMoKTtcbiAgfSBlbHNlIHtcbiAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShleGVjKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIGlmICghcGFyZW50IHx8ICFjaGlsZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gbmV4dCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0KGV2ZW50KSB7XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydFxuICAvLyBgY29tcG9zZWRQYXRoKClgLCBidXQgYnJvd3NlcnMgd2l0aG91dCBzaGFkb3cgRE9NIGRvbid0LlxuICByZXR1cm4gZXZlbnQudGFyZ2V0O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUub3duZXJEb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG59XG5cbi8vIE1vZGlmaWVkIHRvIGFkZCBjb25kaXRpb25hbCBgYXJpYS1oaWRkZW5gIHN1cHBvcnQ6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGhlS2FzaGV5L2FyaWEtaGlkZGVuL2Jsb2IvOTIyMGM4ZjRhNGZkMzVmNjNiZWU1NTEwYTlmNDFhMzcyNjQzODJkNC9zcmMvaW5kZXgudHNcbmNvbnN0IGNvdW50ZXJzID0ge1xuICBpbmVydDogLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCksXG4gICdhcmlhLWhpZGRlbic6IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpLFxuICBub25lOiAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKVxufTtcbmZ1bmN0aW9uIGdldENvdW50ZXJNYXAoY29udHJvbCkge1xuICBpZiAoY29udHJvbCA9PT0gJ2luZXJ0JykgcmV0dXJuIGNvdW50ZXJzLmluZXJ0O1xuICBpZiAoY29udHJvbCA9PT0gJ2FyaWEtaGlkZGVuJykgcmV0dXJuIGNvdW50ZXJzWydhcmlhLWhpZGRlbiddO1xuICByZXR1cm4gY291bnRlcnMubm9uZTtcbn1cbmxldCB1bmNvbnRyb2xsZWRFbGVtZW50c1NldCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xubGV0IG1hcmtlck1hcCA9IHt9O1xubGV0IGxvY2tDb3VudCQxID0gMDtcbmNvbnN0IHN1cHBvcnRzSW5lcnQgPSAoKSA9PiB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdpbmVydCcgaW4gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuY29uc3QgdW53cmFwSG9zdCA9IG5vZGUgPT4gbm9kZSAmJiAobm9kZS5ob3N0IHx8IHVud3JhcEhvc3Qobm9kZS5wYXJlbnROb2RlKSk7XG5jb25zdCBjb3JyZWN0RWxlbWVudHMgPSAocGFyZW50LCB0YXJnZXRzKSA9PiB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xuICBpZiAocGFyZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IGNvcnJlY3RlZFRhcmdldCA9IHVud3JhcEhvc3QodGFyZ2V0KTtcbiAgaWYgKHBhcmVudC5jb250YWlucyhjb3JyZWN0ZWRUYXJnZXQpKSB7XG4gICAgcmV0dXJuIGNvcnJlY3RlZFRhcmdldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0pLmZpbHRlcih4ID0+IHggIT0gbnVsbCk7XG5mdW5jdGlvbiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKHVuY29ycmVjdGVkQXZvaWRFbGVtZW50cywgYm9keSwgYXJpYUhpZGRlbiwgaW5lcnQpIHtcbiAgY29uc3QgbWFya2VyTmFtZSA9ICdkYXRhLWZsb2F0aW5nLXVpLWluZXJ0JztcbiAgY29uc3QgY29udHJvbEF0dHJpYnV0ZSA9IGluZXJ0ID8gJ2luZXJ0JyA6IGFyaWFIaWRkZW4gPyAnYXJpYS1oaWRkZW4nIDogbnVsbDtcbiAgY29uc3QgYXZvaWRFbGVtZW50cyA9IGNvcnJlY3RFbGVtZW50cyhib2R5LCB1bmNvcnJlY3RlZEF2b2lkRWxlbWVudHMpO1xuICBjb25zdCBlbGVtZW50c1RvS2VlcCA9IG5ldyBTZXQoKTtcbiAgY29uc3QgZWxlbWVudHNUb1N0b3AgPSBuZXcgU2V0KGF2b2lkRWxlbWVudHMpO1xuICBjb25zdCBoaWRkZW5FbGVtZW50cyA9IFtdO1xuICBpZiAoIW1hcmtlck1hcFttYXJrZXJOYW1lXSkge1xuICAgIG1hcmtlck1hcFttYXJrZXJOYW1lXSA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgY29uc3QgbWFya2VyQ291bnRlciA9IG1hcmtlck1hcFttYXJrZXJOYW1lXTtcbiAgYXZvaWRFbGVtZW50cy5mb3JFYWNoKGtlZXApO1xuICBkZWVwKGJvZHkpO1xuICBlbGVtZW50c1RvS2VlcC5jbGVhcigpO1xuICBmdW5jdGlvbiBrZWVwKGVsKSB7XG4gICAgaWYgKCFlbCB8fCBlbGVtZW50c1RvS2VlcC5oYXMoZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnRzVG9LZWVwLmFkZChlbCk7XG4gICAgZWwucGFyZW50Tm9kZSAmJiBrZWVwKGVsLnBhcmVudE5vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZXAocGFyZW50KSB7XG4gICAgaWYgKCFwYXJlbnQgfHwgZWxlbWVudHNUb1N0b3AuaGFzKHBhcmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgW10uZm9yRWFjaC5jYWxsKHBhcmVudC5jaGlsZHJlbiwgbm9kZSA9PiB7XG4gICAgICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdzY3JpcHQnKSByZXR1cm47XG4gICAgICBpZiAoZWxlbWVudHNUb0tlZXAuaGFzKG5vZGUpKSB7XG4gICAgICAgIGRlZXAobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhdHRyID0gY29udHJvbEF0dHJpYnV0ZSA/IG5vZGUuZ2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUpIDogbnVsbDtcbiAgICAgICAgY29uc3QgYWxyZWFkeUhpZGRlbiA9IGF0dHIgIT09IG51bGwgJiYgYXR0ciAhPT0gJ2ZhbHNlJztcbiAgICAgICAgY29uc3QgY291bnRlck1hcCA9IGdldENvdW50ZXJNYXAoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyTWFwLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgY291bnRlck1hcC5zZXQobm9kZSwgY291bnRlclZhbHVlKTtcbiAgICAgICAgbWFya2VyQ291bnRlci5zZXQobm9kZSwgbWFya2VyVmFsdWUpO1xuICAgICAgICBoaWRkZW5FbGVtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoY291bnRlclZhbHVlID09PSAxICYmIGFscmVhZHlIaWRkZW4pIHtcbiAgICAgICAgICB1bmNvbnRyb2xsZWRFbGVtZW50c1NldC5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlclZhbHVlID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobWFya2VyTmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeUhpZGRlbiAmJiBjb250cm9sQXR0cmlidXRlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSwgY29udHJvbEF0dHJpYnV0ZSA9PT0gJ2luZXJ0JyA/ICcnIDogJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxvY2tDb3VudCQxKys7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaGlkZGVuRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGNvdW50ZXJNYXAgPSBnZXRDb3VudGVyTWFwKGNvbnRyb2xBdHRyaWJ1dGUpO1xuICAgICAgY29uc3QgY3VycmVudENvdW50ZXJWYWx1ZSA9IGNvdW50ZXJNYXAuZ2V0KGVsZW1lbnQpIHx8IDA7XG4gICAgICBjb25zdCBjb3VudGVyVmFsdWUgPSBjdXJyZW50Q291bnRlclZhbHVlIC0gMTtcbiAgICAgIGNvbnN0IG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvdW50ZXJNYXAuc2V0KGVsZW1lbnQsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICBtYXJrZXJDb3VudGVyLnNldChlbGVtZW50LCBtYXJrZXJWYWx1ZSk7XG4gICAgICBpZiAoIWNvdW50ZXJWYWx1ZSkge1xuICAgICAgICBpZiAoIXVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmhhcyhlbGVtZW50KSAmJiBjb250cm9sQXR0cmlidXRlKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXJrZXJWYWx1ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShtYXJrZXJOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2NrQ291bnQkMS0tO1xuICAgIGlmICghbG9ja0NvdW50JDEpIHtcbiAgICAgIGNvdW50ZXJzLmluZXJ0ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvdW50ZXJzWydhcmlhLWhpZGRlbiddID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvdW50ZXJzLm5vbmUgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgbWFya2VyTWFwID0ge307XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWFya090aGVycyhhdm9pZEVsZW1lbnRzLCBhcmlhSGlkZGVuLCBpbmVydCkge1xuICBpZiAoYXJpYUhpZGRlbiA9PT0gdm9pZCAwKSB7XG4gICAgYXJpYUhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGlmIChpbmVydCA9PT0gdm9pZCAwKSB7XG4gICAgaW5lcnQgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoYXZvaWRFbGVtZW50c1swXSkuYm9keTtcbiAgcmV0dXJuIGFwcGx5QXR0cmlidXRlVG9PdGhlcnMoYXZvaWRFbGVtZW50cy5jb25jYXQoQXJyYXkuZnJvbShib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ1thcmlhLWxpdmVdLFtyb2xlPVwic3RhdHVzXCJdLG91dHB1dCcpKSksIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KTtcbn1cblxuY29uc3QgSElEREVOX1NUWUxFUyA9IHtcbiAgYm9yZGVyOiAwLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gIGhlaWdodDogJzFweCcsXG4gIG1hcmdpbjogJy0xcHgnLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHBhZGRpbmc6IDAsXG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgd2lkdGg6ICcxcHgnLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDBcbn07XG5jb25zdCBGb2N1c0d1YXJkID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRm9jdXNHdWFyZChwcm9wcywgcmVmKSB7XG4gIGNvbnN0IFtyb2xlLCBzZXRSb2xlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIC8vIFVubGlrZSBvdGhlciBzY3JlZW4gcmVhZGVycyBzdWNoIGFzIE5WREEgYW5kIEpBV1MsIHRoZSB2aXJ0dWFsIGN1cnNvclxuICAgICAgLy8gb24gVm9pY2VPdmVyIGRvZXMgdHJpZ2dlciB0aGUgb25Gb2N1cyBldmVudCwgc28gd2UgY2FuIHVzZSB0aGUgZm9jdXNcbiAgICAgIC8vIHRyYXAgZWxlbWVudC4gT24gU2FmYXJpLCBvbmx5IGJ1dHRvbnMgdHJpZ2dlciB0aGUgb25Gb2N1cyBldmVudC5cbiAgICAgIC8vIE5COiBcImdyb3VwXCIgcm9sZSBpbiB0aGUgU2FuZGJveCBubyBsb25nZXIgYXBwZWFycyB0byB3b3JrLCBtdXN0IGJlIGFcbiAgICAgIC8vIGJ1dHRvbiByb2xlLlxuICAgICAgc2V0Um9sZSgnYnV0dG9uJyk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlc3RQcm9wcyA9IHtcbiAgICByZWYsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gUm9sZSBpcyBvbmx5IGZvciBWb2ljZU92ZXJcbiAgICByb2xlLFxuICAgICdhcmlhLWhpZGRlbic6IHJvbGUgPyB1bmRlZmluZWQgOiB0cnVlLFxuICAgIFtjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJyldOiAnJyxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChcInNwYW5cIiwge1xuICAgIC4uLnByb3BzLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9KTtcbn0pO1xuXG5jb25zdCBQb3J0YWxDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBhdHRyID0gLyojX19QVVJFX18qL2NyZWF0ZUF0dHJpYnV0ZSgncG9ydGFsJyk7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1BvcnRhbCN1c2VmbG9hdGluZ3BvcnRhbG5vZGVcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmdQb3J0YWxOb2RlKHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgaWQsXG4gICAgcm9vdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcG9ydGFsQ29udGV4dCA9IHVzZVBvcnRhbENvbnRleHQoKTtcbiAgY29uc3QgW3BvcnRhbE5vZGUsIHNldFBvcnRhbE5vZGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHBvcnRhbE5vZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUgPT0gbnVsbCB8fCBwb3J0YWxOb2RlLnJlbW92ZSgpO1xuICAgICAgLy8gQWxsb3cgdGhlIHN1YnNlcXVlbnQgbGF5b3V0IGVmZmVjdHMgdG8gY3JlYXRlIGEgbmV3IG5vZGUgb24gdXBkYXRlcy5cbiAgICAgIC8vIFRoZSBwb3J0YWwgbm9kZSB3aWxsIHN0aWxsIGJlIGNsZWFuZWQgdXAgb24gdW5tb3VudC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjQ1NFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW3BvcnRhbE5vZGVdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBXYWl0IGZvciB0aGUgdW5pcXVlSWQgdG8gYmUgZ2VuZXJhdGVkIGJlZm9yZSBjcmVhdGluZyB0aGUgcG9ydGFsIG5vZGUgaW5cbiAgICAvLyBSZWFjdCA8MTggKHVzaW5nIGB1c2VGbG9hdGluZ0lkYCBpbnN0ZWFkIG9mIHRoZSBuYXRpdmUgYHVzZUlkYCkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNzc4XG4gICAgaWYgKCF1bmlxdWVJZCkgcmV0dXJuO1xuICAgIGlmIChwb3J0YWxOb2RlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBleGlzdGluZ0lkUm9vdCA9IGlkID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogbnVsbDtcbiAgICBpZiAoIWV4aXN0aW5nSWRSb290KSByZXR1cm47XG4gICAgY29uc3Qgc3ViUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHN1YlJvb3QuaWQgPSB1bmlxdWVJZDtcbiAgICBzdWJSb290LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgZXhpc3RpbmdJZFJvb3QuYXBwZW5kQ2hpbGQoc3ViUm9vdCk7XG4gICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gc3ViUm9vdDtcbiAgICBzZXRQb3J0YWxOb2RlKHN1YlJvb3QpO1xuICB9LCBbaWQsIHVuaXF1ZUlkXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gV2FpdCBmb3IgdGhlIHJvb3QgdG8gZXhpc3QgYmVmb3JlIGNyZWF0aW5nIHRoZSBwb3J0YWwgbm9kZS4gVGhlIHJvb3QgbXVzdFxuICAgIC8vIGJlIHN0b3JlZCBpbiBzdGF0ZSwgbm90IGEgcmVmLCBmb3IgdGhpcyB0byB3b3JrIHJlYWN0aXZlbHkuXG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHJldHVybjtcbiAgICBpZiAoIXVuaXF1ZUlkKSByZXR1cm47XG4gICAgaWYgKHBvcnRhbE5vZGVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGxldCBjb250YWluZXIgPSByb290IHx8IChwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpO1xuICAgIGlmIChjb250YWluZXIgJiYgIWlzRWxlbWVudChjb250YWluZXIpKSBjb250YWluZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICBsZXQgaWRXcmFwcGVyID0gbnVsbDtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGlkV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaWRXcmFwcGVyLmlkID0gaWQ7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaWRXcmFwcGVyKTtcbiAgICB9XG4gICAgY29uc3Qgc3ViUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHN1YlJvb3QuaWQgPSB1bmlxdWVJZDtcbiAgICBzdWJSb290LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgY29udGFpbmVyID0gaWRXcmFwcGVyIHx8IGNvbnRhaW5lcjtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3ViUm9vdCk7XG4gICAgcG9ydGFsTm9kZVJlZi5jdXJyZW50ID0gc3ViUm9vdDtcbiAgICBzZXRQb3J0YWxOb2RlKHN1YlJvb3QpO1xuICB9LCBbaWQsIHJvb3QsIHVuaXF1ZUlkLCBwb3J0YWxDb250ZXh0XSk7XG4gIHJldHVybiBwb3J0YWxOb2RlO1xufVxuLyoqXG4gKiBQb3J0YWxzIHRoZSBmbG9hdGluZyBlbGVtZW50IGludG8gYSBnaXZlbiBjb250YWluZXIgZWxlbWVudCDigJQgYnkgZGVmYXVsdCxcbiAqIG91dHNpZGUgb2YgdGhlIGFwcCByb290IGFuZCBpbnRvIHRoZSBib2R5LlxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNhbiBhcHBlYXIgb3V0c2lkZSBhbnlcbiAqIHBvdGVudGlhbCBwYXJlbnQgY29udGFpbmVycyB0aGF0IGNhdXNlIGNsaXBwaW5nIChzdWNoIGFzIGBvdmVyZmxvdzogaGlkZGVuYCksXG4gKiB3aGlsZSByZXRhaW5pbmcgaXRzIGxvY2F0aW9uIGluIHRoZSBSZWFjdCB0cmVlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nUG9ydGFsXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nUG9ydGFsKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZCxcbiAgICByb290LFxuICAgIHByZXNlcnZlVGFiT3JkZXIgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcG9ydGFsTm9kZSA9IHVzZUZsb2F0aW5nUG9ydGFsTm9kZSh7XG4gICAgaWQsXG4gICAgcm9vdFxuICB9KTtcbiAgY29uc3QgW2ZvY3VzTWFuYWdlclN0YXRlLCBzZXRGb2N1c01hbmFnZXJTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgYmVmb3JlT3V0c2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJPdXRzaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBiZWZvcmVJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFmdGVySW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBtb2RhbCA9IGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbDtcbiAgY29uc3Qgb3BlbiA9IGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5vcGVuO1xuICBjb25zdCBzaG91bGRSZW5kZXJHdWFyZHMgPVxuICAvLyBUaGUgRm9jdXNNYW5hZ2VyIGFuZCB0aGVyZWZvcmUgZmxvYXRpbmcgZWxlbWVudCBhcmUgY3VycmVudGx5IG9wZW4vXG4gIC8vIHJlbmRlcmVkLlxuICAhIWZvY3VzTWFuYWdlclN0YXRlICYmXG4gIC8vIEd1YXJkcyBhcmUgb25seSBmb3Igbm9uLW1vZGFsIGZvY3VzIG1hbmFnZW1lbnQuXG4gICFmb2N1c01hbmFnZXJTdGF0ZS5tb2RhbCAmJlxuICAvLyBEb24ndCByZW5kZXIgaWYgdW5tb3VudCBpcyB0cmFuc2l0aW9uaW5nLlxuICBmb2N1c01hbmFnZXJTdGF0ZS5vcGVuICYmIHByZXNlcnZlVGFiT3JkZXIgJiYgISEocm9vdCB8fCBwb3J0YWxOb2RlKTtcblxuICAvLyBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdGFiYmFibGUtcG9ydGFsLWY0dG5nP2ZpbGU9L3NyYy9UYWJiYWJsZVBvcnRhbC50c3hcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXBvcnRhbE5vZGUgfHwgIXByZXNlcnZlVGFiT3JkZXIgfHwgbW9kYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudHMgaW5zaWRlIHRoZSBwb3J0YWwgZWxlbWVudCBhcmUgdGFiYmFibGUgb25seSB3aGVuIHRoZVxuICAgIC8vIHBvcnRhbCBoYXMgYWxyZWFkeSBiZWVuIGZvY3VzZWQsIGVpdGhlciBieSB0YWJiaW5nIGludG8gYSBmb2N1cyB0cmFwXG4gICAgLy8gZWxlbWVudCBvdXRzaWRlIG9yIHVzaW5nIHRoZSBtb3VzZS5cbiAgICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICBpZiAocG9ydGFsTm9kZSAmJiBpc091dHNpZGVFdmVudChldmVudCkpIHtcbiAgICAgICAgY29uc3QgZm9jdXNpbmcgPSBldmVudC50eXBlID09PSAnZm9jdXNpbic7XG4gICAgICAgIGNvbnN0IG1hbmFnZUZvY3VzID0gZm9jdXNpbmcgPyBlbmFibGVGb2N1c0luc2lkZSA6IGRpc2FibGVGb2N1c0luc2lkZTtcbiAgICAgICAgbWFuYWdlRm9jdXMocG9ydGFsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIExpc3RlbiB0byB0aGUgZXZlbnQgb24gdGhlIGNhcHR1cmUgcGhhc2Ugc28gdGhleSBydW4gYmVmb3JlIHRoZSBmb2N1c1xuICAgIC8vIHRyYXAgZWxlbWVudHMgb25Gb2N1cyBwcm9wIGlzIGNhbGxlZC5cbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzLCB0cnVlKTtcbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXMsIHRydWUpO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlLCBwcmVzZXJ2ZVRhYk9yZGVyLCBtb2RhbF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcG9ydGFsTm9kZSkgcmV0dXJuO1xuICAgIGlmIChvcGVuKSByZXR1cm47XG4gICAgZW5hYmxlRm9jdXNJbnNpZGUocG9ydGFsTm9kZSk7XG4gIH0sIFtvcGVuLCBwb3J0YWxOb2RlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhQb3J0YWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHByZXNlcnZlVGFiT3JkZXIsXG4gICAgICBiZWZvcmVPdXRzaWRlUmVmLFxuICAgICAgYWZ0ZXJPdXRzaWRlUmVmLFxuICAgICAgYmVmb3JlSW5zaWRlUmVmLFxuICAgICAgYWZ0ZXJJbnNpZGVSZWYsXG4gICAgICBwb3J0YWxOb2RlLFxuICAgICAgc2V0Rm9jdXNNYW5hZ2VyU3RhdGVcbiAgICB9KSwgW3ByZXNlcnZlVGFiT3JkZXIsIHBvcnRhbE5vZGVdKSxcbiAgICBjaGlsZHJlbjogW3Nob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9qc3goRm9jdXNHdWFyZCwge1xuICAgICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgICByZWY6IGJlZm9yZU91dHNpZGVSZWYsXG4gICAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICB2YXIgX2JlZm9yZUluc2lkZVJlZiRjdXJyO1xuICAgICAgICAgIChfYmVmb3JlSW5zaWRlUmVmJGN1cnIgPSBiZWZvcmVJbnNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYmVmb3JlSW5zaWRlUmVmJGN1cnIuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkb21SZWZlcmVuY2UgPSBmb2N1c01hbmFnZXJTdGF0ZSA/IGZvY3VzTWFuYWdlclN0YXRlLmRvbVJlZmVyZW5jZSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZShkb21SZWZlcmVuY2UpO1xuICAgICAgICAgIHByZXZUYWJiYWJsZSA9PSBudWxsIHx8IHByZXZUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIFwiYXJpYS1vd25zXCI6IHBvcnRhbE5vZGUuaWQsXG4gICAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICAgIH0pLCBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdERPTS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHBvcnRhbE5vZGUpLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovanN4KEZvY3VzR3VhcmQsIHtcbiAgICAgIFwiZGF0YS10eXBlXCI6IFwib3V0c2lkZVwiLFxuICAgICAgcmVmOiBhZnRlck91dHNpZGVSZWYsXG4gICAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICB2YXIgX2FmdGVySW5zaWRlUmVmJGN1cnJlO1xuICAgICAgICAgIChfYWZ0ZXJJbnNpZGVSZWYkY3VycmUgPSBhZnRlckluc2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9hZnRlckluc2lkZVJlZiRjdXJyZS5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRvbVJlZmVyZW5jZSA9IGZvY3VzTWFuYWdlclN0YXRlID8gZm9jdXNNYW5hZ2VyU3RhdGUuZG9tUmVmZXJlbmNlIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoZG9tUmVmZXJlbmNlKTtcbiAgICAgICAgICBuZXh0VGFiYmFibGUgPT0gbnVsbCB8fCBuZXh0VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgICAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLmNsb3NlT25Gb2N1c091dCkgJiYgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5vbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnZm9jdXMtb3V0JykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSldXG4gIH0pO1xufVxuY29uc3QgdXNlUG9ydGFsQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoUG9ydGFsQ29udGV4dCk7XG5cbmZ1bmN0aW9uIHVzZUxpdGVNZXJnZVJlZnMocmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlID0+IHtcbiAgICAgIHJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIHJlZnMpO1xufVxuXG5jb25zdCBMSVNUX0xJTUlUID0gMjA7XG5sZXQgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyA9IFtdO1xuZnVuY3Rpb24gYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyA9IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMuZmlsdGVyKGVsID0+IGVsLmlzQ29ubmVjdGVkKTtcbiAgaWYgKGVsZW1lbnQgJiYgZ2V0Tm9kZU5hbWUoZWxlbWVudCkgIT09ICdib2R5Jykge1xuICAgIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICBpZiAocHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5sZW5ndGggPiBMSVNUX0xJTUlUKSB7XG4gICAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgtMjApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkge1xuICByZXR1cm4gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgpLnJldmVyc2UoKS5maW5kKGVsID0+IGVsLmlzQ29ubmVjdGVkKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0VGFiYmFibGVFbGVtZW50KGNvbnRhaW5lcikge1xuICBjb25zdCB0YWJiYWJsZU9wdGlvbnMgPSBnZXRUYWJiYWJsZU9wdGlvbnMoKTtcbiAgaWYgKGlzVGFiYmFibGUoY29udGFpbmVyLCB0YWJiYWJsZU9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICByZXR1cm4gdGFiYmFibGUoY29udGFpbmVyLCB0YWJiYWJsZU9wdGlvbnMpWzBdIHx8IGNvbnRhaW5lcjtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRhYkluZGV4KGZsb2F0aW5nRm9jdXNFbGVtZW50LCBvcmRlclJlZikge1xuICB2YXIgX2Zsb2F0aW5nRm9jdXNFbGVtZW50O1xuICBpZiAoIW9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgJiYgISgoX2Zsb2F0aW5nRm9jdXNFbGVtZW50ID0gZmxvYXRpbmdGb2N1c0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykpICE9IG51bGwgJiYgX2Zsb2F0aW5nRm9jdXNFbGVtZW50LmluY2x1ZGVzKCdkaWFsb2cnKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IGdldFRhYmJhYmxlT3B0aW9ucygpO1xuICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGZvY3VzYWJsZShmbG9hdGluZ0ZvY3VzRWxlbWVudCwgb3B0aW9ucyk7XG4gIGNvbnN0IHRhYmJhYmxlQ29udGVudCA9IGZvY3VzYWJsZUVsZW1lbnRzLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICBjb25zdCBkYXRhVGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpIHx8ICcnO1xuICAgIHJldHVybiBpc1RhYmJhYmxlKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykgJiYgIWRhdGFUYWJJbmRleC5zdGFydHNXaXRoKCctJyk7XG4gIH0pO1xuICBjb25zdCB0YWJJbmRleCA9IGZsb2F0aW5nRm9jdXNFbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgaWYgKG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgfHwgdGFiYmFibGVDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0YWJJbmRleCAhPT0gJzAnKSB7XG4gICAgICBmbG9hdGluZ0ZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFiSW5kZXggIT09ICctMScgfHwgZmxvYXRpbmdGb2N1c0VsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykgJiYgZmxvYXRpbmdGb2N1c0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykgIT09ICctMScpIHtcbiAgICBmbG9hdGluZ0ZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgZmxvYXRpbmdGb2N1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JywgJy0xJyk7XG4gIH1cbn1cbmNvbnN0IFZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFZpc3VhbGx5SGlkZGVuRGlzbWlzcyhwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiYnV0dG9uXCIsIHtcbiAgICAuLi5wcm9wcyxcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHJlZjogcmVmLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KTtcbn0pO1xuLyoqXG4gKiBQcm92aWRlcyBmb2N1cyBtYW5hZ2VtZW50IGZvciB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0ZvY3VzTWFuYWdlclxuICovXG5mdW5jdGlvbiBGbG9hdGluZ0ZvY3VzTWFuYWdlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgY29udGV4dCxcbiAgICBjaGlsZHJlbixcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIG9yZGVyID0gWydjb250ZW50J10sXG4gICAgZ3VhcmRzOiBfZ3VhcmRzID0gdHJ1ZSxcbiAgICBpbml0aWFsRm9jdXMgPSAwLFxuICAgIHJldHVybkZvY3VzID0gdHJ1ZSxcbiAgICByZXN0b3JlRm9jdXMgPSBmYWxzZSxcbiAgICBtb2RhbCA9IHRydWUsXG4gICAgdmlzdWFsbHlIaWRkZW5EaXNtaXNzID0gZmFsc2UsXG4gICAgY2xvc2VPbkZvY3VzT3V0ID0gdHJ1ZSxcbiAgICBvdXRzaWRlRWxlbWVudHNJbmVydCA9IGZhbHNlLFxuICAgIGdldEluc2lkZUVsZW1lbnRzOiBfZ2V0SW5zaWRlRWxlbWVudHMgPSAoKSA9PiBbXVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBldmVudHMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBnZXROb2RlSWQgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkZmxvYTtcbiAgICByZXR1cm4gKF9kYXRhUmVmJGN1cnJlbnQkZmxvYSA9IGRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JGZsb2Eubm9kZUlkO1xuICB9KTtcbiAgY29uc3QgZ2V0SW5zaWRlRWxlbWVudHMgPSB1c2VFZmZlY3RFdmVudChfZ2V0SW5zaWRlRWxlbWVudHMpO1xuICBjb25zdCBpZ25vcmVJbml0aWFsRm9jdXMgPSB0eXBlb2YgaW5pdGlhbEZvY3VzID09PSAnbnVtYmVyJyAmJiBpbml0aWFsRm9jdXMgPCAwO1xuICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGEgY29tYm9ib3ggYW5kIGlzIHR5cGVhYmxlIChlLmcuIGlucHV0L3RleHRhcmVhKSxcbiAgLy8gdGhlcmUgYXJlIGRpZmZlcmVudCBmb2N1cyBzZW1hbnRpY3MuIFRoZSBndWFyZHMgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCwgYnV0XG4gIC8vIGFyaWEtaGlkZGVuIHNob3VsZCBiZSBhcHBsaWVkIHRvIGFsbCBub2RlcyBzdGlsbC4gRnVydGhlciwgdGhlIHZpc3VhbGx5XG4gIC8vIGhpZGRlbiBkaXNtaXNzIGJ1dHRvbiBzaG91bGQgb25seSBhcHBlYXIgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgbm90IHRoZVxuICAvLyBzdGFydC5cbiAgY29uc3QgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID0gaXNUeXBlYWJsZUNvbWJvYm94KGRvbVJlZmVyZW5jZSkgJiYgaWdub3JlSW5pdGlhbEZvY3VzO1xuXG4gIC8vIEZvcmNlIHRoZSBndWFyZHMgdG8gYmUgcmVuZGVyZWQgaWYgdGhlIGBpbmVydGAgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gIGNvbnN0IGluZXJ0U3VwcG9ydGVkID0gc3VwcG9ydHNJbmVydCgpO1xuICBjb25zdCBndWFyZHMgPSBpbmVydFN1cHBvcnRlZCA/IF9ndWFyZHMgOiB0cnVlO1xuICBjb25zdCB1c2VJbmVydCA9ICFndWFyZHMgfHwgaW5lcnRTdXBwb3J0ZWQgJiYgb3V0c2lkZUVsZW1lbnRzSW5lcnQ7XG4gIGNvbnN0IG9yZGVyUmVmID0gdXNlTGF0ZXN0UmVmKG9yZGVyKTtcbiAgY29uc3QgaW5pdGlhbEZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKGluaXRpYWxGb2N1cyk7XG4gIGNvbnN0IHJldHVybkZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKHJldHVybkZvY3VzKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBzdGFydERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGVuZERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHByZXZlbnRSZXR1cm5Gb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzUG9pbnRlckRvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB0YWJiYWJsZUluZGV4UmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3QgaXNJbnNpZGVQb3J0YWwgPSBwb3J0YWxDb250ZXh0ICE9IG51bGw7XG4gIGNvbnN0IGZsb2F0aW5nRm9jdXNFbGVtZW50ID0gZ2V0RmxvYXRpbmdGb2N1c0VsZW1lbnQoZmxvYXRpbmcpO1xuICBjb25zdCBnZXRUYWJiYWJsZUNvbnRlbnQgPSB1c2VFZmZlY3RFdmVudChmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250YWluZXIgPSBmbG9hdGluZ0ZvY3VzRWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lciA/IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpIDogW107XG4gIH0pO1xuICBjb25zdCBnZXRUYWJiYWJsZUVsZW1lbnRzID0gdXNlRWZmZWN0RXZlbnQoY29udGFpbmVyID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIG9yZGVyUmVmLmN1cnJlbnQubWFwKHR5cGUgPT4ge1xuICAgICAgaWYgKGRvbVJlZmVyZW5jZSAmJiB0eXBlID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICByZXR1cm4gZG9tUmVmZXJlbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nRm9jdXNFbGVtZW50ICYmIHR5cGUgPT09ICdmbG9hdGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZsb2F0aW5nRm9jdXNFbGVtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pLmZsYXQoKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKCFtb2RhbCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICAgICAgLy8gVGhlIGZvY3VzIGd1YXJkcyBoYXZlIG5vdGhpbmcgdG8gZm9jdXMsIHNvIHdlIG5lZWQgdG8gc3RvcCB0aGUgZXZlbnQuXG4gICAgICAgIGlmIChjb250YWlucyQxKGZsb2F0aW5nRm9jdXNFbGVtZW50LCBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50JDEoZmxvYXRpbmdGb2N1c0VsZW1lbnQpKSkgJiYgZ2V0VGFiYmFibGVDb250ZW50KCkubGVuZ3RoID09PSAwICYmICFpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0JDEoZXZlbnQpO1xuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFswXSA9PT0gJ3JlZmVyZW5jZScgJiYgdGFyZ2V0ID09PSBkb21SZWZlcmVuY2UpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnRbMV0gPT09ICdmbG9hdGluZycgJiYgdGFyZ2V0ID09PSBmbG9hdGluZ0ZvY3VzRWxlbWVudCAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgZW5xdWV1ZUZvY3VzKGVsc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQkMShmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nRm9jdXNFbGVtZW50LCBtb2RhbCwgb3JkZXJSZWYsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ2V0VGFiYmFibGVDb250ZW50LCBnZXRUYWJiYWJsZUVsZW1lbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUZvY3VzSW4oZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldCQxKGV2ZW50KTtcbiAgICAgIGNvbnN0IHRhYmJhYmxlQ29udGVudCA9IGdldFRhYmJhYmxlQ29udGVudCgpO1xuICAgICAgY29uc3QgdGFiYmFibGVJbmRleCA9IHRhYmJhYmxlQ29udGVudC5pbmRleE9mKHRhcmdldCk7XG4gICAgICBpZiAodGFiYmFibGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGFiYmFibGVJbmRleFJlZi5jdXJyZW50ID0gdGFiYmFibGVJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGhhbmRsZUZvY3VzSW4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgaGFuZGxlRm9jdXNJbik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZywgZ2V0VGFiYmFibGVDb250ZW50XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKCFjbG9zZU9uRm9jdXNPdXQpIHJldHVybjtcblxuICAgIC8vIEluIFNhZmFyaSwgYnV0dG9ucyBsb3NlIGZvY3VzIHdoZW4gcHJlc3NpbmcgdGhlbS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bigpIHtcbiAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNPdXRzaWRlKGV2ZW50KSB7XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0JDEoZXZlbnQpO1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBjb25zdCBub2RlSWQgPSBnZXROb2RlSWQoKTtcbiAgICAgICAgY29uc3QgbW92ZWRUb1VucmVsYXRlZE5vZGUgPSAhKGNvbnRhaW5zJDEoZG9tUmVmZXJlbmNlLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyQxKGZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyQxKHJlbGF0ZWRUYXJnZXQsIGZsb2F0aW5nKSB8fCBjb250YWlucyQxKHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSwgcmVsYXRlZFRhcmdldCkgfHwgcmVsYXRlZFRhcmdldCAhPSBudWxsICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKGNyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKSkgfHwgdHJlZSAmJiAoZ2V0Tm9kZUNoaWxkcmVuJDEodHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmZpbmQobm9kZSA9PiB7XG4gICAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQsIF9ub2RlJGNvbnRleHQyO1xuICAgICAgICAgIHJldHVybiBjb250YWlucyQxKChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZywgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMkMSgoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9KSB8fCBnZXROb2RlQW5jZXN0b3JzKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0MywgX25vZGUkY29udGV4dDQsIF9ub2RlJGNvbnRleHQ1O1xuICAgICAgICAgIHJldHVybiBbKF9ub2RlJGNvbnRleHQzID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDMuZWxlbWVudHMuZmxvYXRpbmcsIGdldEZsb2F0aW5nRm9jdXNFbGVtZW50KChfbm9kZSRjb250ZXh0NCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ0LmVsZW1lbnRzLmZsb2F0aW5nKV0uaW5jbHVkZXMocmVsYXRlZFRhcmdldCkgfHwgKChfbm9kZSRjb250ZXh0NSA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ1LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT09IHJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIH0pKSk7XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09PSBkb21SZWZlcmVuY2UgJiYgZmxvYXRpbmdGb2N1c0VsZW1lbnQpIHtcbiAgICAgICAgICBoYW5kbGVUYWJJbmRleChmbG9hdGluZ0ZvY3VzRWxlbWVudCwgb3JkZXJSZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzdG9yZSBmb2N1cyB0byB0aGUgcHJldmlvdXMgdGFiYmFibGUgZWxlbWVudCBpbmRleCB0byBwcmV2ZW50XG4gICAgICAgIC8vIGZvY3VzIGZyb20gYmVpbmcgbG9zdCBvdXRzaWRlIHRoZSBmbG9hdGluZyB0cmVlLlxuICAgICAgICBpZiAocmVzdG9yZUZvY3VzICYmIGN1cnJlbnRUYXJnZXQgIT09IGRvbVJlZmVyZW5jZSAmJiAhKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC5pc0Nvbm5lY3RlZCkgJiYgYWN0aXZlRWxlbWVudChnZXREb2N1bWVudCQxKGZsb2F0aW5nRm9jdXNFbGVtZW50KSkgPT09IGdldERvY3VtZW50JDEoZmxvYXRpbmdGb2N1c0VsZW1lbnQpLmJvZHkpIHtcbiAgICAgICAgICAvLyBMZXQgYEZsb2F0aW5nUG9ydGFsYCBlZmZlY3Qga25vd3MgdGhhdCBmb2N1cyBpcyBzdGlsbCBpbnNpZGUgdGhlXG4gICAgICAgICAgLy8gZmxvYXRpbmcgdHJlZS5cbiAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChmbG9hdGluZ0ZvY3VzRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGZsb2F0aW5nRm9jdXNFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZUluZGV4ID0gdGFiYmFibGVJbmRleFJlZi5jdXJyZW50O1xuICAgICAgICAgIGNvbnN0IHRhYmJhYmxlQ29udGVudCA9IGdldFRhYmJhYmxlQ29udGVudCgpO1xuICAgICAgICAgIGNvbnN0IG5vZGVUb0ZvY3VzID0gdGFiYmFibGVDb250ZW50W3ByZXZUYWJiYWJsZUluZGV4XSB8fCB0YWJiYWJsZUNvbnRlbnRbdGFiYmFibGVDb250ZW50Lmxlbmd0aCAtIDFdIHx8IGZsb2F0aW5nRm9jdXNFbGVtZW50O1xuICAgICAgICAgIGlmIChpc0hUTUxFbGVtZW50KG5vZGVUb0ZvY3VzKSkge1xuICAgICAgICAgICAgbm9kZVRvRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzMwNjBcbiAgICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC5pbnNpZGVSZWFjdFRyZWUpIHtcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQuaW5zaWRlUmVhY3RUcmVlID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9jdXMgZGlkIG5vdCBtb3ZlIGluc2lkZSB0aGUgZmxvYXRpbmcgdHJlZSwgYW5kIHRoZXJlIGFyZSBubyB0YWJiYWJsZVxuICAgICAgICAvLyBwb3J0YWwgZ3VhcmRzIHRvIGhhbmRsZSBjbG9zaW5nLlxuICAgICAgICBpZiAoKGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA/IHRydWUgOiAhbW9kYWwpICYmIHJlbGF0ZWRUYXJnZXQgJiYgbW92ZWRUb1VucmVsYXRlZE5vZGUgJiYgIWlzUG9pbnRlckRvd25SZWYuY3VycmVudCAmJlxuICAgICAgICAvLyBGaXggUmVhY3QgMTggU3RyaWN0IE1vZGUgcmV0dXJuRm9jdXMgZHVlIHRvIGRvdWJsZSByZW5kZXJpbmcuXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQgIT09IGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpKSB7XG4gICAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdmb2N1cy1vdXQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZyAmJiBpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgIGRvbVJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICBmbG9hdGluZy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb21SZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgICBkb21SZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGZsb2F0aW5nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIGZsb2F0aW5nRm9jdXNFbGVtZW50LCBtb2RhbCwgdHJlZSwgcG9ydGFsQ29udGV4dCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRm9jdXNPdXQsIHJlc3RvcmVGb2N1cywgZ2V0VGFiYmFibGVDb250ZW50LCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gsIGdldE5vZGVJZCwgb3JkZXJSZWYsIGRhdGFSZWZdKTtcbiAgY29uc3QgYmVmb3JlR3VhcmRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFmdGVyR3VhcmRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG1lcmdlZEJlZm9yZUd1YXJkUmVmID0gdXNlTGl0ZU1lcmdlUmVmcyhbYmVmb3JlR3VhcmRSZWYsIHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYmVmb3JlSW5zaWRlUmVmXSk7XG4gIGNvbnN0IG1lcmdlZEFmdGVyR3VhcmRSZWYgPSB1c2VMaXRlTWVyZ2VSZWZzKFthZnRlckd1YXJkUmVmLCBwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LmFmdGVySW5zaWRlUmVmXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9wb3J0YWxDb250ZXh0JHBvcnRhbCwgX2FuY2VzdG9ycyRmaW5kO1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGlmICghZmxvYXRpbmcpIHJldHVybjtcblxuICAgIC8vIERvbid0IGhpZGUgcG9ydGFscyBuZXN0ZWQgd2l0aGluIHRoZSBwYXJlbnQgcG9ydGFsLlxuICAgIGNvbnN0IHBvcnRhbE5vZGVzID0gQXJyYXkuZnJvbSgocG9ydGFsQ29udGV4dCA9PSBudWxsIHx8IChfcG9ydGFsQ29udGV4dCRwb3J0YWwgPSBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfcG9ydGFsQ29udGV4dCRwb3J0YWwucXVlcnlTZWxlY3RvckFsbChcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgncG9ydGFsJykgKyBcIl1cIikpIHx8IFtdKTtcbiAgICBjb25zdCBhbmNlc3RvcnMgPSB0cmVlID8gZ2V0Tm9kZUFuY2VzdG9ycyh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIGdldE5vZGVJZCgpKSA6IFtdO1xuICAgIGNvbnN0IGFuY2VzdG9yRmxvYXRpbmdOb2RlcyA9IHRyZWUgJiYgIW1vZGFsID8gYW5jZXN0b3JzLm1hcChub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0NjtcbiAgICAgIHJldHVybiAoX25vZGUkY29udGV4dDYgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Ni5lbGVtZW50cy5mbG9hdGluZztcbiAgICB9KSA6IFtdO1xuICAgIGNvbnN0IHJvb3RBbmNlc3RvckNvbWJvYm94RG9tUmVmZXJlbmNlID0gKF9hbmNlc3RvcnMkZmluZCA9IGFuY2VzdG9ycy5maW5kKG5vZGUgPT4ge1xuICAgICAgdmFyIF9ub2RlJGNvbnRleHQ3O1xuICAgICAgcmV0dXJuIGlzVHlwZWFibGVDb21ib2JveCgoKF9ub2RlJGNvbnRleHQ3ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDcuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSB8fCBudWxsKTtcbiAgICB9KSkgPT0gbnVsbCB8fCAoX2FuY2VzdG9ycyRmaW5kID0gX2FuY2VzdG9ycyRmaW5kLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYW5jZXN0b3JzJGZpbmQuZWxlbWVudHMuZG9tUmVmZXJlbmNlO1xuICAgIGNvbnN0IGluc2lkZUVsZW1lbnRzID0gW2Zsb2F0aW5nLCByb290QW5jZXN0b3JDb21ib2JveERvbVJlZmVyZW5jZSwgLi4ucG9ydGFsTm9kZXMsIC4uLmFuY2VzdG9yRmxvYXRpbmdOb2RlcywgLi4uZ2V0SW5zaWRlRWxlbWVudHMoKSwgc3RhcnREaXNtaXNzQnV0dG9uUmVmLmN1cnJlbnQsIGVuZERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgYmVmb3JlR3VhcmRSZWYuY3VycmVudCwgYWZ0ZXJHdWFyZFJlZi5jdXJyZW50LCBwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LmJlZm9yZU91dHNpZGVSZWYuY3VycmVudCwgcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5hZnRlck91dHNpZGVSZWYuY3VycmVudCwgb3JkZXJSZWYuY3VycmVudC5pbmNsdWRlcygncmVmZXJlbmNlJykgfHwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gZG9tUmVmZXJlbmNlIDogbnVsbF0uZmlsdGVyKHggPT4geCAhPSBudWxsKTtcbiAgICBjb25zdCBjbGVhbnVwID0gbW9kYWwgfHwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gbWFya090aGVycyhpbnNpZGVFbGVtZW50cywgIXVzZUluZXJ0LCB1c2VJbmVydCkgOiBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG9yZGVyUmVmLCBwb3J0YWxDb250ZXh0LCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gsIGd1YXJkcywgdXNlSW5lcnQsIHRyZWUsIGdldE5vZGVJZCwgZ2V0SW5zaWRlRWxlbWVudHNdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWlzSFRNTEVsZW1lbnQoZmxvYXRpbmdGb2N1c0VsZW1lbnQpKSByZXR1cm47XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQkMShmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuXG4gICAgLy8gV2FpdCBmb3IgYW55IGxheW91dCBlZmZlY3Qgc3RhdGUgc2V0dGVycyB0byBleGVjdXRlIHRvIHNldCBgdGFiSW5kZXhgLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0VGFiYmFibGVFbGVtZW50cyhmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgICBjb25zdCBpbml0aWFsRm9jdXNWYWx1ZSA9IGluaXRpYWxGb2N1c1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgZWxUb0ZvY3VzID0gKHR5cGVvZiBpbml0aWFsRm9jdXNWYWx1ZSA9PT0gJ251bWJlcicgPyBmb2N1c2FibGVFbGVtZW50c1tpbml0aWFsRm9jdXNWYWx1ZV0gOiBpbml0aWFsRm9jdXNWYWx1ZS5jdXJyZW50KSB8fCBmbG9hdGluZ0ZvY3VzRWxlbWVudDtcbiAgICAgIGNvbnN0IGZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgPSBjb250YWlucyQxKGZsb2F0aW5nRm9jdXNFbGVtZW50LCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgaWYgKCFpZ25vcmVJbml0aWFsRm9jdXMgJiYgIWZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgJiYgb3Blbikge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoZWxUb0ZvY3VzLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZWxUb0ZvY3VzID09PSBmbG9hdGluZ0ZvY3VzRWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2Rpc2FibGVkLCBvcGVuLCBmbG9hdGluZ0ZvY3VzRWxlbWVudCwgaWdub3JlSW5pdGlhbEZvY3VzLCBnZXRUYWJiYWJsZUVsZW1lbnRzLCBpbml0aWFsRm9jdXNSZWZdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nRm9jdXNFbGVtZW50KSByZXR1cm47XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQkMShmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuXG4gICAgLy8gRGlzbWlzc2luZyB2aWEgb3V0c2lkZSBwcmVzcyBzaG91bGQgYWx3YXlzIGlnbm9yZSBgcmV0dXJuRm9jdXNgIHRvXG4gICAgLy8gcHJldmVudCB1bndhbnRlZCBzY3JvbGxpbmcuXG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHJlYXNvbixcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIG5lc3RlZFxuICAgICAgfSA9IF9yZWY7XG4gICAgICBpZiAoWydob3ZlcicsICdzYWZlLXBvbHlnb24nXS5pbmNsdWRlcyhyZWFzb24pICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uICE9PSAnb3V0c2lkZS1wcmVzcycpIHJldHVybjtcbiAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHx8IGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudCkpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICBjb25zdCBmYWxsYmFja0VsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBmYWxsYmFja0VsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICBmYWxsYmFja0VsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIE9iamVjdC5hc3NpZ24oZmFsbGJhY2tFbC5zdHlsZSwgSElEREVOX1NUWUxFUyk7XG4gICAgaWYgKGlzSW5zaWRlUG9ydGFsICYmIGRvbVJlZmVyZW5jZSkge1xuICAgICAgZG9tUmVmZXJlbmNlLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBmYWxsYmFja0VsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmV0dXJuRWxlbWVudCgpIHtcbiAgICAgIGlmICh0eXBlb2YgcmV0dXJuRm9jdXNSZWYuY3VycmVudCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZG9tUmVmZXJlbmNlIHx8IGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgICByZXR1cm4gZWwgJiYgZWwuaXNDb25uZWN0ZWQgPyBlbCA6IGZhbGxiYWNrRWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuRm9jdXNSZWYuY3VycmVudC5jdXJyZW50IHx8IGZhbGxiYWNrRWw7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSA9IGNvbnRhaW5zJDEoZmxvYXRpbmcsIGFjdGl2ZUVsKSB8fCB0cmVlICYmIGdldE5vZGVDaGlsZHJlbiQxKHRyZWUubm9kZXNSZWYuY3VycmVudCwgZ2V0Tm9kZUlkKCksIGZhbHNlKS5zb21lKG5vZGUgPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDg7XG4gICAgICAgIHJldHVybiBjb250YWlucyQxKChfbm9kZSRjb250ZXh0OCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ4LmVsZW1lbnRzLmZsb2F0aW5nLCBhY3RpdmVFbCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJldHVybkVsZW1lbnQgPSBnZXRSZXR1cm5FbGVtZW50KCk7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgaXMgYHJldHVybkVsZW1lbnRgLCBpZiBpdCdzIHRhYmJhYmxlLCBvciBpdHMgZmlyc3QgdGFiYmFibGUgY2hpbGQuXG4gICAgICAgIGNvbnN0IHRhYmJhYmxlUmV0dXJuRWxlbWVudCA9IGdldEZpcnN0VGFiYmFibGVFbGVtZW50KHJldHVybkVsZW1lbnQpO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgcmV0dXJuRm9jdXNSZWYuY3VycmVudCAmJiAhcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgaXNIVE1MRWxlbWVudCh0YWJiYWJsZVJldHVybkVsZW1lbnQpICYmIChcbiAgICAgICAgLy8gSWYgdGhlIGZvY3VzIG1vdmVkIHNvbWV3aGVyZSBlbHNlIGFmdGVyIG1vdW50LCBhdm9pZCByZXR1cm5pbmcgZm9jdXNcbiAgICAgICAgLy8gc2luY2UgaXQgbGlrZWx5IGVudGVyZWQgYSBkaWZmZXJlbnQgZWxlbWVudCB3aGljaCBzaG91bGQgYmVcbiAgICAgICAgLy8gcmVzcGVjdGVkOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI2MDdcbiAgICAgICAgdGFiYmFibGVSZXR1cm5FbGVtZW50ICE9PSBhY3RpdmVFbCAmJiBhY3RpdmVFbCAhPT0gZG9jLmJvZHkgPyBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIDogdHJ1ZSkpIHtcbiAgICAgICAgICB0YWJiYWJsZVJldHVybkVsZW1lbnQuZm9jdXMoe1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZhbGxiYWNrRWwucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGZsb2F0aW5nLCBmbG9hdGluZ0ZvY3VzRWxlbWVudCwgcmV0dXJuRm9jdXNSZWYsIGRhdGFSZWYsIGV2ZW50cywgdHJlZSwgaXNJbnNpZGVQb3J0YWwsIGRvbVJlZmVyZW5jZSwgZ2V0Tm9kZUlkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVGhlIGByZXR1cm5Gb2N1c2AgY2xlYW51cCBiZWhhdmlvciBpcyBpbnNpZGUgYSBtaWNyb3Rhc2s7IGVuc3VyZSB3ZVxuICAgIC8vIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlIGJlZm9yZSByZXNldHRpbmcgdGhlIGZsYWcuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfSwgW2Rpc2FibGVkXSk7XG5cbiAgLy8gU3luY2hyb25pemUgdGhlIGBjb250ZXh0YCAmIGBtb2RhbGAgdmFsdWUgdG8gdGhlIEZsb2F0aW5nUG9ydGFsIGNvbnRleHQuXG4gIC8vIEl0IHdpbGwgZGVjaWRlIHdoZXRoZXIgb3Igbm90IGl0IG5lZWRzIHRvIHJlbmRlciBpdHMgb3duIGd1YXJkcy5cbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIXBvcnRhbENvbnRleHQpIHJldHVybjtcbiAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKHtcbiAgICAgIG1vZGFsLFxuICAgICAgY2xvc2VPbkZvY3VzT3V0LFxuICAgICAgb3BlbixcbiAgICAgIG9uT3BlbkNoYW5nZSxcbiAgICAgIGRvbVJlZmVyZW5jZVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKG51bGwpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgcG9ydGFsQ29udGV4dCwgbW9kYWwsIG9wZW4sIG9uT3BlbkNoYW5nZSwgY2xvc2VPbkZvY3VzT3V0LCBkb21SZWZlcmVuY2VdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWZsb2F0aW5nRm9jdXNFbGVtZW50KSByZXR1cm47XG4gICAgaGFuZGxlVGFiSW5kZXgoZmxvYXRpbmdGb2N1c0VsZW1lbnQsIG9yZGVyUmVmKTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZ0ZvY3VzRWxlbWVudCwgb3JkZXJSZWZdKTtcbiAgZnVuY3Rpb24gcmVuZGVyRGlzbWlzc0J1dHRvbihsb2NhdGlvbikge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhdmlzdWFsbHlIaWRkZW5EaXNtaXNzIHx8ICFtb2RhbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFZpc3VhbGx5SGlkZGVuRGlzbWlzcywge1xuICAgICAgcmVmOiBsb2NhdGlvbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA6IGVuZERpc21pc3NCdXR0b25SZWYsXG4gICAgICBvbkNsaWNrOiBldmVudCA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KSxcbiAgICAgIGNoaWxkcmVuOiB0eXBlb2YgdmlzdWFsbHlIaWRkZW5EaXNtaXNzID09PSAnc3RyaW5nJyA/IHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA6ICdEaXNtaXNzJ1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNob3VsZFJlbmRlckd1YXJkcyA9ICFkaXNhYmxlZCAmJiBndWFyZHMgJiYgKG1vZGFsID8gIWlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA6IHRydWUpICYmIChpc0luc2lkZVBvcnRhbCB8fCBtb2RhbCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9qc3goRm9jdXNHdWFyZCwge1xuICAgICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICAgIHJlZjogbWVyZ2VkQmVmb3JlR3VhcmRSZWYsXG4gICAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMob3JkZXJbMF0gPT09ICdyZWZlcmVuY2UnID8gZWxzWzBdIDogZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9ydGFsQ29udGV4dCAhPSBudWxsICYmIHBvcnRhbENvbnRleHQucHJlc2VydmVUYWJPcmRlciAmJiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRhYmJhYmxlID0gZ2V0TmV4dFRhYmJhYmxlKGRvbVJlZmVyZW5jZSk7XG4gICAgICAgICAgICBuZXh0VGFiYmFibGUgPT0gbnVsbCB8fCBuZXh0VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGJlZm9yZTtcbiAgICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRiZWZvcmUgPSBwb3J0YWxDb250ZXh0LmJlZm9yZU91dHNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfcG9ydGFsQ29udGV4dCRiZWZvcmUuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgIWlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCAmJiByZW5kZXJEaXNtaXNzQnV0dG9uKCdzdGFydCcpLCBjaGlsZHJlbiwgcmVuZGVyRGlzbWlzc0J1dHRvbignZW5kJyksIHNob3VsZFJlbmRlckd1YXJkcyAmJiAvKiNfX1BVUkVfXyovanN4KEZvY3VzR3VhcmQsIHtcbiAgICAgIFwiZGF0YS10eXBlXCI6IFwiaW5zaWRlXCIsXG4gICAgICByZWY6IG1lcmdlZEFmdGVyR3VhcmRSZWYsXG4gICAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICAgIGVucXVldWVGb2N1cyhnZXRUYWJiYWJsZUVsZW1lbnRzKClbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBvcnRhbENvbnRleHQgIT0gbnVsbCAmJiBwb3J0YWxDb250ZXh0LnByZXNlcnZlVGFiT3JkZXIgJiYgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSB7XG4gICAgICAgICAgaWYgKGNsb3NlT25Gb2N1c091dCkge1xuICAgICAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZUYWJiYWJsZSA9IGdldFByZXZpb3VzVGFiYmFibGUoZG9tUmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHByZXZUYWJiYWJsZSA9PSBudWxsIHx8IHByZXZUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYWZ0ZXJPO1xuICAgICAgICAgICAgKF9wb3J0YWxDb250ZXh0JGFmdGVyTyA9IHBvcnRhbENvbnRleHQuYWZ0ZXJPdXRzaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX3BvcnRhbENvbnRleHQkYWZ0ZXJPLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSldXG4gIH0pO1xufVxuXG5sZXQgbG9ja0NvdW50ID0gMDtcbmNvbnN0IHNjcm9sbGJhclByb3BlcnR5ID0gJy0tZmxvYXRpbmctdWktc2Nyb2xsYmFyLXdpZHRoJztcbmZ1bmN0aW9uIGVuYWJsZVNjcm9sbExvY2soKSB7XG4gIGNvbnN0IHBsYXRmb3JtID0gZ2V0UGxhdGZvcm0oKTtcbiAgY29uc3QgaXNJT1MgPSAvaVAoaG9uZXxhZHxvZCl8aU9TLy50ZXN0KHBsYXRmb3JtKSB8fFxuICAvLyBpUGFkcyBjYW4gY2xhaW0gdG8gYmUgTWFjSW50ZWxcbiAgcGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMTtcbiAgY29uc3QgYm9keVN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXJcbiAgY29uc3Qgc2Nyb2xsYmFyWCA9IE1hdGgucm91bmQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gIGNvbnN0IHBhZGRpbmdQcm9wID0gc2Nyb2xsYmFyWCA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0JztcbiAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgY29uc3Qgc2Nyb2xsWCA9IGJvZHlTdHlsZS5sZWZ0ID8gcGFyc2VGbG9hdChib2R5U3R5bGUubGVmdCkgOiB3aW5kb3cuc2Nyb2xsWDtcbiAgY29uc3Qgc2Nyb2xsWSA9IGJvZHlTdHlsZS50b3AgPyBwYXJzZUZsb2F0KGJvZHlTdHlsZS50b3ApIDogd2luZG93LnNjcm9sbFk7XG4gIGJvZHlTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICBib2R5U3R5bGUuc2V0UHJvcGVydHkoc2Nyb2xsYmFyUHJvcGVydHksIHNjcm9sbGJhcldpZHRoICsgXCJweFwiKTtcbiAgaWYgKHNjcm9sbGJhcldpZHRoKSB7XG4gICAgYm9keVN0eWxlW3BhZGRpbmdQcm9wXSA9IHNjcm9sbGJhcldpZHRoICsgXCJweFwiO1xuICB9XG5cbiAgLy8gT25seSBpT1MgZG9lc24ndCByZXNwZWN0IGBvdmVyZmxvdzogaGlkZGVuYCBvbiBkb2N1bWVudC5ib2R5LCBhbmQgdGhpc1xuICAvLyB0ZWNobmlxdWUgaGFzIGZld2VyIHNpZGUgZWZmZWN0cy5cbiAgaWYgKGlzSU9TKSB7XG4gICAgdmFyIF93aW5kb3ckdmlzdWFsVmlld3BvciwgX3dpbmRvdyR2aXN1YWxWaWV3cG9yMjtcbiAgICAvLyBpT1MgMTIgZG9lcyBub3Qgc3VwcG9ydCBgdmlzdWFsVmlld3BvcnRgLlxuICAgIGNvbnN0IG9mZnNldExlZnQgPSAoKF93aW5kb3ckdmlzdWFsVmlld3BvciA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3Bvci5vZmZzZXRMZWZ0KSB8fCAwO1xuICAgIGNvbnN0IG9mZnNldFRvcCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3BvcjIub2Zmc2V0VG9wKSB8fCAwO1xuICAgIE9iamVjdC5hc3NpZ24oYm9keVN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIHRvcDogLShzY3JvbGxZIC0gTWF0aC5mbG9vcihvZmZzZXRUb3ApKSArIFwicHhcIixcbiAgICAgIGxlZnQ6IC0oc2Nyb2xsWCAtIE1hdGguZmxvb3Iob2Zmc2V0TGVmdCkpICsgXCJweFwiLFxuICAgICAgcmlnaHQ6ICcwJ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgIFtwYWRkaW5nUHJvcF06ICcnXG4gICAgfSk7XG4gICAgYm9keVN0eWxlLnJlbW92ZVByb3BlcnR5KHNjcm9sbGJhclByb3BlcnR5KTtcbiAgICBpZiAoaXNJT1MpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oYm9keVN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgbGVmdDogJycsXG4gICAgICAgIHJpZ2h0OiAnJ1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsWCwgc2Nyb2xsWSk7XG4gICAgfVxuICB9O1xufVxubGV0IGNsZWFudXAgPSAoKSA9PiB7fTtcblxuLyoqXG4gKiBQcm92aWRlcyBiYXNlIHN0eWxpbmcgZm9yIGEgZml4ZWQgb3ZlcmxheSBlbGVtZW50IHRvIGRpbSBjb250ZW50IG9yIGJsb2NrXG4gKiBwb2ludGVyIGV2ZW50cyBiZWhpbmQgYSBmbG9hdGluZyBlbGVtZW50LlxuICogSXQncyBhIHJlZ3VsYXIgYDxkaXY+YCwgc28gaXQgY2FuIGJlIHN0eWxlZCB2aWEgYW55IENTUyBzb2x1dGlvbiB5b3UgcHJlZmVyLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nT3ZlcmxheVxuICovXG5jb25zdCBGbG9hdGluZ092ZXJsYXkgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGbG9hdGluZ092ZXJsYXkocHJvcHMsIHJlZikge1xuICBjb25zdCB7XG4gICAgbG9ja1Njcm9sbCA9IGZhbHNlLFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbG9ja1Njcm9sbCkgcmV0dXJuO1xuICAgIGxvY2tDb3VudCsrO1xuICAgIGlmIChsb2NrQ291bnQgPT09IDEpIHtcbiAgICAgIGNsZWFudXAgPSBlbmFibGVTY3JvbGxMb2NrKCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsb2NrQ291bnQtLTtcbiAgICAgIGlmIChsb2NrQ291bnQgPT09IDApIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtsb2NrU2Nyb2xsXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByZWY6IHJlZixcbiAgICAuLi5yZXN0LFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICAuLi5yZXN0LnN0eWxlXG4gICAgfVxuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBpc0J1dHRvblRhcmdldChldmVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpICYmIGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJztcbn1cbmZ1bmN0aW9uIGlzQW5jaG9yVGFyZ2V0KGV2ZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdBJztcbn1cbmZ1bmN0aW9uIGlzU3BhY2VJZ25vcmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuLyoqXG4gKiBPcGVucyBvciBjbG9zZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBjbGlja2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpY2tcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpY2soY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZXZlbnQ6IGV2ZW50T3B0aW9uID0gJ2NsaWNrJyxcbiAgICB0b2dnbGUgPSB0cnVlLFxuICAgIGlnbm9yZU1vdXNlID0gZmFsc2UsXG4gICAga2V5Ym9hcmRIYW5kbGVycyA9IHRydWUsXG4gICAgc3RpY2tJZk9wZW4gPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgZGlkS2V5RG93blJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgfSxcbiAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgY29uc3QgcG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZVJlZi5jdXJyZW50O1xuXG4gICAgICAvLyBJZ25vcmUgYWxsIGJ1dHRvbnMgZXhjZXB0IGZvciB0aGUgXCJtYWluXCIgYnV0dG9uLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uXG4gICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgICBpZiAoZXZlbnRPcHRpb24gPT09ICdjbGljaycpIHJldHVybjtcbiAgICAgIGlmIChpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlLCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkgcmV0dXJuO1xuICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlICYmIChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ICYmIHN0aWNrSWZPcGVuID8gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlID09PSAnbW91c2Vkb3duJyA6IHRydWUpKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUHJldmVudCBzdGVhbGluZyBmb2N1cyBmcm9tIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICBjb25zdCBwb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoZXZlbnRPcHRpb24gPT09ICdtb3VzZWRvd24nICYmIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUsIHRydWUpICYmIGlnbm9yZU1vdXNlKSByZXR1cm47XG4gICAgICBpZiAob3BlbiAmJiB0b2dnbGUgJiYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgJiYgc3RpY2tJZk9wZW4gPyBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUgPT09ICdjbGljaycgOiB0cnVlKSkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAha2V5Ym9hcmRIYW5kbGVycyB8fCBpc0J1dHRvblRhcmdldChldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnICYmICFpc1NwYWNlSWdub3JlZChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpZEtleURvd25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBbmNob3JUYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25LZXlVcChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWtleWJvYXJkSGFuZGxlcnMgfHwgaXNCdXR0b25UYXJnZXQoZXZlbnQpIHx8IGlzU3BhY2VJZ25vcmVkKGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnICYmIGRpZEtleURvd25SZWYuY3VycmVudCkge1xuICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSksIFtkYXRhUmVmLCBkb21SZWZlcmVuY2UsIGV2ZW50T3B0aW9uLCBpZ25vcmVNb3VzZSwga2V5Ym9hcmRIYW5kbGVycywgb25PcGVuQ2hhbmdlLCBvcGVuLCBzdGlja0lmT3BlbiwgdG9nZ2xlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZV0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWaXJ0dWFsRWxlbWVudChkb21FbGVtZW50LCBkYXRhKSB7XG4gIGxldCBvZmZzZXRYID0gbnVsbDtcbiAgbGV0IG9mZnNldFkgPSBudWxsO1xuICBsZXQgaXNBdXRvVXBkYXRlRXZlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0RWxlbWVudDogZG9tRWxlbWVudCB8fCB1bmRlZmluZWQsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgdmFyIF9kYXRhJGRhdGFSZWYkY3VycmVudDtcbiAgICAgIGNvbnN0IGRvbVJlY3QgPSAoZG9tRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgfHwge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgaXNYQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3gnIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3knIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUgPSBbJ21vdXNlZW50ZXInLCAnbW91c2Vtb3ZlJ10uaW5jbHVkZXMoKChfZGF0YSRkYXRhUmVmJGN1cnJlbnQgPSBkYXRhLmRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRkYXRhUmVmJGN1cnJlbnQudHlwZSkgfHwgJycpICYmIGRhdGEucG9pbnRlclR5cGUgIT09ICd0b3VjaCc7XG4gICAgICBsZXQgd2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgbGV0IGhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgbGV0IHggPSBkb21SZWN0Lng7XG4gICAgICBsZXQgeSA9IGRvbVJlY3QueTtcbiAgICAgIGlmIChvZmZzZXRYID09IG51bGwgJiYgZGF0YS54ICYmIGlzWEF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WCA9IGRvbVJlY3QueCAtIGRhdGEueDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRZID09IG51bGwgJiYgZGF0YS55ICYmIGlzWUF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WSA9IGRvbVJlY3QueSAtIGRhdGEueTtcbiAgICAgIH1cbiAgICAgIHggLT0gb2Zmc2V0WCB8fCAwO1xuICAgICAgeSAtPSBvZmZzZXRZIHx8IDA7XG4gICAgICB3aWR0aCA9IDA7XG4gICAgICBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc0F1dG9VcGRhdGVFdmVudCB8fCBjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IDA7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiAwO1xuICAgICAgICB4ID0gaXNYQXhpcyAmJiBkYXRhLnggIT0gbnVsbCA/IGRhdGEueCA6IHg7XG4gICAgICAgIHkgPSBpc1lBeGlzICYmIGRhdGEueSAhPSBudWxsID8gZGF0YS55IDogeTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdXRvVXBkYXRlRXZlbnQgJiYgIWNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlKSB7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiBoZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gZGF0YS5heGlzID09PSAneScgPyBkb21SZWN0LndpZHRoIDogd2lkdGg7XG4gICAgICB9XG4gICAgICBpc0F1dG9VcGRhdGVFdmVudCA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICAgICAgbGVmdDogeFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc01vdXNlQmFzZWRFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQgIT0gbnVsbCAmJiBldmVudC5jbGllbnRYICE9IG51bGw7XG59XG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZmxvYXRpbmcgZWxlbWVudCByZWxhdGl2ZSB0byBhIGNsaWVudCBwb2ludCAoaW4gdGhlIHZpZXdwb3J0KSxcbiAqIHN1Y2ggYXMgdGhlIG1vdXNlIHBvc2l0aW9uLiBCeSBkZWZhdWx0LCBpdCBmb2xsb3dzIHRoZSBtb3VzZSBjdXJzb3IuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpZW50UG9pbnRcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpZW50UG9pbnQoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nLFxuICAgICAgZG9tUmVmZXJlbmNlXG4gICAgfSxcbiAgICByZWZzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgYXhpcyA9ICdib3RoJyxcbiAgICB4ID0gbnVsbCxcbiAgICB5ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjbGVhbnVwTGlzdGVuZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtwb2ludGVyVHlwZSwgc2V0UG9pbnRlclR5cGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgW3JlYWN0aXZlLCBzZXRSZWFjdGl2ZV0gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IHVzZUVmZmVjdEV2ZW50KCh4LCB5KSA9PiB7XG4gICAgaWYgKGluaXRpYWxSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBzZXR0aW5nIGlmIHRoZSBvcGVuIGV2ZW50IHdhcyBub3QgYSBtb3VzZS1saWtlIG9uZVxuICAgIC8vIChlLmcuIGZvY3VzIHRvIG9wZW4sIHRoZW4gaG92ZXIgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQpLlxuICAgIC8vIE9ubHkgYXBwbHkgaWYgdGhlIGV2ZW50IGV4aXN0cy5cbiAgICBpZiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiAhaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShjcmVhdGVWaXJ0dWFsRWxlbWVudChkb21SZWZlcmVuY2UsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYXhpcyxcbiAgICAgIGRhdGFSZWYsXG4gICAgICBwb2ludGVyVHlwZVxuICAgIH0pKTtcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSByZXR1cm47XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfSBlbHNlIGlmICghY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY2xlYW51cCwgdGhlcmUncyBubyBsaXN0ZW5lciwgYnV0IHdlIHdhbnQgdG8gZW5zdXJlXG4gICAgICAvLyB3ZSBhZGQgdGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJzb3IgbGFuZGVkIG9uIHRoZSBmbG9hdGluZyBlbGVtZW50IGFuZFxuICAgICAgLy8gdGhlbiBiYWNrIG9uIHRoZSByZWZlcmVuY2UgKGkuZS4gaXQncyBpbnRlcmFjdGl2ZSkuXG4gICAgICBzZXRSZWFjdGl2ZShbXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgcG9pbnRlciBpcyBhIG1vdXNlLWxpa2UgcG9pbnRlciwgd2Ugd2FudCB0byBjb250aW51ZSBmb2xsb3dpbmcgdGhlXG4gIC8vIG1vdXNlIGV2ZW4gaWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgdHJhbnNpdGlvbmluZyBvdXQuIE9uIHRvdWNoXG4gIC8vIGRldmljZXMsIHRoaXMgaXMgdW5kZXNpcmFibGUgYmVjYXVzZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aWxsIG1vdmUgdG9cbiAgLy8gdGhlIGRpc21pc3NhbCB0b3VjaCBwb2ludC5cbiAgY29uc3Qgb3BlbkNoZWNrID0gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSkgPyBmbG9hdGluZyA6IG9wZW47XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIEV4cGxpY2l0bHkgc3BlY2lmaWVkIGB4YC9geWAgY29vcmRpbmF0ZXMgc2hvdWxkbid0IGFkZCBhIGxpc3RlbmVyLlxuICAgIGlmICghb3BlbkNoZWNrIHx8ICFlbmFibGVkIHx8IHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZmxvYXRpbmcpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0JDEoZXZlbnQpO1xuICAgICAgaWYgKCFjb250YWlucyQxKGZsb2F0aW5nLCB0YXJnZXQpKSB7XG4gICAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCB8fCBpc01vdXNlQmFzZWRFdmVudChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSkge1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gY2xlYW51cDtcbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH1cbiAgICByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlKGRvbVJlZmVyZW5jZSk7XG4gIH0sIFtvcGVuQ2hlY2ssIGVuYWJsZWQsIHgsIHksIGZsb2F0aW5nLCBkYXRhUmVmLCByZWZzLCBkb21SZWZlcmVuY2UsIHNldFJlZmVyZW5jZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBhZGRMaXN0ZW5lcigpO1xuICB9LCBbYWRkTGlzdGVuZXIsIHJlYWN0aXZlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVuYWJsZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICBpbml0aWFsUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBmbG9hdGluZ10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCAmJiBvcGVuKSB7XG4gICAgICBpbml0aWFsUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW5dKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0UmVmZXJlbmNlKHgsIHkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHgsIHksIHNldFJlZmVyZW5jZV0pO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzZXRQb2ludGVyVHlwZVJlZihfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICBwb2ludGVyVHlwZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBzZXRQb2ludGVyVHlwZShwb2ludGVyVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyVHlwZVJlZixcbiAgICAgIG9uUG9pbnRlckVudGVyOiBzZXRQb2ludGVyVHlwZVJlZixcbiAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSxcbiAgICAgIG9uTW91c2VFbnRlcjogaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmVcbiAgICB9O1xuICB9LCBbaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmVdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2VcbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlXSk7XG59XG5cbmNvbnN0IGJ1YmJsZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd24nLFxuICBtb3VzZWRvd246ICdvbk1vdXNlRG93bicsXG4gIGNsaWNrOiAnb25DbGljaydcbn07XG5jb25zdCBjYXB0dXJlSGFuZGxlcktleXMgPSB7XG4gIHBvaW50ZXJkb3duOiAnb25Qb2ludGVyRG93bkNhcHR1cmUnLFxuICBtb3VzZWRvd246ICdvbk1vdXNlRG93bkNhcHR1cmUnLFxuICBjbGljazogJ29uQ2xpY2tDYXB0dXJlJ1xufTtcbmNvbnN0IG5vcm1hbGl6ZVByb3AgPSBub3JtYWxpemFibGUgPT4ge1xuICB2YXIgX25vcm1hbGl6YWJsZSRlc2NhcGVLLCBfbm9ybWFsaXphYmxlJG91dHNpZGU7XG4gIHJldHVybiB7XG4gICAgZXNjYXBlS2V5OiB0eXBlb2Ygbm9ybWFsaXphYmxlID09PSAnYm9vbGVhbicgPyBub3JtYWxpemFibGUgOiAoX25vcm1hbGl6YWJsZSRlc2NhcGVLID0gbm9ybWFsaXphYmxlID09IG51bGwgPyB2b2lkIDAgOiBub3JtYWxpemFibGUuZXNjYXBlS2V5KSAhPSBudWxsID8gX25vcm1hbGl6YWJsZSRlc2NhcGVLIDogZmFsc2UsXG4gICAgb3V0c2lkZVByZXNzOiB0eXBlb2Ygbm9ybWFsaXphYmxlID09PSAnYm9vbGVhbicgPyBub3JtYWxpemFibGUgOiAoX25vcm1hbGl6YWJsZSRvdXRzaWRlID0gbm9ybWFsaXphYmxlID09IG51bGwgPyB2b2lkIDAgOiBub3JtYWxpemFibGUub3V0c2lkZVByZXNzKSAhPSBudWxsID8gX25vcm1hbGl6YWJsZSRvdXRzaWRlIDogdHJ1ZVxuICB9O1xufTtcbi8qKlxuICogQ2xvc2VzIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gYSBkaXNtaXNzYWwgaXMgcmVxdWVzdGVkIOKAlCBieSBkZWZhdWx0LCB3aGVuXG4gKiB0aGUgdXNlciBwcmVzc2VzIHRoZSBgZXNjYXBlYCBrZXkgb3Igb3V0c2lkZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VEaXNtaXNzXG4gKi9cbmZ1bmN0aW9uIHVzZURpc21pc3MoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhUmVmXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZXNjYXBlS2V5ID0gdHJ1ZSxcbiAgICBvdXRzaWRlUHJlc3M6IHVuc3RhYmxlX291dHNpZGVQcmVzcyA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIHJlZmVyZW5jZVByZXNzID0gZmFsc2UsXG4gICAgcmVmZXJlbmNlUHJlc3NFdmVudCA9ICdwb2ludGVyZG93bicsXG4gICAgYW5jZXN0b3JTY3JvbGwgPSBmYWxzZSxcbiAgICBidWJibGVzLFxuICAgIGNhcHR1cmVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IG91dHNpZGVQcmVzc0ZuID0gdXNlRWZmZWN0RXZlbnQodHlwZW9mIHVuc3RhYmxlX291dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyA/IHVuc3RhYmxlX291dHNpZGVQcmVzcyA6ICgpID0+IGZhbHNlKTtcbiAgY29uc3Qgb3V0c2lkZVByZXNzID0gdHlwZW9mIHVuc3RhYmxlX291dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyA/IG91dHNpZGVQcmVzc0ZuIDogdW5zdGFibGVfb3V0c2lkZVByZXNzO1xuICBjb25zdCBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHtcbiAgICBlc2NhcGVLZXk6IGVzY2FwZUtleUJ1YmJsZXMsXG4gICAgb3V0c2lkZVByZXNzOiBvdXRzaWRlUHJlc3NCdWJibGVzXG4gIH0gPSBub3JtYWxpemVQcm9wKGJ1YmJsZXMpO1xuICBjb25zdCB7XG4gICAgZXNjYXBlS2V5OiBlc2NhcGVLZXlDYXB0dXJlLFxuICAgIG91dHNpZGVQcmVzczogb3V0c2lkZVByZXNzQ2FwdHVyZVxuICB9ID0gbm9ybWFsaXplUHJvcChjYXB0dXJlKTtcbiAgY29uc3QgaXNDb21wb3NpbmdSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBibHVyVGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigtMSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZGF0YVJlZiRjdXJyZW50JGZsb2E7XG4gICAgaWYgKCFvcGVuIHx8ICFlbmFibGVkIHx8ICFlc2NhcGVLZXkgfHwgZXZlbnQua2V5ICE9PSAnRXNjYXBlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdhaXQgdW50aWwgSU1FIGlzIHNldHRsZWQuIFByZXNzaW5nIGBFc2NhcGVgIHdoaWxlIGNvbXBvc2luZyBzaG91bGRcbiAgICAvLyBjbG9zZSB0aGUgY29tcG9zZSBtZW51LCBidXQgbm90IHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICAgIGlmIChpc0NvbXBvc2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVJZCA9IChfZGF0YVJlZiRjdXJyZW50JGZsb2EgPSBkYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRmbG9hLm5vZGVJZDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRyZWUgPyBnZXROb2RlQ2hpbGRyZW4kMSh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkgOiBbXTtcbiAgICBpZiAoIWVzY2FwZUtleUJ1YmJsZXMpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IHNob3VsZERpc21pc3MgPSB0cnVlO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQ7XG4gICAgICAgICAgaWYgKChfY2hpbGQkY29udGV4dCA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQub3BlbiAmJiAhY2hpbGQuY29udGV4dC5kYXRhUmVmLmN1cnJlbnQuX19lc2NhcGVLZXlCdWJibGVzKSB7XG4gICAgICAgICAgICBzaG91bGREaXNtaXNzID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgaXNSZWFjdEV2ZW50KGV2ZW50KSA/IGV2ZW50Lm5hdGl2ZUV2ZW50IDogZXZlbnQsICdlc2NhcGUta2V5Jyk7XG4gIH0pO1xuICBjb25zdCBjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgdmFyIF9nZXRUYXJnZXQyO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdmFyIF9nZXRUYXJnZXQ7XG4gICAgICBjbG9zZU9uRXNjYXBlS2V5RG93bihldmVudCk7XG4gICAgICAoX2dldFRhcmdldCA9IGdldFRhcmdldCQxKGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDIgPSBnZXRUYXJnZXQkMShldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkZmxvYTI7XG4gICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAvLyB3ZSBjYW4gb25seSBiZSBjb25maWRlbnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLlxuICAgIGNvbnN0IGluc2lkZVJlYWN0VHJlZSA9IGRhdGFSZWYuY3VycmVudC5pbnNpZGVSZWFjdFRyZWU7XG4gICAgZGF0YVJlZi5jdXJyZW50Lmluc2lkZVJlYWN0VHJlZSA9IGZhbHNlO1xuXG4gICAgLy8gV2hlbiBjbGljayBvdXRzaWRlIGlzIGxhenkgKGBjbGlja2AgZXZlbnQpLCBoYW5kbGUgZHJhZ2dpbmcuXG4gICAgLy8gRG9uJ3QgY2xvc2UgaWY6XG4gICAgLy8gLSBUaGUgY2xpY2sgc3RhcnRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgLy8gLSBUaGUgY2xpY2sgZW5kZWQgaW5zaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICAgIGNvbnN0IGVuZGVkT3JTdGFydGVkSW5zaWRlID0gZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudDtcbiAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKG91dHNpZGVQcmVzc0V2ZW50ID09PSAnY2xpY2snICYmIGVuZGVkT3JTdGFydGVkSW5zaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnNpZGVSZWFjdFRyZWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgJiYgIW91dHNpZGVQcmVzcyhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0JDEoZXZlbnQpO1xuICAgIGNvbnN0IGluZXJ0U2VsZWN0b3IgPSBcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgnaW5lcnQnKSArIFwiXVwiO1xuICAgIGNvbnN0IG1hcmtlcnMgPSBnZXREb2N1bWVudCQxKGVsZW1lbnRzLmZsb2F0aW5nKS5xdWVyeVNlbGVjdG9yQWxsKGluZXJ0U2VsZWN0b3IpO1xuICAgIGxldCB0YXJnZXRSb290QW5jZXN0b3IgPSBpc0VsZW1lbnQodGFyZ2V0KSA/IHRhcmdldCA6IG51bGw7XG4gICAgd2hpbGUgKHRhcmdldFJvb3RBbmNlc3RvciAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKHRhcmdldFJvb3RBbmNlc3RvcikpIHtcbiAgICAgIGNvbnN0IG5leHRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKHRhcmdldFJvb3RBbmNlc3Rvcik7XG4gICAgICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5leHRQYXJlbnQpIHx8ICFpc0VsZW1lbnQobmV4dFBhcmVudCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0YXJnZXRSb290QW5jZXN0b3IgPSBuZXh0UGFyZW50O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiBhIHRoaXJkLXBhcnR5IGVsZW1lbnQgaW5qZWN0ZWQgYWZ0ZXIgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCByZW5kZXJlZC5cbiAgICBpZiAobWFya2Vycy5sZW5ndGggJiYgaXNFbGVtZW50KHRhcmdldCkgJiYgIWlzUm9vdEVsZW1lbnQodGFyZ2V0KSAmJlxuICAgIC8vIENsaWNrZWQgb24gYSBkaXJlY3QgYW5jZXN0b3IgKGUuZy4gRmxvYXRpbmdPdmVybGF5KS5cbiAgICAhY29udGFpbnMkMSh0YXJnZXQsIGVsZW1lbnRzLmZsb2F0aW5nKSAmJlxuICAgIC8vIElmIHRoZSB0YXJnZXQgcm9vdCBlbGVtZW50IGNvbnRhaW5zIG5vbmUgb2YgdGhlIG1hcmtlcnMsIHRoZW4gdGhlXG4gICAgLy8gZWxlbWVudCB3YXMgaW5qZWN0ZWQgYWZ0ZXIgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgQXJyYXkuZnJvbShtYXJrZXJzKS5ldmVyeShtYXJrZXIgPT4gIWNvbnRhaW5zJDEodGFyZ2V0Um9vdEFuY2VzdG9yLCBtYXJrZXIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgY29uc3QgbGFzdFRyYXZlcnNhYmxlTm9kZSA9IGlzTGFzdFRyYXZlcnNhYmxlTm9kZSh0YXJnZXQpO1xuICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgICBjb25zdCBzY3JvbGxSZSA9IC9hdXRvfHNjcm9sbC87XG4gICAgICBjb25zdCBpc1Njcm9sbGFibGVYID0gbGFzdFRyYXZlcnNhYmxlTm9kZSB8fCBzY3JvbGxSZS50ZXN0KHN0eWxlLm92ZXJmbG93WCk7XG4gICAgICBjb25zdCBpc1Njcm9sbGFibGVZID0gbGFzdFRyYXZlcnNhYmxlTm9kZSB8fCBzY3JvbGxSZS50ZXN0KHN0eWxlLm92ZXJmbG93WSk7XG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gaXNTY3JvbGxhYmxlWCAmJiB0YXJnZXQuY2xpZW50V2lkdGggPiAwICYmIHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IGNhblNjcm9sbFkgPSBpc1Njcm9sbGFibGVZICYmIHRhcmdldC5jbGllbnRIZWlnaHQgPiAwICYmIHRhcmdldC5zY3JvbGxIZWlnaHQgPiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgaXNSVEwgPSBzdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnO1xuXG4gICAgICAvLyBDaGVjayBjbGljayBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JvbGxiYXIuXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgPGJvZHk+IChvciB3aW5kb3cpXG4gICAgICAvLyBzY3JvbGxiYXIgdG8gdGhlIGxlZnQgc2lkZSwgYnV0IGlzIHZlcnkgcmFyZSBhbmQgaXMgZGlmZmljdWx0IHRvXG4gICAgICAvLyBjaGVjayBmb3IuIFBsdXMsIGZvciBtb2RhbCBkaWFsb2dzIHdpdGggYmFja2Ryb3BzLCBpdCBpcyBtb3JlXG4gICAgICAvLyBpbXBvcnRhbnQgdGhhdCB0aGUgYmFja2Ryb3AgaXMgY2hlY2tlZCBidXQgbm90IHNvIG11Y2ggdGhlIHdpbmRvdy5cbiAgICAgIGNvbnN0IHByZXNzZWRWZXJ0aWNhbFNjcm9sbGJhciA9IGNhblNjcm9sbFkgJiYgKGlzUlRMID8gZXZlbnQub2Zmc2V0WCA8PSB0YXJnZXQub2Zmc2V0V2lkdGggLSB0YXJnZXQuY2xpZW50V2lkdGggOiBldmVudC5vZmZzZXRYID4gdGFyZ2V0LmNsaWVudFdpZHRoKTtcbiAgICAgIGNvbnN0IHByZXNzZWRIb3Jpem9udGFsU2Nyb2xsYmFyID0gY2FuU2Nyb2xsWCAmJiBldmVudC5vZmZzZXRZID4gdGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICAgIGlmIChwcmVzc2VkVmVydGljYWxTY3JvbGxiYXIgfHwgcHJlc3NlZEhvcml6b250YWxTY3JvbGxiYXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSAoX2RhdGFSZWYkY3VycmVudCRmbG9hMiA9IGRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JGZsb2EyLm5vZGVJZDtcbiAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXROb2RlQ2hpbGRyZW4kMSh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZyk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGVsZW1lbnRzLmZsb2F0aW5nKSB8fCBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBlbGVtZW50cy5kb21SZWZlcmVuY2UpIHx8IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Tm9kZUNoaWxkcmVuJDEodHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQyO1xuICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ291dHNpZGUtcHJlc3MnKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0NDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0MztcbiAgICAgIGNsb3NlT25QcmVzc091dHNpZGUoZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQzID0gZ2V0VGFyZ2V0JDEoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQzLnJlbW92ZUV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIChfZ2V0VGFyZ2V0NCA9IGdldFRhcmdldCQxKGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0NC5hZGRFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhUmVmLmN1cnJlbnQuX19lc2NhcGVLZXlCdWJibGVzID0gZXNjYXBlS2V5QnViYmxlcztcbiAgICBkYXRhUmVmLmN1cnJlbnQuX19vdXRzaWRlUHJlc3NCdWJibGVzID0gb3V0c2lkZVByZXNzQnViYmxlcztcbiAgICBsZXQgY29tcG9zaXRpb25UaW1lb3V0ID0gLTE7XG4gICAgZnVuY3Rpb24gb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdhbmNlc3Rvci1zY3JvbGwnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb25TdGFydCgpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY29tcG9zaXRpb25UaW1lb3V0KTtcbiAgICAgIGlzQ29tcG9zaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVDb21wb3NpdGlvbkVuZCgpIHtcbiAgICAgIC8vIFNhZmFyaSBmaXJlcyBgY29tcG9zaXRpb25lbmRgIGJlZm9yZSBga2V5ZG93bmAsIHNvIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgLy8gdW50aWwgdGhlIG5leHQgdGljayB0byBzZXQgYGlzQ29tcG9zaW5nYCB0byBgZmFsc2VgLlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE2NTAwNFxuICAgICAgY29tcG9zaXRpb25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc0NvbXBvc2luZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgLy8gMG1zIG9yIDFtcyBkb24ndCB3b3JrIGluIFNhZmFyaS4gNW1zIGFwcGVhcnMgdG8gY29uc2lzdGVudGx5IHdvcmsuXG4gICAgICAvLyBPbmx5IGFwcGx5IHRvIFdlYktpdCBmb3IgdGhlIHRlc3QgdG8gcmVtYWluIDBtcy5cbiAgICAgIGlzV2ViS2l0KCkgPyA1IDogMCk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50JDEoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgIGlmIChlc2NhcGVLZXkpIHtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgaGFuZGxlQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBoYW5kbGVDb21wb3NpdGlvbkVuZCk7XG4gICAgfVxuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgIGlmIChhbmNlc3RvclNjcm9sbCkge1xuICAgICAgaWYgKGlzRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtZW50cy5yZWZlcmVuY2UpICYmIGVsZW1lbnRzLnJlZmVyZW5jZSAmJiBlbGVtZW50cy5yZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50cy5yZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZpc3VhbCB2aWV3cG9ydCBmb3Igc2Nyb2xsaW5nIGRpc21pc3NhbCAoYWxsb3cgcGluY2gtem9vbSlcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuZmlsdGVyKGFuY2VzdG9yID0+IHtcbiAgICAgIHZhciBfZG9jJGRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIGFuY2VzdG9yICE9PSAoKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jJGRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGVzY2FwZUtleSkge1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGVzY2FwZUtleUNhcHR1cmUgPyBjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUgOiBjbG9zZU9uRXNjYXBlS2V5RG93biwgZXNjYXBlS2V5Q2FwdHVyZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgaGFuZGxlQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIGhhbmRsZUNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIG91dHNpZGVQcmVzcyAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICAgIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChjb21wb3NpdGlvblRpbWVvdXQpO1xuICAgIH07XG4gIH0sIFtkYXRhUmVmLCBlbGVtZW50cywgZXNjYXBlS2V5LCBvdXRzaWRlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50LCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGFuY2VzdG9yU2Nyb2xsLCBlbmFibGVkLCBlc2NhcGVLZXlCdWJibGVzLCBvdXRzaWRlUHJlc3NCdWJibGVzLCBjbG9zZU9uRXNjYXBlS2V5RG93biwgZXNjYXBlS2V5Q2FwdHVyZSwgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlLCBjbG9zZU9uUHJlc3NPdXRzaWRlLCBvdXRzaWRlUHJlc3NDYXB0dXJlLCBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRhdGFSZWYuY3VycmVudC5pbnNpZGVSZWFjdFRyZWUgPSBmYWxzZTtcbiAgfSwgW2RhdGFSZWYsIG91dHNpZGVQcmVzcywgb3V0c2lkZVByZXNzRXZlbnRdKTtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgLi4uKHJlZmVyZW5jZVByZXNzICYmIHtcbiAgICAgIFtidWJibGVIYW5kbGVyS2V5c1tyZWZlcmVuY2VQcmVzc0V2ZW50XV06IGV2ZW50ID0+IHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ3JlZmVyZW5jZS1wcmVzcycpO1xuICAgICAgfSxcbiAgICAgIC4uLihyZWZlcmVuY2VQcmVzc0V2ZW50ICE9PSAnY2xpY2snICYmIHtcbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdyZWZlcmVuY2UtcHJlc3MnKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9KSwgW2Nsb3NlT25Fc2NhcGVLZXlEb3duLCBvbk9wZW5DaGFuZ2UsIHJlZmVyZW5jZVByZXNzLCByZWZlcmVuY2VQcmVzc0V2ZW50XSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uTW91c2VVcCgpIHtcbiAgICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgW2NhcHR1cmVIYW5kbGVyS2V5c1tvdXRzaWRlUHJlc3NFdmVudF1dOiAoKSA9PiB7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaW5zaWRlUmVhY3RUcmVlID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uQmx1ckNhcHR1cmUoKSB7XG4gICAgICBpZiAodHJlZSkgcmV0dXJuO1xuICAgICAgY2xlYXJUaW1lb3V0SWZTZXQoYmx1clRpbWVvdXRSZWYpO1xuICAgICAgZGF0YVJlZi5jdXJyZW50Lmluc2lkZVJlYWN0VHJlZSA9IHRydWU7XG4gICAgICBibHVyVGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQuaW5zaWRlUmVhY3RUcmVlID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBbY2xvc2VPbkVzY2FwZUtleURvd24sIG91dHNpZGVQcmVzc0V2ZW50LCBkYXRhUmVmLCB0cmVlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZSwgZmxvYXRpbmddKTtcbn1cblxuZnVuY3Rpb24gdXNlRmxvYXRpbmdSb290Q29udGV4dChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuID0gZmFsc2UsXG4gICAgb25PcGVuQ2hhbmdlOiBvbk9wZW5DaGFuZ2VQcm9wLFxuICAgIGVsZW1lbnRzOiBlbGVtZW50c1Byb3BcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZsb2F0aW5nSWQgPSB1c2VJZCgpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKHt9KTtcbiAgY29uc3QgW2V2ZW50c10gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVFdmVudEVtaXR0ZXIoKSk7XG4gIGNvbnN0IG5lc3RlZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCkgIT0gbnVsbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG9wdGlvbkRvbVJlZmVyZW5jZSA9IGVsZW1lbnRzUHJvcC5yZWZlcmVuY2U7XG4gICAgaWYgKG9wdGlvbkRvbVJlZmVyZW5jZSAmJiAhaXNFbGVtZW50KG9wdGlvbkRvbVJlZmVyZW5jZSkpIHtcbiAgICAgIGVycm9yKCdDYW5ub3QgcGFzcyBhIHZpcnR1YWwgZWxlbWVudCB0byB0aGUgYGVsZW1lbnRzLnJlZmVyZW5jZWAgb3B0aW9uLCcsICdhcyBpdCBtdXN0IGJlIGEgcmVhbCBET00gZWxlbWVudC4gVXNlIGByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlKClgJywgJ2luc3RlYWQuJyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IFtwb3NpdGlvblJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUoZWxlbWVudHNQcm9wLnJlZmVyZW5jZSk7XG4gIGNvbnN0IG9uT3BlbkNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KChvcGVuLCBldmVudCwgcmVhc29uKSA9PiB7XG4gICAgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA9IG9wZW4gPyBldmVudCA6IHVuZGVmaW5lZDtcbiAgICBldmVudHMuZW1pdCgnb3BlbmNoYW5nZScsIHtcbiAgICAgIG9wZW4sXG4gICAgICBldmVudCxcbiAgICAgIHJlYXNvbixcbiAgICAgIG5lc3RlZFxuICAgIH0pO1xuICAgIG9uT3BlbkNoYW5nZVByb3AgPT0gbnVsbCB8fCBvbk9wZW5DaGFuZ2VQcm9wKG9wZW4sIGV2ZW50LCByZWFzb24pO1xuICB9KTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZVxuICB9KSwgW10pO1xuICBjb25zdCBlbGVtZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2U6IHBvc2l0aW9uUmVmZXJlbmNlIHx8IGVsZW1lbnRzUHJvcC5yZWZlcmVuY2UgfHwgbnVsbCxcbiAgICBmbG9hdGluZzogZWxlbWVudHNQcm9wLmZsb2F0aW5nIHx8IG51bGwsXG4gICAgZG9tUmVmZXJlbmNlOiBlbGVtZW50c1Byb3AucmVmZXJlbmNlXG4gIH0pLCBbcG9zaXRpb25SZWZlcmVuY2UsIGVsZW1lbnRzUHJvcC5yZWZlcmVuY2UsIGVsZW1lbnRzUHJvcC5mbG9hdGluZ10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGRhdGFSZWYsXG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZWxlbWVudHMsXG4gICAgZXZlbnRzLFxuICAgIGZsb2F0aW5nSWQsXG4gICAgcmVmc1xuICB9KSwgW29wZW4sIG9uT3BlbkNoYW5nZSwgZWxlbWVudHMsIGV2ZW50cywgZmxvYXRpbmdJZCwgcmVmc10pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYSBmbG9hdGluZyBlbGVtZW50IGFuZCBjb250ZXh0IHRvIGFkZCBpbnRlcmFjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRmxvYXRpbmdcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmcob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBub2RlSWRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGludGVybmFsUm9vdENvbnRleHQgPSB1c2VGbG9hdGluZ1Jvb3RDb250ZXh0KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2U6IG51bGwsXG4gICAgICBmbG9hdGluZzogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnMuZWxlbWVudHNcbiAgICB9XG4gIH0pO1xuICBjb25zdCByb290Q29udGV4dCA9IG9wdGlvbnMucm9vdENvbnRleHQgfHwgaW50ZXJuYWxSb290Q29udGV4dDtcbiAgY29uc3QgY29tcHV0ZWRFbGVtZW50cyA9IHJvb3RDb250ZXh0LmVsZW1lbnRzO1xuICBjb25zdCBbX2RvbVJlZmVyZW5jZSwgc2V0RG9tUmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcG9zaXRpb25SZWZlcmVuY2UsIF9zZXRQb3NpdGlvblJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgb3B0aW9uRG9tUmVmZXJlbmNlID0gY29tcHV0ZWRFbGVtZW50cyA9PSBudWxsID8gdm9pZCAwIDogY29tcHV0ZWRFbGVtZW50cy5kb21SZWZlcmVuY2U7XG4gIGNvbnN0IGRvbVJlZmVyZW5jZSA9IG9wdGlvbkRvbVJlZmVyZW5jZSB8fCBfZG9tUmVmZXJlbmNlO1xuICBjb25zdCBkb21SZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZG9tUmVmZXJlbmNlKSB7XG4gICAgICBkb21SZWZlcmVuY2VSZWYuY3VycmVudCA9IGRvbVJlZmVyZW5jZTtcbiAgICB9XG4gIH0sIFtkb21SZWZlcmVuY2VdKTtcbiAgY29uc3QgcG9zaXRpb24gPSB1c2VGbG9hdGluZyQxKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICAuLi5jb21wdXRlZEVsZW1lbnRzLFxuICAgICAgLi4uKHBvc2l0aW9uUmVmZXJlbmNlICYmIHtcbiAgICAgICAgcmVmZXJlbmNlOiBwb3NpdGlvblJlZmVyZW5jZVxuICAgICAgfSlcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbnN0IGNvbXB1dGVkUG9zaXRpb25SZWZlcmVuY2UgPSBpc0VsZW1lbnQobm9kZSkgPyB7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRDbGllbnRSZWN0czogKCkgPT4gbm9kZS5nZXRDbGllbnRSZWN0cygpLFxuICAgICAgY29udGV4dEVsZW1lbnQ6IG5vZGVcbiAgICB9IDogbm9kZTtcbiAgICAvLyBTdG9yZSB0aGUgcG9zaXRpb25SZWZlcmVuY2UgaW4gc3RhdGUgaWYgdGhlIERPTSByZWZlcmVuY2UgaXMgc3BlY2lmaWVkIGV4dGVybmFsbHkgdmlhIHRoZVxuICAgIC8vIGBlbGVtZW50cy5yZWZlcmVuY2VgIG9wdGlvbi4gVGhpcyBlbnN1cmVzIHRoYXQgaXQgd29uJ3QgYmUgb3ZlcnJpZGRlbiBvbiBmdXR1cmUgcmVuZGVycy5cbiAgICBfc2V0UG9zaXRpb25SZWZlcmVuY2UoY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSk7XG4gICAgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2UoY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSk7XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChpc0VsZW1lbnQobm9kZSkgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgc2V0RG9tUmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciBwYXNzaW5nIGEgdmlydHVhbCBlbGVtZW50IHRvIGByZWZlcmVuY2VgXG4gICAgLy8gYWZ0ZXIgaXQgaGFzIHNldCB0aGUgRE9NIHJlZmVyZW5jZS5cbiAgICBpZiAoaXNFbGVtZW50KHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQpIHx8IHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQgPT09IG51bGwgfHxcbiAgICAvLyBEb24ndCBhbGxvdyBzZXR0aW5nIHZpcnR1YWwgZWxlbWVudHMgdXNpbmcgdGhlIG9sZCB0ZWNobmlxdWUgYmFjayB0b1xuICAgIC8vIGBudWxsYCB0byBzdXBwb3J0IGBwb3NpdGlvblJlZmVyZW5jZWAgKyBhbiB1bnN0YWJsZSBgcmVmZXJlbmNlYFxuICAgIC8vIGNhbGxiYWNrIHJlZi5cbiAgICBub2RlICE9PSBudWxsICYmICFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5yZWZzLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZSxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVJlZlxuICB9KSwgW3Bvc2l0aW9uLnJlZnMsIHNldFJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24uZWxlbWVudHMsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VcbiAgfSksIFtwb3NpdGlvbi5lbGVtZW50cywgZG9tUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgLi4ucm9vdENvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBub2RlSWRcbiAgfSksIFtwb3NpdGlvbiwgcmVmcywgZWxlbWVudHMsIG5vZGVJZCwgcm9vdENvbnRleHRdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByb290Q29udGV4dC5kYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCBub2RlID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBub2RlSWQpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgY29udGV4dCxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzXG4gIH0pLCBbcG9zaXRpb24sIHJlZnMsIGVsZW1lbnRzLCBjb250ZXh0XSk7XG59XG5cbmZ1bmN0aW9uIGlzTWFjU2FmYXJpKCkge1xuICByZXR1cm4gaXNNYWMoKSAmJiBpc1NhZmFyaSgpO1xufVxuLyoqXG4gKiBPcGVucyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGlsZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaGFzIGZvY3VzLCBsaWtlIENTU1xuICogYDpmb2N1c2AuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRm9jdXNcbiAqL1xuZnVuY3Rpb24gdXNlRm9jdXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBldmVudHMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHZpc2libGVPbmx5ID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJsb2NrRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3Qga2V5Ym9hcmRNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudHMuZG9tUmVmZXJlbmNlKTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2Ugd2FzIGZvY3VzZWQgYW5kIHRoZSB1c2VyIGxlZnQgdGhlIHRhYi93aW5kb3csIGFuZCB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IHdhcyBub3Qgb3BlbiwgdGhlIGZvY3VzIHNob3VsZCBiZSBibG9ja2VkIHdoZW4gdGhleVxuICAgIC8vIHJldHVybiB0byB0aGUgdGFiL3dpbmRvdy5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoIW9wZW4gJiYgaXNIVE1MRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpICYmIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSA9PT0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudCQxKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkpKSB7XG4gICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bigpIHtcbiAgICAgIGtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oKSB7XG4gICAgICBrZXlib2FyZE1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIGlmIChpc01hY1NhZmFyaSgpKSB7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcbiAgICAgIGlmIChpc01hY1NhZmFyaSgpKSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VsZW1lbnRzLmRvbVJlZmVyZW5jZSwgb3BlbiwgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICByZWFzb25cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ3JlZmVyZW5jZS1wcmVzcycgfHwgcmVhc29uID09PSAnZXNjYXBlLWtleScpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2V2ZW50cywgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0UmVmKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIGlmIChibG9ja0ZvY3VzUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldCQxKGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGlmICh2aXNpYmxlT25seSAmJiBpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAvLyBTYWZhcmkgZmFpbHMgdG8gbWF0Y2ggYDpmb2N1cy12aXNpYmxlYCBpZiBmb2N1cyB3YXMgaW5pdGlhbGx5XG4gICAgICAgIC8vIG91dHNpZGUgdGhlIGRvY3VtZW50LlxuICAgICAgICBpZiAoaXNNYWNTYWZhcmkoKSAmJiAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgIGlmICgha2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ICYmICFpc1R5cGVhYmxlRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFtYXRjaGVzRm9jdXNWaXNpYmxlKHRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgfSxcbiAgICBvbkJsdXIoZXZlbnQpIHtcbiAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBjb25zdCBuYXRpdmVFdmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuXG4gICAgICAvLyBIaXQgdGhlIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50IHBvcnRhbCBndWFyZC4gRm9jdXMgd2lsbCBiZVxuICAgICAgLy8gbW92ZWQgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbW1lZGlhdGVseSBhZnRlci5cbiAgICAgIGNvbnN0IG1vdmVkVG9Gb2N1c0d1YXJkID0gaXNFbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKGNyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKSkgJiYgcmVsYXRlZFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpID09PSAnb3V0c2lkZSc7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSB3aW5kb3cgYmx1ciBsaXN0ZW5lciB0byBmaXJlLlxuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRmbG9hO1xuICAgICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlID8gZWxlbWVudHMuZG9tUmVmZXJlbmNlLm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudCk7XG5cbiAgICAgICAgLy8gRm9jdXMgbGVmdCB0aGUgcGFnZSwga2VlcCBpdCBvcGVuLlxuICAgICAgICBpZiAoIXJlbGF0ZWRUYXJnZXQgJiYgYWN0aXZlRWwgPT09IGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFdoZW4gZm9jdXNpbmcgdGhlIHJlZmVyZW5jZSBlbGVtZW50IChlLmcuIHJlZ3VsYXIgY2xpY2spLCB0aGVuXG4gICAgICAgIC8vIGNsaWNraW5nIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQsIHByZXZlbnQgaXQgZnJvbSBoaWRpbmcuXG4gICAgICAgIC8vIE5vdGU6IGl0IG11c3QgYmUgZm9jdXNhYmxlLCBlLmcuIGB0YWJpbmRleD1cIi0xXCJgLlxuICAgICAgICAvLyBXZSBjYW4gbm90IHJlbHkgb24gcmVsYXRlZFRhcmdldCB0byBwb2ludCB0byB0aGUgY29ycmVjdCBlbGVtZW50XG4gICAgICAgIC8vIGFzIGl0IHdpbGwgb25seSBwb2ludCB0byB0aGUgc2hhZG93IGhvc3Qgb2YgdGhlIG5ld2x5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAvLyBhbmQgbm90IHRoZSBlbGVtZW50IHRoYXQgYWN0dWFsbHkgaGFzIHJlY2VpdmVkIGZvY3VzIGlmIGl0IGlzIGxvY2F0ZWRcbiAgICAgICAgLy8gaW5zaWRlIGEgc2hhZG93IHJvb3QuXG4gICAgICAgIGlmIChjb250YWlucyQxKChfZGF0YVJlZiRjdXJyZW50JGZsb2EgPSBkYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRmbG9hLnJlZnMuZmxvYXRpbmcuY3VycmVudCwgYWN0aXZlRWwpIHx8IGNvbnRhaW5zJDEoZWxlbWVudHMuZG9tUmVmZXJlbmNlLCBhY3RpdmVFbCkgfHwgbW92ZWRUb0ZvY3VzR3VhcmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBuYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBbZGF0YVJlZiwgZWxlbWVudHMuZG9tUmVmZXJlbmNlLCBvbk9wZW5DaGFuZ2UsIHZpc2libGVPbmx5XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZV0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCBlbGVtZW50S2V5KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaXNJdGVtID0gZWxlbWVudEtleSA9PT0gJ2l0ZW0nO1xuICBsZXQgZG9tVXNlclByb3BzID0gdXNlclByb3BzO1xuICBpZiAoaXNJdGVtICYmIHVzZXJQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIFtBQ1RJVkVfS0VZXTogXyxcbiAgICAgIFtTRUxFQ1RFRF9LRVldOiBfXyxcbiAgICAgIC4uLnZhbGlkUHJvcHNcbiAgICB9ID0gdXNlclByb3BzO1xuICAgIGRvbVVzZXJQcm9wcyA9IHZhbGlkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi4oZWxlbWVudEtleSA9PT0gJ2Zsb2F0aW5nJyAmJiB7XG4gICAgICB0YWJJbmRleDogLTEsXG4gICAgICBbRk9DVVNBQkxFX0FUVFJJQlVURV06ICcnXG4gICAgfSksXG4gICAgLi4uZG9tVXNlclByb3BzLFxuICAgIC4uLnByb3BzTGlzdC5tYXAodmFsdWUgPT4ge1xuICAgICAgY29uc3QgcHJvcHNPckdldFByb3BzID0gdmFsdWUgPyB2YWx1ZVtlbGVtZW50S2V5XSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHByb3BzT3JHZXRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXNlclByb3BzID8gcHJvcHNPckdldFByb3BzKHVzZXJQcm9wcykgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BzT3JHZXRQcm9wcztcbiAgICB9KS5jb25jYXQodXNlclByb3BzKS5yZWR1Y2UoKGFjYywgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgaWYgKGlzSXRlbSAmJiBbQUNUSVZFX0tFWSwgU0VMRUNURURfS0VZXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAgICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgfHwgX21hcCRnZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKF9tYXAkZ2V0MiA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5tYXAoZm4gPT4gZm4oLi4uYXJncykpLmZpbmQodmFsID0+IHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfTtcbn1cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGludGVyYWN0aW9uIGhvb2tzJyBwcm9wcyBpbnRvIHByb3AgZ2V0dGVycywgYWxsb3dpbmdcbiAqIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zIHRvIGJlIGNvbXBvc2VkIHRvZ2V0aGVyIHdpdGhvdXQgb3ZlcndyaXRpbmcgb25lXG4gKiBhbm90aGVyLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUludGVyYWN0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VJbnRlcmFjdGlvbnMocHJvcHNMaXN0KSB7XG4gIGlmIChwcm9wc0xpc3QgPT09IHZvaWQgMCkge1xuICAgIHByb3BzTGlzdCA9IFtdO1xuICB9XG4gIGNvbnN0IHJlZmVyZW5jZURlcHMgPSBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5yZWZlcmVuY2UpO1xuICBjb25zdCBmbG9hdGluZ0RlcHMgPSBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5mbG9hdGluZyk7XG4gIGNvbnN0IGl0ZW1EZXBzID0gcHJvcHNMaXN0Lm1hcChrZXkgPT4ga2V5ID09IG51bGwgPyB2b2lkIDAgOiBrZXkuaXRlbSk7XG4gIGNvbnN0IGdldFJlZmVyZW5jZVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdyZWZlcmVuY2UnKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICByZWZlcmVuY2VEZXBzKTtcbiAgY29uc3QgZ2V0RmxvYXRpbmdQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnZmxvYXRpbmcnKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBmbG9hdGluZ0RlcHMpO1xuICBjb25zdCBnZXRJdGVtUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ2l0ZW0nKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBpdGVtRGVwcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59XG5cbmNvbnN0IEVTQ0FQRSA9ICdFc2NhcGUnO1xuZnVuY3Rpb24gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKSB7XG4gIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICByZXR1cm4gdmVydGljYWw7XG4gICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICByZXR1cm4gaG9yaXpvbnRhbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZlcnRpY2FsIHx8IGhvcml6b250YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTWFpbk9yaWVudGF0aW9uS2V5KGtleSwgb3JpZW50YXRpb24pIHtcbiAgY29uc3QgdmVydGljYWwgPSBrZXkgPT09IEFSUk9XX1VQIHx8IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfTEVGVCB8fCBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICBjb25zdCBob3Jpem9udGFsID0gcnRsID8ga2V5ID09PSBBUlJPV19MRUZUIDoga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkgfHwga2V5ID09PSAnRW50ZXInIHx8IGtleSA9PT0gJyAnIHx8IGtleSA9PT0gJyc7XG59XG5mdW5jdGlvbiBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0RPV047XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsLCBjb2xzKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0gcnRsID8ga2V5ID09PSBBUlJPV19SSUdIVCA6IGtleSA9PT0gQVJST1dfTEVGVDtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfVVA7XG4gIGlmIChvcmllbnRhdGlvbiA9PT0gJ2JvdGgnIHx8IG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgY29scyAmJiBjb2xzID4gMSkge1xuICAgIHJldHVybiBrZXkgPT09IEVTQ0FQRTtcbiAgfVxuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbi8qKlxuICogQWRkcyBhcnJvdyBrZXktYmFzZWQgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMsIGVpdGhlciB1c2luZyByZWFsIERPTVxuICogZm9jdXMgb3IgdmlydHVhbCBmb2N1cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VMaXN0TmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdJZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGxpc3RSZWYsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZTogdW5zdGFibGVfb25OYXZpZ2F0ZSA9ICgpID0+IHt9LFxuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsLFxuICAgIGFsbG93RXNjYXBlID0gZmFsc2UsXG4gICAgbG9vcCA9IGZhbHNlLFxuICAgIG5lc3RlZCA9IGZhbHNlLFxuICAgIHJ0bCA9IGZhbHNlLFxuICAgIHZpcnR1YWwgPSBmYWxzZSxcbiAgICBmb2N1c0l0ZW1Pbk9wZW4gPSAnYXV0bycsXG4gICAgZm9jdXNJdGVtT25Ib3ZlciA9IHRydWUsXG4gICAgb3Blbk9uQXJyb3dLZXlEb3duID0gdHJ1ZSxcbiAgICBkaXNhYmxlZEluZGljZXMgPSB1bmRlZmluZWQsXG4gICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnLFxuICAgIHBhcmVudE9yaWVudGF0aW9uLFxuICAgIGNvbHMgPSAxLFxuICAgIHNjcm9sbEl0ZW1JbnRvVmlldyA9IHRydWUsXG4gICAgdmlydHVhbEl0ZW1SZWYsXG4gICAgaXRlbVNpemVzLFxuICAgIGRlbnNlID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGFsbG93RXNjYXBlKSB7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgd2FybignYHVzZUxpc3ROYXZpZ2F0aW9uYCBsb29waW5nIG11c3QgYmUgZW5hYmxlZCB0byBhbGxvdyBlc2NhcGluZy4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICB3YXJuKCdgdXNlTGlzdE5hdmlnYXRpb25gIG11c3QgYmUgdmlydHVhbCB0byBhbGxvdyBlc2NhcGluZy4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIGNvbHMgPiAxKSB7XG4gICAgICB3YXJuKCdJbiBncmlkIGxpc3QgbmF2aWdhdGlvbiBtb2RlIChgY29sc2AgPiAxKSwgdGhlIGBvcmllbnRhdGlvbmAgc2hvdWxkJywgJ2JlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcImJvdGhcIi4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmxvYXRpbmdGb2N1c0VsZW1lbnQgPSBnZXRGbG9hdGluZ0ZvY3VzRWxlbWVudChlbGVtZW50cy5mbG9hdGluZyk7XG4gIGNvbnN0IGZsb2F0aW5nRm9jdXNFbGVtZW50UmVmID0gdXNlTGF0ZXN0UmVmKGZsb2F0aW5nRm9jdXNFbGVtZW50KTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29udGV4dC5kYXRhUmVmLmN1cnJlbnQub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgfSwgW2NvbnRleHQsIG9yaWVudGF0aW9uXSk7XG4gIGNvbnN0IG9uTmF2aWdhdGUgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgdW5zdGFibGVfb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50ID09PSAtMSA/IG51bGwgOiBpbmRleFJlZi5jdXJyZW50KTtcbiAgfSk7XG4gIGNvbnN0IHR5cGVhYmxlQ29tYm9ib3hSZWZlcmVuY2UgPSBpc1R5cGVhYmxlQ29tYm9ib3goZWxlbWVudHMuZG9tUmVmZXJlbmNlKTtcbiAgY29uc3QgZm9jdXNJdGVtT25PcGVuUmVmID0gUmVhY3QudXNlUmVmKGZvY3VzSXRlbU9uT3Blbik7XG4gIGNvbnN0IGluZGV4UmVmID0gUmVhY3QudXNlUmVmKHNlbGVjdGVkSW5kZXggIT0gbnVsbCA/IHNlbGVjdGVkSW5kZXggOiAtMSk7XG4gIGNvbnN0IGtleVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNQb2ludGVyTW9kYWxpdHlSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IHByZXZpb3VzT25OYXZpZ2F0ZVJlZiA9IFJlYWN0LnVzZVJlZihvbk5hdmlnYXRlKTtcbiAgY29uc3QgcHJldmlvdXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKCEhZWxlbWVudHMuZmxvYXRpbmcpO1xuICBjb25zdCBwcmV2aW91c09wZW5SZWYgPSBSZWFjdC51c2VSZWYob3Blbik7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3Qgc2VsZWN0ZWRJbmRleFJlZiA9IHVzZUxhdGVzdFJlZihzZWxlY3RlZEluZGV4KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlydHVhbElkLCBzZXRWaXJ0dWFsSWRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgZm9jdXNJdGVtID0gdXNlRWZmZWN0RXZlbnQoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHJ1bkZvY3VzKGl0ZW0pIHtcbiAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgIHZhciBfaXRlbSRpZDtcbiAgICAgICAgaWYgKChfaXRlbSRpZCA9IGl0ZW0uaWQpICE9IG51bGwgJiYgX2l0ZW0kaWQuZW5kc1dpdGgoJy1mdWktb3B0aW9uJykpIHtcbiAgICAgICAgICBpdGVtLmlkID0gZmxvYXRpbmdJZCArIFwiLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc2xpY2UoMiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHNldEFjdGl2ZUlkKGl0ZW0uaWQpO1xuICAgICAgICB0cmVlID09IG51bGwgfHwgdHJlZS5ldmVudHMuZW1pdCgndmlydHVhbGZvY3VzJywgaXRlbSk7XG4gICAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoaXRlbSwge1xuICAgICAgICAgIHN5bmM6IGZvcmNlU3luY0ZvY3VzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbEl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhSZWYuY3VycmVudF07XG4gICAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlldyA9IGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudDtcbiAgICBpZiAoaW5pdGlhbEl0ZW0pIHtcbiAgICAgIHJ1bkZvY3VzKGluaXRpYWxJdGVtKTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZWR1bGVyID0gZm9yY2VTeW5jRm9jdXNSZWYuY3VycmVudCA/IHYgPT4gdigpIDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIHNjaGVkdWxlcigoKSA9PiB7XG4gICAgICBjb25zdCB3YWl0ZWRJdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4UmVmLmN1cnJlbnRdIHx8IGluaXRpYWxJdGVtO1xuICAgICAgaWYgKCF3YWl0ZWRJdGVtKSByZXR1cm47XG4gICAgICBpZiAoIWluaXRpYWxJdGVtKSB7XG4gICAgICAgIHJ1bkZvY3VzKHdhaXRlZEl0ZW0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsSW50b1ZpZXdPcHRpb25zID0gc2Nyb2xsSXRlbUludG9WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyAmJiBpdGVtICYmIChmb3JjZVNjcm9sbEludG9WaWV3IHx8ICFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChzaG91bGRTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAvLyBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgYC5zY3JvbGxJbnRvVmlldygpYCBidXQgaXQncyB3aWRlbHkgc3VwcG9ydGVkXG4gICAgICAgIC8vIGJ5IGFsbCBicm93c2Vycy5cbiAgICAgICAgd2FpdGVkSXRlbS5zY3JvbGxJbnRvVmlldyA9PSBudWxsIHx8IHdhaXRlZEl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKG9wZW4gJiYgZWxlbWVudHMuZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgcG9pbnRlciBtb2RhbGl0eSwgd2Ugd2FudCB0byBlbnN1cmUgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gY29tZXMgaW50byB2aWV3IHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbmVkLlxuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHRoZSB1c2VyIGNhbiBzcGVjaWZ5IGBvbk5hdmlnYXRlYCBjb25kaXRpb25hbGx5XG4gICAgICAvLyAob25OYXZpZ2F0ZTogb3BlbiA/IHNldEFjdGl2ZUluZGV4IDogc2V0U2VsZWN0ZWRJbmRleCksXG4gICAgICAvLyB3ZSBzdG9yZSBhbmQgY2FsbCB0aGUgcHJldmlvdXMgZnVuY3Rpb24uXG4gICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudCgpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBzZWxlY3RlZEluZGV4LCBvbk5hdmlnYXRlXSk7XG5cbiAgLy8gU3luYyBgYWN0aXZlSW5kZXhgIHRvIGJlIHRoZSBmb2N1c2VkIGl0ZW0gd2hpbGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAgLy8gb3Blbi5cbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSByZXR1cm47XG4gICAgaWYgKGFjdGl2ZUluZGV4ID09IG51bGwpIHtcbiAgICAgIGZvcmNlU3luY0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChzZWxlY3RlZEluZGV4UmVmLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdhcyBvcGVuIChlLmcuIHRoZSBsaXN0IGNoYW5nZWQpLlxuICAgICAgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgZm9jdXNJdGVtKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWwgc3luYy5cbiAgICAgIGlmICgoIXByZXZpb3VzT3BlblJlZi5jdXJyZW50IHx8ICFwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkgJiYgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgKGtleVJlZi5jdXJyZW50ICE9IG51bGwgfHwgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPT09IHRydWUgJiYga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgbGV0IHJ1bnMgPSAwO1xuICAgICAgICBjb25zdCB3YWl0Rm9yTGlzdFBvcHVsYXRlZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAobGlzdFJlZi5jdXJyZW50WzBdID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGxldHRpbmcgdGhlIGJyb3dzZXIgcGFpbnQgaWYgcG9zc2libGUgb24gdGhlIGZpcnN0IHRyeSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgckFGLiBEb24ndCB0cnkgbW9yZSB0aGFuIHR3aWNlLCBzaW5jZSBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIGlzIHdyb25nIG90aGVyd2lzZS5cbiAgICAgICAgICAgIGlmIChydW5zIDwgMikge1xuICAgICAgICAgICAgICBjb25zdCBzY2hlZHVsZXIgPSBydW5zID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogcXVldWVNaWNyb3Rhc2s7XG4gICAgICAgICAgICAgIHNjaGVkdWxlcih3YWl0Rm9yTGlzdFBvcHVsYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBrZXlSZWYuY3VycmVudCA9PSBudWxsIHx8IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoa2V5UmVmLmN1cnJlbnQsIG9yaWVudGF0aW9uLCBydGwpIHx8IG5lc3RlZCA/IGdldE1pbkxpc3RJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCkgOiBnZXRNYXhMaXN0SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2FpdEZvckxpc3RQb3B1bGF0ZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc0luZGV4T3V0T2ZMaXN0Qm91bmRzKGxpc3RSZWYsIGFjdGl2ZUluZGV4KSkge1xuICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGFjdGl2ZUluZGV4O1xuICAgICAgZm9jdXNJdGVtKCk7XG4gICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBlbGVtZW50cy5mbG9hdGluZywgYWN0aXZlSW5kZXgsIHNlbGVjdGVkSW5kZXhSZWYsIG5lc3RlZCwgbGlzdFJlZiwgb3JpZW50YXRpb24sIHJ0bCwgb25OYXZpZ2F0ZSwgZm9jdXNJdGVtLCBkaXNhYmxlZEluZGljZXNSZWZdKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhcmVudCBmbG9hdGluZyBlbGVtZW50IGhhcyBmb2N1cyB3aGVuIGEgbmVzdGVkIGNoaWxkIGNsb3Nlc1xuICAvLyB0byBhbGxvdyBhcnJvdyBrZXkgbmF2aWdhdGlvbiB0byB3b3JrIGFmdGVyIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgY2hpbGQuXG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9ub2RlcyRmaW5kO1xuICAgIGlmICghZW5hYmxlZCB8fCBlbGVtZW50cy5mbG9hdGluZyB8fCAhdHJlZSB8fCB2aXJ0dWFsIHx8ICFwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IHRyZWUubm9kZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYXJlbnQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfbm9kZXMkZmluZCA9IF9ub2RlcyRmaW5kLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZXMkZmluZC5lbGVtZW50cy5mbG9hdGluZztcbiAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQkMShlbGVtZW50cy5mbG9hdGluZykpO1xuICAgIGNvbnN0IHRyZWVDb250YWluc0FjdGl2ZUVsID0gbm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGV4dCAmJiBjb250YWlucyQxKG5vZGUuY29udGV4dC5lbGVtZW50cy5mbG9hdGluZywgYWN0aXZlRWwpKTtcbiAgICBpZiAocGFyZW50ICYmICF0cmVlQ29udGFpbnNBY3RpdmVFbCAmJiBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KSB7XG4gICAgICBwYXJlbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBlbGVtZW50cy5mbG9hdGluZywgdHJlZSwgcGFyZW50SWQsIHZpcnR1YWxdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIXRyZWUpIHJldHVybjtcbiAgICBpZiAoIXZpcnR1YWwpIHJldHVybjtcbiAgICBpZiAocGFyZW50SWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBoYW5kbGVWaXJ0dWFsRm9jdXMoaXRlbSkge1xuICAgICAgc2V0VmlydHVhbElkKGl0ZW0uaWQpO1xuICAgICAgaWYgKHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmVlLmV2ZW50cy5vbigndmlydHVhbGZvY3VzJywgaGFuZGxlVmlydHVhbEZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZS5ldmVudHMub2ZmKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0cmVlLCB2aXJ0dWFsLCBwYXJlbnRJZCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudCA9IG9uTmF2aWdhdGU7XG4gICAgcHJldmlvdXNPcGVuUmVmLmN1cnJlbnQgPSBvcGVuO1xuICAgIHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50ID0gISFlbGVtZW50cy5mbG9hdGluZztcbiAgfSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IGZvY3VzSXRlbU9uT3BlbjtcbiAgICB9XG4gIH0sIFtvcGVuLCBmb2N1c0l0ZW1Pbk9wZW5dKTtcbiAgY29uc3QgaGFzQWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCAhPSBudWxsO1xuICBjb25zdCBpdGVtID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCkge1xuICAgICAgaWYgKCFsYXRlc3RPcGVuUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdFJlZi5jdXJyZW50LmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4UmVmLmN1cnJlbnQgIT09IGluZGV4KSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIG9uRm9jdXMoX3JlZikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIGZvcmNlU3luY0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KTtcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiBfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIFNhZmFyaVxuICAgICAgLi4uKGZvY3VzSXRlbU9uSG92ZXIgJiYge1xuICAgICAgICBvbk1vdXNlTW92ZShfcmVmMykge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICAgIGZvcmNlU3luY0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJMZWF2ZShfcmVmNCkge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVxuICAgICAgICAgIH0gPSBfcmVmNDtcbiAgICAgICAgICBpZiAoIWlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yY2VTeW5jRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIG9uTmF2aWdhdGUoKTtcbiAgICAgICAgICBpZiAoIXZpcnR1YWwpIHtcbiAgICAgICAgICAgIHZhciBfZmxvYXRpbmdGb2N1c0VsZW1lbnQ7XG4gICAgICAgICAgICAoX2Zsb2F0aW5nRm9jdXNFbGVtZW50ID0gZmxvYXRpbmdGb2N1c0VsZW1lbnRSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfZmxvYXRpbmdGb2N1c0VsZW1lbnQuZm9jdXMoe1xuICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0sIFtsYXRlc3RPcGVuUmVmLCBmbG9hdGluZ0ZvY3VzRWxlbWVudFJlZiwgZm9jdXNJdGVtT25Ib3ZlciwgbGlzdFJlZiwgb25OYXZpZ2F0ZSwgdmlydHVhbF0pO1xuICBjb25zdCBnZXRQYXJlbnRPcmllbnRhdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB2YXIgX3RyZWUkbm9kZXNSZWYkY3VycmVuO1xuICAgIHJldHVybiBwYXJlbnRPcmllbnRhdGlvbiAhPSBudWxsID8gcGFyZW50T3JpZW50YXRpb24gOiB0cmVlID09IG51bGwgfHwgKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY29udGV4dCkgPT0gbnVsbCB8fCAoX3RyZWUkbm9kZXNSZWYkY3VycmVuID0gX3RyZWUkbm9kZXNSZWYkY3VycmVuLmRhdGFSZWYpID09IG51bGwgPyB2b2lkIDAgOiBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY3VycmVudC5vcmllbnRhdGlvbjtcbiAgfSwgW3BhcmVudElkLCB0cmVlLCBwYXJlbnRPcmllbnRhdGlvbl0pO1xuICBjb25zdCBjb21tb25PbktleURvd24gPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIGZvcmNlU3luY0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgLy8gV2hlbiBjb21wb3NpbmcgYSBjaGFyYWN0ZXIsIENocm9tZSBmaXJlcyBBcnJvd0Rvd24gdHdpY2UuIEZpcmVmb3gvU2FmYXJpXG4gICAgLy8gZG9uJ3QgYXBwZWFyIHRvIHN1ZmZlciBmcm9tIHRoaXMuIGBldmVudC5pc0NvbXBvc2luZ2AgaXMgYXZvaWRlZCBkdWUgdG9cbiAgICAvLyBTYWZhcmkgbm90IHN1cHBvcnRpbmcgaXQgcHJvcGVybHkgKGFsdGhvdWdoIGl0J3Mgbm90IG5lZWRlZCBpbiB0aGUgZmlyc3RcbiAgICAvLyBwbGFjZSBmb3IgU2FmYXJpLCBqdXN0IGF2b2lkaW5nIGFueSBwb3NzaWJsZSBpc3N1ZXMpLlxuICAgIGlmIChldmVudC53aGljaCA9PT0gMjI5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgYW5pbWF0aW5nIG91dCwgaWdub3JlIG5hdmlnYXRpb24uIE90aGVyd2lzZSxcbiAgICAvLyB0aGUgYGFjdGl2ZUluZGV4YCBnZXRzIHNldCB0byAwIGRlc3BpdGUgbm90IGJlaW5nIG9wZW4gc28gdGhlIG5leHQgdGltZVxuICAgIC8vIHRoZSB1c2VyIEFycm93RG93bnMsIHRoZSBmaXJzdCBpdGVtIHdvbid0IGJlIGZvY3VzZWQuXG4gICAgaWYgKCFsYXRlc3RPcGVuUmVmLmN1cnJlbnQgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZmxvYXRpbmdGb2N1c0VsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmVzdGVkICYmIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCwgY29scykpIHtcbiAgICAgIC8vIElmIHRoZSBuZXN0ZWQgbGlzdCdzIGNsb3NlIGtleSBpcyBhbHNvIHRoZSBwYXJlbnQgbmF2aWdhdGlvbiBrZXksXG4gICAgICAvLyBsZXQgdGhlIHBhcmVudCBuYXZpZ2F0ZS4gT3RoZXJ3aXNlLCBzdG9wIHByb3BhZ2F0aW5nIHRoZSBldmVudC5cbiAgICAgIGlmICghaXNNYWluT3JpZW50YXRpb25LZXkoZXZlbnQua2V5LCBnZXRQYXJlbnRPcmllbnRhdGlvbigpKSkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICBpZiAodmlydHVhbCkge1xuICAgICAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmV2ZW50cy5lbWl0KCd2aXJ0dWFsZm9jdXMnLCBlbGVtZW50cy5kb21SZWZlcmVuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRzLmRvbVJlZmVyZW5jZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGluZGV4UmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgbWluSW5kZXggPSBnZXRNaW5MaXN0SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICBjb25zdCBtYXhJbmRleCA9IGdldE1heExpc3RJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGlmICghdHlwZWFibGVDb21ib2JveFJlZmVyZW5jZSkge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0hvbWUnKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtaW5JbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VuZCcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR3JpZCBuYXZpZ2F0aW9uLlxuICAgIGlmIChjb2xzID4gMSkge1xuICAgICAgY29uc3Qgc2l6ZXMgPSBpdGVtU2l6ZXMgfHwgQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogbGlzdFJlZi5jdXJyZW50Lmxlbmd0aFxuICAgICAgfSwgKCkgPT4gKHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMVxuICAgICAgfSkpO1xuICAgICAgLy8gVG8gY2FsY3VsYXRlIG1vdmVtZW50cyBvbiB0aGUgZ3JpZCwgd2UgdXNlIGh5cG90aGV0aWNhbCBjZWxsIGluZGljZXNcbiAgICAgIC8vIGFzIGlmIGV2ZXJ5IGl0ZW0gd2FzIDF4MSwgdGhlbiBjb252ZXJ0IGJhY2sgdG8gcmVhbCBpbmRpY2VzLlxuICAgICAgY29uc3QgY2VsbE1hcCA9IGNyZWF0ZUdyaWRDZWxsTWFwKHNpemVzLCBjb2xzLCBkZW5zZSk7XG4gICAgICBjb25zdCBtaW5HcmlkSW5kZXggPSBjZWxsTWFwLmZpbmRJbmRleChpbmRleCA9PiBpbmRleCAhPSBudWxsICYmICFpc0xpc3RJbmRleERpc2FibGVkKGxpc3RSZWYsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpKTtcbiAgICAgIC8vIGxhc3QgZW5hYmxlZCBpbmRleFxuICAgICAgY29uc3QgbWF4R3JpZEluZGV4ID0gY2VsbE1hcC5yZWR1Y2UoKGZvdW5kSW5kZXgsIGluZGV4LCBjZWxsSW5kZXgpID0+IGluZGV4ICE9IG51bGwgJiYgIWlzTGlzdEluZGV4RGlzYWJsZWQobGlzdFJlZiwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICBjb25zdCBpbmRleCA9IGNlbGxNYXBbZ2V0R3JpZE5hdmlnYXRlZEluZGV4KHtcbiAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCAhPSBudWxsID8gbGlzdFJlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgfSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGxvb3AsXG4gICAgICAgIHJ0bCxcbiAgICAgICAgY29scyxcbiAgICAgICAgLy8gdHJlYXQgdW5kZWZpbmVkIChlbXB0eSBncmlkIHNwYWNlcykgYXMgZGlzYWJsZWQgaW5kaWNlcyBzbyB3ZVxuICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICBkaXNhYmxlZEluZGljZXM6IGdldEdyaWRDZWxsSW5kaWNlcyhbLi4uKCh0eXBlb2YgZGlzYWJsZWRJbmRpY2VzICE9PSAnZnVuY3Rpb24nID8gZGlzYWJsZWRJbmRpY2VzIDogbnVsbCkgfHwgbGlzdFJlZi5jdXJyZW50Lm1hcCgoXywgaW5kZXgpID0+IGlzTGlzdEluZGV4RGlzYWJsZWQobGlzdFJlZiwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykgPyBpbmRleCA6IHVuZGVmaW5lZCkpLCB1bmRlZmluZWRdLCBjZWxsTWFwKSxcbiAgICAgICAgbWluSW5kZXg6IG1pbkdyaWRJbmRleCxcbiAgICAgICAgbWF4SW5kZXg6IG1heEdyaWRJbmRleCxcbiAgICAgICAgcHJldkluZGV4OiBnZXRHcmlkQ2VsbEluZGV4T2ZDb3JuZXIoaW5kZXhSZWYuY3VycmVudCA+IG1heEluZGV4ID8gbWluSW5kZXggOiBpbmRleFJlZi5jdXJyZW50LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgLy8gdXNlIGEgY29ybmVyIG1hdGNoaW5nIHRoZSBlZGdlIGNsb3Nlc3QgdG8gdGhlIGRpcmVjdGlvblxuICAgICAgICAvLyB3ZSdyZSBtb3ZpbmcgaW4gc28gd2UgZG9uJ3QgZW5kIHVwIGluIHRoZSBzYW1lIGl0ZW0uIFByZWZlclxuICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgZXZlbnQua2V5ID09PSBBUlJPV19ET1dOID8gJ2JsJyA6IGV2ZW50LmtleSA9PT0gKHJ0bCA/IEFSUk9XX0xFRlQgOiBBUlJPV19SSUdIVCkgPyAndHInIDogJ3RsJyksXG4gICAgICAgIHN0b3BFdmVudDogdHJ1ZVxuICAgICAgfSldO1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZW50YXRpb24gPT09ICdib3RoJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIG9yaWVudGF0aW9uKSkge1xuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcblxuICAgICAgLy8gUmVzZXQgdGhlIGluZGV4IGlmIG5vIGl0ZW0gaXMgZm9jdXNlZC5cbiAgICAgIGlmIChvcGVuICYmICF2aXJ0dWFsICYmIGFjdGl2ZUVsZW1lbnQoZXZlbnQuY3VycmVudFRhcmdldC5vd25lckRvY3VtZW50KSA9PT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpID8gbWluSW5kZXggOiBtYXhJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpKSB7XG4gICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGN1cnJlbnRJbmRleCA+PSBtYXhJbmRleCA/IGFsbG93RXNjYXBlICYmIGN1cnJlbnRJbmRleCAhPT0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA/IC0xIDogbWluSW5kZXggOiBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWluKG1heEluZGV4LCBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjdXJyZW50SW5kZXggPD0gbWluSW5kZXggPyBhbGxvd0VzY2FwZSAmJiBjdXJyZW50SW5kZXggIT09IC0xID8gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA6IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBNYXRoLm1heChtaW5JbmRleCwgZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzSW5kZXhPdXRPZkxpc3RCb3VuZHMobGlzdFJlZiwgaW5kZXhSZWYuY3VycmVudCkpIHtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgfVxuICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB2aXJ0dWFsICYmIG9wZW4gJiYgaGFzQWN0aXZlSW5kZXggJiYge1xuICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IHZpcnR1YWxJZCB8fCBhY3RpdmVJZFxuICAgIH07XG4gIH0sIFt2aXJ0dWFsLCBvcGVuLCBoYXNBY3RpdmVJbmRleCwgdmlydHVhbElkLCBhY3RpdmVJZF0pO1xuICBjb25zdCBmbG9hdGluZyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAnYXJpYS1vcmllbnRhdGlvbic6IG9yaWVudGF0aW9uID09PSAnYm90aCcgPyB1bmRlZmluZWQgOiBvcmllbnRhdGlvbixcbiAgICAgIC4uLighdHlwZWFibGVDb21ib2JveFJlZmVyZW5jZSA/IGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCA6IHt9KSxcbiAgICAgIG9uS2V5RG93bjogY29tbW9uT25LZXlEb3duLFxuICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCwgY29tbW9uT25LZXlEb3duLCBvcmllbnRhdGlvbiwgdHlwZWFibGVDb21ib2JveFJlZmVyZW5jZV0pO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxNb3VzZShldmVudCkge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbENsaWNrKGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbFBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIC8vIGBwb2ludGVyZG93bmAgZmlyZXMgZmlyc3QsIHJlc2V0IHRoZSBzdGF0ZSB0aGVuIHBlcmZvcm0gdGhlIGNoZWNrcy5cbiAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gZm9jdXNJdGVtT25PcGVuO1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wLFxuICAgICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaXNBcnJvd0tleSA9IGV2ZW50LmtleS5zdGFydHNXaXRoKCdBcnJvdycpO1xuICAgICAgICBjb25zdCBpc0hvbWVPckVuZEtleSA9IFsnSG9tZScsICdFbmQnXS5pbmNsdWRlcyhldmVudC5rZXkpO1xuICAgICAgICBjb25zdCBpc01vdmVLZXkgPSBpc0Fycm93S2V5IHx8IGlzSG9tZU9yRW5kS2V5O1xuICAgICAgICBjb25zdCBpc0Nyb3NzT3BlbktleSA9IGlzQ3Jvc3NPcmllbnRhdGlvbk9wZW5LZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKTtcbiAgICAgICAgY29uc3QgaXNDcm9zc0Nsb3NlS2V5ID0gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsLCBjb2xzKTtcbiAgICAgICAgY29uc3QgaXNQYXJlbnRDcm9zc09wZW5LZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGV2ZW50LmtleSwgZ2V0UGFyZW50T3JpZW50YXRpb24oKSwgcnRsKTtcbiAgICAgICAgY29uc3QgaXNNYWluS2V5ID0gaXNNYWluT3JpZW50YXRpb25LZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbik7XG4gICAgICAgIGNvbnN0IGlzTmF2aWdhdGlvbktleSA9IChuZXN0ZWQgPyBpc1BhcmVudENyb3NzT3BlbktleSA6IGlzTWFpbktleSkgfHwgZXZlbnQua2V5ID09PSAnRW50ZXInIHx8IGV2ZW50LmtleS50cmltKCkgPT09ICcnO1xuICAgICAgICBpZiAodmlydHVhbCAmJiBvcGVuKSB7XG4gICAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0cmVlID09IG51bGwgPyB2b2lkIDAgOiB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZChub2RlID0+IG5vZGUucGFyZW50SWQgPT0gbnVsbCk7XG4gICAgICAgICAgY29uc3QgZGVlcGVzdE5vZGUgPSB0cmVlICYmIHJvb3ROb2RlID8gZ2V0RGVlcGVzdE5vZGUodHJlZS5ub2Rlc1JlZi5jdXJyZW50LCByb290Tm9kZS5pZCkgOiBudWxsO1xuICAgICAgICAgIGlmIChpc01vdmVLZXkgJiYgZGVlcGVzdE5vZGUgJiYgdmlydHVhbEl0ZW1SZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc0Nyb3NzT3BlbktleSB8fCBpc0Nyb3NzQ2xvc2VLZXkpIHtcbiAgICAgICAgICAgICAgdmFyIF9kZWVwZXN0Tm9kZSRjb250ZXh0LCBfZGVlcGVzdE5vZGUkY29udGV4dDI7XG4gICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFRhcmdldCA9ICgoX2RlZXBlc3ROb2RlJGNvbnRleHQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgY29uc3QgZGlzcGF0Y2hJdGVtID0gaXNDcm9zc0Nsb3NlS2V5ICYmICFpc0N1cnJlbnRUYXJnZXQgPyAoX2RlZXBlc3ROb2RlJGNvbnRleHQyID0gZGVlcGVzdE5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kZWVwZXN0Tm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UgOiBpc0Nyb3NzT3BlbktleSA/IGxpc3RSZWYuY3VycmVudC5maW5kKGl0ZW0gPT4gKGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uaWQpID09PSBhY3RpdmVJZCkgOiBudWxsO1xuICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2hJdGVtKSB7XG4gICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEl0ZW0uZGlzcGF0Y2hFdmVudChldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgc2V0VmlydHVhbElkKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaXNNYWluS2V5IHx8IGlzSG9tZU9yRW5kS2V5KSAmJiBkZWVwZXN0Tm9kZS5jb250ZXh0KSB7XG4gICAgICAgICAgICAgIGlmIChkZWVwZXN0Tm9kZS5jb250ZXh0Lm9wZW4gJiYgZGVlcGVzdE5vZGUucGFyZW50SWQgJiYgZXZlbnQuY3VycmVudFRhcmdldCAhPT0gZGVlcGVzdE5vZGUuY29udGV4dC5lbGVtZW50cy5kb21SZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2RlZXBlc3ROb2RlJGNvbnRleHQkO1xuICAgICAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgKF9kZWVwZXN0Tm9kZSRjb250ZXh0JCA9IGRlZXBlc3ROb2RlLmNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PSBudWxsIHx8IF9kZWVwZXN0Tm9kZSRjb250ZXh0JC5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbW1vbk9uS2V5RG93bihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBmbG9hdGluZyBlbGVtZW50IHNob3VsZCBub3Qgb3BlbiBvbiBhcnJvdyBrZXkgZG93biwgYXZvaWRcbiAgICAgICAgLy8gc2V0dGluZyBgYWN0aXZlSW5kZXhgIHdoaWxlIGl0J3MgY2xvc2VkLlxuICAgICAgICBpZiAoIW9wZW4gJiYgIW9wZW5PbkFycm93S2V5RG93biAmJiBpc0Fycm93S2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgICAgICBjb25zdCBpc1BhcmVudE1haW5LZXkgPSBpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIGdldFBhcmVudE9yaWVudGF0aW9uKCkpO1xuICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gbmVzdGVkICYmIGlzUGFyZW50TWFpbktleSA/IG51bGwgOiBldmVudC5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgIGlmIChpc1BhcmVudENyb3NzT3BlbktleSkge1xuICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBnZXRNaW5MaXN0SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICBvbk5hdmlnYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01haW5LZXkpIHtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBpZiAoIW9wZW4gJiYgb3Blbk9uQXJyb3dLZXlEb3duKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tbW9uT25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIG9uTmF2aWdhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkZvY3VzKCkge1xuICAgICAgICBpZiAob3BlbiAmJiAhdmlydHVhbCkge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgICBvbk5hdmlnYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblBvaW50ZXJEb3duOiBjaGVja1ZpcnR1YWxQb2ludGVyLFxuICAgICAgb25Qb2ludGVyRW50ZXI6IGNoZWNrVmlydHVhbFBvaW50ZXIsXG4gICAgICBvbk1vdXNlRG93bjogY2hlY2tWaXJ0dWFsTW91c2UsXG4gICAgICBvbkNsaWNrOiBjaGVja1ZpcnR1YWxNb3VzZVxuICAgIH07XG4gIH0sIFthY3RpdmVJZCwgYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wLCBjb2xzLCBjb21tb25PbktleURvd24sIGRpc2FibGVkSW5kaWNlc1JlZiwgZm9jdXNJdGVtT25PcGVuLCBsaXN0UmVmLCBuZXN0ZWQsIG9uTmF2aWdhdGUsIG9uT3BlbkNoYW5nZSwgb3Blbiwgb3Blbk9uQXJyb3dLZXlEb3duLCBvcmllbnRhdGlvbiwgZ2V0UGFyZW50T3JpZW50YXRpb24sIHJ0bCwgc2VsZWN0ZWRJbmRleCwgdHJlZSwgdmlydHVhbCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgaXRlbVxuICB9IDoge30sIFtlbmFibGVkLCByZWZlcmVuY2UsIGZsb2F0aW5nLCBpdGVtXSk7XG59XG5cbmNvbnN0IGNvbXBvbmVudFJvbGVUb0FyaWFSb2xlTWFwID0gLyojX19QVVJFX18qL25ldyBNYXAoW1snc2VsZWN0JywgJ2xpc3Rib3gnXSwgWydjb21ib2JveCcsICdsaXN0Ym94J10sIFsnbGFiZWwnLCBmYWxzZV1dKTtcblxuLyoqXG4gKiBBZGRzIGJhc2Ugc2NyZWVuIHJlYWRlciBwcm9wcyB0byB0aGUgcmVmZXJlbmNlIGFuZCBmbG9hdGluZyBlbGVtZW50cyBmb3IgYVxuICogZ2l2ZW4gZmxvYXRpbmcgZWxlbWVudCBgcm9sZWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlUm9sZVxuICovXG5mdW5jdGlvbiB1c2VSb2xlKGNvbnRleHQsIHByb3BzKSB7XG4gIHZhciBfZWxlbWVudHMkZG9tUmVmZXJlbmMsIF9jb21wb25lbnRSb2xlVG9BcmlhUjtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzLFxuICAgIGZsb2F0aW5nSWQ6IGRlZmF1bHRGbG9hdGluZ0lkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgcm9sZSA9ICdkaWFsb2cnXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgZGVmYXVsdFJlZmVyZW5jZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcmVmZXJlbmNlSWQgPSAoKF9lbGVtZW50cyRkb21SZWZlcmVuYyA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50cyRkb21SZWZlcmVuYy5pZCkgfHwgZGVmYXVsdFJlZmVyZW5jZUlkO1xuICBjb25zdCBmbG9hdGluZ0lkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9nZXRGbG9hdGluZ0ZvY3VzRWxlbTtcbiAgICByZXR1cm4gKChfZ2V0RmxvYXRpbmdGb2N1c0VsZW0gPSBnZXRGbG9hdGluZ0ZvY3VzRWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0RmxvYXRpbmdGb2N1c0VsZW0uaWQpIHx8IGRlZmF1bHRGbG9hdGluZ0lkO1xuICB9LCBbZWxlbWVudHMuZmxvYXRpbmcsIGRlZmF1bHRGbG9hdGluZ0lkXSk7XG4gIGNvbnN0IGFyaWFSb2xlID0gKF9jb21wb25lbnRSb2xlVG9BcmlhUiA9IGNvbXBvbmVudFJvbGVUb0FyaWFSb2xlTWFwLmdldChyb2xlKSkgIT0gbnVsbCA/IF9jb21wb25lbnRSb2xlVG9BcmlhUiA6IHJvbGU7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgaXNOZXN0ZWQgPSBwYXJlbnRJZCAhPSBudWxsO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoYXJpYVJvbGUgPT09ICd0b29sdGlwJyB8fCByb2xlID09PSAnbGFiZWwnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbXCJhcmlhLVwiICsgKHJvbGUgPT09ICdsYWJlbCcgPyAnbGFiZWxsZWRieScgOiAnZGVzY3JpYmVkYnknKV06IG9wZW4gPyBmbG9hdGluZ0lkIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICdhcmlhLWhhc3BvcHVwJzogYXJpYVJvbGUgPT09ICdhbGVydGRpYWxvZycgPyAnZGlhbG9nJyA6IGFyaWFSb2xlLFxuICAgICAgJ2FyaWEtY29udHJvbHMnOiBvcGVuID8gZmxvYXRpbmdJZCA6IHVuZGVmaW5lZCxcbiAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ2xpc3Rib3gnICYmIHtcbiAgICAgICAgcm9sZTogJ2NvbWJvYm94J1xuICAgICAgfSksXG4gICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgIGlkOiByZWZlcmVuY2VJZFxuICAgICAgfSksXG4gICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiBpc05lc3RlZCAmJiB7XG4gICAgICAgIHJvbGU6ICdtZW51aXRlbSdcbiAgICAgIH0pLFxuICAgICAgLi4uKHJvbGUgPT09ICdzZWxlY3QnICYmIHtcbiAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ25vbmUnXG4gICAgICB9KSxcbiAgICAgIC4uLihyb2xlID09PSAnY29tYm9ib3gnICYmIHtcbiAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnXG4gICAgICB9KVxuICAgIH07XG4gIH0sIFthcmlhUm9sZSwgZmxvYXRpbmdJZCwgaXNOZXN0ZWQsIG9wZW4sIHJlZmVyZW5jZUlkLCByb2xlXSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZmxvYXRpbmdQcm9wcyA9IHtcbiAgICAgIGlkOiBmbG9hdGluZ0lkLFxuICAgICAgLi4uKGFyaWFSb2xlICYmIHtcbiAgICAgICAgcm9sZTogYXJpYVJvbGVcbiAgICAgIH0pXG4gICAgfTtcbiAgICBpZiAoYXJpYVJvbGUgPT09ICd0b29sdGlwJyB8fCByb2xlID09PSAnbGFiZWwnKSB7XG4gICAgICByZXR1cm4gZmxvYXRpbmdQcm9wcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZsb2F0aW5nUHJvcHMsXG4gICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiByZWZlcmVuY2VJZFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbYXJpYVJvbGUsIGZsb2F0aW5nSWQsIHJlZmVyZW5jZUlkLCByb2xlXSk7XG4gIGNvbnN0IGl0ZW0gPSBSZWFjdC51c2VDYWxsYmFjayhfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlLFxuICAgICAgc2VsZWN0ZWRcbiAgICB9ID0gX3JlZjtcbiAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtcbiAgICAgIHJvbGU6ICdvcHRpb24nLFxuICAgICAgLi4uKGFjdGl2ZSAmJiB7XG4gICAgICAgIGlkOiBmbG9hdGluZ0lkICsgXCItZnVpLW9wdGlvblwiXG4gICAgICB9KVxuICAgIH07XG5cbiAgICAvLyBGb3IgYG1lbnVgLCB3ZSBhcmUgdW5hYmxlIHRvIHRlbGwgaWYgdGhlIGl0ZW0gaXMgYSBgbWVudWl0ZW1yYWRpb2BcbiAgICAvLyBvciBgbWVudWl0ZW1jaGVja2JveGAuIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSByZWFzb25zLCBhbHNvXG4gICAgLy8gYXZvaWQgZGVmYXVsdGluZyB0byBgbWVudWl0ZW1gIGFzIGl0IG1heSBvdmVyd3JpdGUgY3VzdG9tIHJvbGUgcHJvcHMuXG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmNvbW1vblByb3BzLFxuICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogYWN0aXZlICYmIHNlbGVjdGVkXG4gICAgICAgIH07XG4gICAgICBjYXNlICdjb21ib2JveCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHNlbGVjdGVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH0sIFtmbG9hdGluZ0lkLCByb2xlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIGl0ZW1cbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlLCBmbG9hdGluZywgaXRlbV0pO1xufVxuXG4vLyBDb252ZXJ0cyBhIEpTIHN0eWxlIGtleSBsaWtlIGBiYWNrZ3JvdW5kQ29sb3JgIHRvIGEgQ1NTIHRyYW5zaXRpb24tcHJvcGVydHlcbi8vIGxpa2UgYGJhY2tncm91bmQtY29sb3JgLlxuY29uc3QgY2FtZWxDYXNlVG9LZWJhYkNhc2UgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tBLVpdKyg/IVthLXpdKXxbQS1aXS9nLCAoJCwgb2ZzKSA9PiAob2ZzID8gJy0nIDogJycpICsgJC50b0xvd2VyQ2FzZSgpKTtcbmZ1bmN0aW9uIGV4ZWNXaXRoQXJnc09yUmV0dXJuKHZhbHVlT3JGbiwgYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlT3JGbiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlT3JGbihhcmdzKSA6IHZhbHVlT3JGbjtcbn1cbmZ1bmN0aW9uIHVzZURlbGF5VW5tb3VudChvcGVuLCBkdXJhdGlvbk1zKSB7XG4gIGNvbnN0IFtpc01vdW50ZWQsIHNldElzTW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShvcGVuKTtcbiAgaWYgKG9wZW4gJiYgIWlzTW91bnRlZCkge1xuICAgIHNldElzTW91bnRlZCh0cnVlKTtcbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiAmJiBpc01vdW50ZWQpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldElzTW91bnRlZChmYWxzZSksIGR1cmF0aW9uTXMpO1xuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gIH0sIFtvcGVuLCBpc01vdW50ZWQsIGR1cmF0aW9uTXNdKTtcbiAgcmV0dXJuIGlzTW91bnRlZDtcbn1cbi8qKlxuICogUHJvdmlkZXMgYSBzdGF0dXMgc3RyaW5nIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsXG4gKiBjb3JyZWN0bHkgaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0YXR1c1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpc051bWJlckR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJztcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlKCd1bm1vdW50ZWQnKTtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGNsb3NlRHVyYXRpb24pO1xuICBpZiAoIWlzTW91bnRlZCAmJiBzdGF0dXMgPT09ICdjbG9zZScpIHtcbiAgICBzZXRTdGF0dXMoJ3VubW91bnRlZCcpO1xuICB9XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRTdGF0dXMoJ2luaXRpYWwnKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgLy8gRW5zdXJlIGl0IG9wZW5zIGJlZm9yZSBwYWludC4gV2l0aCBgRmxvYXRpbmdEZWxheUdyb3VwYCxcbiAgICAgICAgLy8gdGhpcyBhdm9pZHMgYSBmbGlja2VyIHdoZW4gbW92aW5nIGJldHdlZW4gZmxvYXRpbmcgZWxlbWVudHNcbiAgICAgICAgLy8gdG8gZW5zdXJlIG9uZSBpcyBhbHdheXMgb3BlbiB3aXRoIG5vIG1pc3NpbmcgZnJhbWVzLlxuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIHNldFN0YXR1cygnb3BlbicpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgICAgfTtcbiAgICB9XG4gICAgc2V0U3RhdHVzKCdjbG9zZScpO1xuICB9LCBbb3BlbiwgZmxvYXRpbmddKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIHN0eWxlcyB0byBhcHBseSBDU1MgdHJhbnNpdGlvbnMgdG8gYSBmbG9hdGluZyBlbGVtZW50LCBjb3JyZWN0bHlcbiAqIGhhbmRsaW5nIHBsYWNlbWVudC1hd2FyZSB0cmFuc2l0aW9ucy4gV3JhcHBlciBhcm91bmQgYHVzZVRyYW5zaXRpb25TdGF0dXNgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0eWxlc1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3R5bGVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5pdGlhbDogdW5zdGFibGVfaW5pdGlhbCA9IHtcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgIG9wZW46IHVuc3RhYmxlX29wZW4sXG4gICAgY2xvc2U6IHVuc3RhYmxlX2Nsb3NlLFxuICAgIGNvbW1vbjogdW5zdGFibGVfY29tbW9uLFxuICAgIGR1cmF0aW9uID0gMjUwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcGxhY2VtZW50ID0gY29udGV4dC5wbGFjZW1lbnQ7XG4gIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3QgZm5BcmdzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHNpZGUsXG4gICAgcGxhY2VtZW50XG4gIH0pLCBbc2lkZSwgcGxhY2VtZW50XSk7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBvcGVuRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24ub3BlbikgfHwgMDtcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW3N0eWxlcywgc2V0U3R5bGVzXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+ICh7XG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfY29tbW9uLCBmbkFyZ3MpLFxuICAgIC4uLmV4ZWNXaXRoQXJnc09yUmV0dXJuKHVuc3RhYmxlX2luaXRpYWwsIGZuQXJncylcbiAgfSkpO1xuICBjb25zdCB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0YXR1c1xuICB9ID0gdXNlVHJhbnNpdGlvblN0YXR1cyhjb250ZXh0LCB7XG4gICAgZHVyYXRpb25cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfaW5pdGlhbCk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfb3Blbik7XG4gIGNvbnN0IGNsb3NlUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2Nsb3NlKTtcbiAgY29uc3QgY29tbW9uUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2NvbW1vbik7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGluaXRpYWxSZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBjbG9zZVN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGNsb3NlUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3QgY29tbW9uU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oY29tbW9uUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3Qgb3BlblN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKG9wZW5SZWYuY3VycmVudCwgZm5BcmdzKSB8fCBPYmplY3Qua2V5cyhpbml0aWFsU3R5bGVzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICBhY2Nba2V5XSA9ICcnO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKHN0YXR1cyA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICBzZXRTdHlsZXMoc3R5bGVzID0+ICh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogc3R5bGVzLnRyYW5zaXRpb25Qcm9wZXJ0eSxcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5pbml0aWFsU3R5bGVzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICdvcGVuJykge1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhvcGVuU3R5bGVzKS5tYXAoY2FtZWxDYXNlVG9LZWJhYkNhc2UpLmpvaW4oJywnKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBvcGVuRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4ub3BlblN0eWxlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICdjbG9zZScpIHtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IGNsb3NlU3R5bGVzIHx8IGluaXRpYWxTdHlsZXM7XG4gICAgICBzZXRTdHlsZXMoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKHN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogY2xvc2VEdXJhdGlvbiArIFwibXNcIixcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5zdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2Nsb3NlRHVyYXRpb24sIGNsb3NlUmVmLCBpbml0aWFsUmVmLCBvcGVuUmVmLCBjb21tb25SZWYsIG9wZW5EdXJhdGlvbiwgc3RhdHVzLCBmbkFyZ3NdKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3R5bGVzXG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBtYXRjaGluZyBjYWxsYmFjayB0aGF0IGNhbiBiZSB1c2VkIHRvIGZvY3VzIGFuIGl0ZW0gYXMgdGhlIHVzZXJcbiAqIHR5cGVzLCBvZnRlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbigpYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUeXBlYWhlYWRcbiAqL1xuZnVuY3Rpb24gdXNlVHlwZWFoZWFkKGNvbnRleHQsIHByb3BzKSB7XG4gIHZhciBfcmVmO1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBkYXRhUmVmXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk1hdGNoOiB1bnN0YWJsZV9vbk1hdGNoLFxuICAgIG9uVHlwaW5nQ2hhbmdlOiB1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSxcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBmaW5kTWF0Y2ggPSBudWxsLFxuICAgIHJlc2V0TXMgPSA3NTAsXG4gICAgaWdub3JlS2V5cyA9IFtdLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdGltZW91dElkUmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3Qgc3RyaW5nUmVmID0gUmVhY3QudXNlUmVmKCcnKTtcbiAgY29uc3QgcHJldkluZGV4UmVmID0gUmVhY3QudXNlUmVmKChfcmVmID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZiA6IC0xKTtcbiAgY29uc3QgbWF0Y2hJbmRleFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb25NYXRjaCA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTWF0Y2gpO1xuICBjb25zdCBvblR5cGluZ0NoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uVHlwaW5nQ2hhbmdlKTtcbiAgY29uc3QgZmluZE1hdGNoUmVmID0gdXNlTGF0ZXN0UmVmKGZpbmRNYXRjaCk7XG4gIGNvbnN0IGlnbm9yZUtleXNSZWYgPSB1c2VMYXRlc3RSZWYoaWdub3JlS2V5cyk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRJZFJlZik7XG4gICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3luYyBhcnJvdyBrZXkgbmF2aWdhdGlvbiBidXQgbm90IHR5cGVhaGVhZCBuYXZpZ2F0aW9uLlxuICAgIGlmIChvcGVuICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSAnJykge1xuICAgICAgdmFyIF9yZWYyO1xuICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSAoX3JlZjIgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmMiA6IC0xO1xuICAgIH1cbiAgfSwgW29wZW4sIHNlbGVjdGVkSW5kZXgsIGFjdGl2ZUluZGV4XSk7XG4gIGNvbnN0IHNldFR5cGluZ0NoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghZGF0YVJlZi5jdXJyZW50LnR5cGluZykge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQudHlwaW5nID0gdmFsdWU7XG4gICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC50eXBpbmcpIHtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICBvblR5cGluZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb25LZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoaW5nSW5kZXgobGlzdCwgb3JkZXJlZExpc3QsIHN0cmluZykge1xuICAgICAgY29uc3Qgc3RyID0gZmluZE1hdGNoUmVmLmN1cnJlbnQgPyBmaW5kTWF0Y2hSZWYuY3VycmVudChvcmRlcmVkTGlzdCwgc3RyaW5nKSA6IG9yZGVyZWRMaXN0LmZpbmQodGV4dCA9PiAodGV4dCA9PSBudWxsID8gdm9pZCAwIDogdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSA9PT0gMCk7XG4gICAgICByZXR1cm4gc3RyID8gbGlzdC5pbmRleE9mKHN0cikgOiAtMTtcbiAgICB9XG4gICAgY29uc3QgbGlzdENvbnRlbnQgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gICAgaWYgKHN0cmluZ1JlZi5jdXJyZW50Lmxlbmd0aCA+IDAgJiYgc3RyaW5nUmVmLmN1cnJlbnRbMF0gIT09ICcgJykge1xuICAgICAgaWYgKGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIGxpc3RDb250ZW50LCBzdHJpbmdSZWYuY3VycmVudCkgPT09IC0xKSB7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsaXN0Q29udGVudCA9PSBudWxsIHx8IGlnbm9yZUtleXNSZWYuY3VycmVudC5pbmNsdWRlcyhldmVudC5rZXkpIHx8XG4gICAgLy8gQ2hhcmFjdGVyIGtleS5cbiAgICBldmVudC5rZXkubGVuZ3RoICE9PSAxIHx8XG4gICAgLy8gTW9kaWZpZXIga2V5LlxuICAgIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICBzZXRUeXBpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gQmFpbCBvdXQgaWYgdGhlIGxpc3QgY29udGFpbnMgYSB3b3JkIGxpa2UgXCJsbGFtYVwiIG9yIFwiYWFyb25cIi4gVE9ETzpcbiAgICAvLyBhbGxvdyBpdCBpbiB0aGlzIGNhc2UsIHRvby5cbiAgICBjb25zdCBhbGxvd1JhcGlkU3VjY2Vzc2lvbk9mRmlyc3RMZXR0ZXIgPSBsaXN0Q29udGVudC5ldmVyeSh0ZXh0ID0+IHtcbiAgICAgIHZhciBfdGV4dCQsIF90ZXh0JDI7XG4gICAgICByZXR1cm4gdGV4dCA/ICgoX3RleHQkID0gdGV4dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JC50b0xvY2FsZUxvd2VyQ2FzZSgpKSAhPT0gKChfdGV4dCQyID0gdGV4dFsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JDIudG9Mb2NhbGVMb3dlckNhc2UoKSkgOiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gQWxsb3dzIHRoZSB1c2VyIHRvIGN5Y2xlIHRocm91Z2ggaXRlbXMgdGhhdCBzdGFydCB3aXRoIHRoZSBzYW1lIGxldHRlclxuICAgIC8vIGluIHJhcGlkIHN1Y2Nlc3Npb24uXG4gICAgaWYgKGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciAmJiBzdHJpbmdSZWYuY3VycmVudCA9PT0gZXZlbnQua2V5KSB7XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIHN0cmluZ1JlZi5jdXJyZW50ICs9IGV2ZW50LmtleTtcbiAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0SWRSZWYpO1xuICAgIHRpbWVvdXRJZFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gbWF0Y2hJbmRleFJlZi5jdXJyZW50O1xuICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICB9LCByZXNldE1zKTtcbiAgICBjb25zdCBwcmV2SW5kZXggPSBwcmV2SW5kZXhSZWYuY3VycmVudDtcbiAgICBjb25zdCBpbmRleCA9IGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIFsuLi5saXN0Q29udGVudC5zbGljZSgocHJldkluZGV4IHx8IDApICsgMSksIC4uLmxpc3RDb250ZW50LnNsaWNlKDAsIChwcmV2SW5kZXggfHwgMCkgKyAxKV0sIHN0cmluZ1JlZi5jdXJyZW50KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBvbk1hdGNoKGluZGV4KTtcbiAgICAgIG1hdGNoSW5kZXhSZWYuY3VycmVudCA9IGluZGV4O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbktleURvd25cbiAgfSksIFtvbktleURvd25dKTtcbiAgY29uc3QgZmxvYXRpbmcgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25LZXlEb3duLFxuICAgICAgb25LZXlVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW29uS2V5RG93biwgc2V0VHlwaW5nQ2hhbmdlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZSwgZmxvYXRpbmddKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChzdGF0ZSwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgcmVjdHM6IHtcbiAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uc3RhdGUucmVjdHMuZmxvYXRpbmcsXG4gICAgICAgIGhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBhbiBpbm5lciBlbGVtZW50IGluc2lkZSBvZiBpdCBpc1xuICogYW5jaG9yZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKiBAZGVwcmVjYXRlZFxuICovXG5jb25zdCBpbm5lciA9IHByb3BzID0+ICh7XG4gIG5hbWU6ICdpbm5lcicsXG4gIG9wdGlvbnM6IHByb3BzLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RSZWYsXG4gICAgICBvdmVyZmxvd1JlZixcbiAgICAgIG9uRmFsbGJhY2tDaGFuZ2UsXG4gICAgICBvZmZzZXQ6IGlubmVyT2Zmc2V0ID0gMCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1pbkl0ZW1zVmlzaWJsZSA9IDQsXG4gICAgICByZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCA9IDAsXG4gICAgICBzY3JvbGxSZWYsXG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICB9ID0gZXZhbHVhdGUocHJvcHMsIHN0YXRlKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0cyxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGNvbnN0IHNjcm9sbEVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuXG4gICAgLy8gVmFsaWQgY29tYmluYXRpb25zOlxuICAgIC8vIDEuIEZsb2F0aW5nIGVsZW1lbnQgaXMgdGhlIHNjcm9sbFJlZiBhbmQgaGFzIGEgYm9yZGVyIChkZWZhdWx0KVxuICAgIC8vIDIuIEZsb2F0aW5nIGVsZW1lbnQgaXMgbm90IHRoZSBzY3JvbGxSZWYsIGZsb2F0aW5nIGVsZW1lbnQgaGFzIGEgYm9yZGVyXG4gICAgLy8gMy4gRmxvYXRpbmcgZWxlbWVudCBpcyBub3QgdGhlIHNjcm9sbFJlZiwgc2Nyb2xsUmVmIGhhcyBhIGJvcmRlclxuICAgIC8vIEZsb2F0aW5nID4gey4uLmdldEZsb2F0aW5nUHJvcHMoKX0gd3JhcHBlciA+IHNjcm9sbFJlZiA+IGl0ZW1zIGlzIG5vdFxuICAgIC8vIGFsbG93ZWQgYXMgVm9pY2VPdmVyIGRvZXNuJ3Qgd29yay5cbiAgICBjb25zdCBjbGllbnRUb3AgPSBmbG9hdGluZy5jbGllbnRUb3AgfHwgc2Nyb2xsRWwuY2xpZW50VG9wO1xuICAgIGNvbnN0IGZsb2F0aW5nSXNCb3JkZXJlZCA9IGZsb2F0aW5nLmNsaWVudFRvcCAhPT0gMDtcbiAgICBjb25zdCBzY3JvbGxFbElzQm9yZGVyZWQgPSBzY3JvbGxFbC5jbGllbnRUb3AgIT09IDA7XG4gICAgY29uc3QgZmxvYXRpbmdJc1Njcm9sbEVsID0gZmxvYXRpbmcgPT09IHNjcm9sbEVsO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc3RhdGUucGxhY2VtZW50LnN0YXJ0c1dpdGgoJ2JvdHRvbScpKSB7XG4gICAgICAgIHdhcm4oJ2BwbGFjZW1lbnRgIHNpZGUgbXVzdCBiZSBcImJvdHRvbVwiIHdoZW4gdXNpbmcgdGhlIGBpbm5lcmAnLCAnbWlkZGxld2FyZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi4oYXdhaXQgb2Zmc2V0KC1pdGVtLm9mZnNldFRvcCAtIGZsb2F0aW5nLmNsaWVudFRvcCAtIHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gaXRlbS5vZmZzZXRIZWlnaHQgLyAyIC0gaW5uZXJPZmZzZXQpLmZuKHN0YXRlKSlcbiAgICB9O1xuICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChuZXh0QXJncywgc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0ICsgY2xpZW50VG9wICsgZmxvYXRpbmcuY2xpZW50VG9wKSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICBjb25zdCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmWSA9IG1heCgwLCBvdmVyZmxvdy50b3ApO1xuICAgIGNvbnN0IG5leHRZID0gbmV4dEFyZ3MueSArIGRpZmZZO1xuICAgIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IHNjcm9sbEVsLnNjcm9sbEhlaWdodCA+IHNjcm9sbEVsLmNsaWVudEhlaWdodDtcbiAgICBjb25zdCByb3VuZGVyID0gaXNTY3JvbGxhYmxlID8gdiA9PiB2IDogcm91bmQ7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gcm91bmRlcihtYXgoMCwgc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0ICsgKGZsb2F0aW5nSXNCb3JkZXJlZCAmJiBmbG9hdGluZ0lzU2Nyb2xsRWwgfHwgc2Nyb2xsRWxJc0JvcmRlcmVkID8gY2xpZW50VG9wICogMiA6IDApIC0gZGlmZlkgLSBtYXgoMCwgb3ZlcmZsb3cuYm90dG9tKSkpO1xuICAgIHNjcm9sbEVsLnN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcbiAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBkaWZmWTtcblxuICAgIC8vIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UsIGZhbGxiYWNrIHRvIHN0YW5kYXJkIGFuY2hvcmVkIHBvc2l0aW9uaW5nXG4gICAgaWYgKG9uRmFsbGJhY2tDaGFuZ2UpIHtcbiAgICAgIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0IDwgaXRlbS5vZmZzZXRIZWlnaHQgKiBtaW4obWluSXRlbXNWaXNpYmxlLCBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkO1xuICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IG9uRmFsbGJhY2tDaGFuZ2Uoc2hvdWxkRmFsbGJhY2spKTtcbiAgICB9XG4gICAgaWYgKG92ZXJmbG93UmVmKSB7XG4gICAgICBvdmVyZmxvd1JlZi5jdXJyZW50ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodCh7XG4gICAgICAgIC4uLm5leHRBcmdzLFxuICAgICAgICB5OiBuZXh0WVxuICAgICAgfSwgc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0ICsgY2xpZW50VG9wICsgZmxvYXRpbmcuY2xpZW50VG9wKSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHk6IG5leHRZXG4gICAgfTtcbiAgfVxufSk7XG4vKipcbiAqIENoYW5nZXMgdGhlIGBpbm5lcmAgbWlkZGxld2FyZSdzIGBvZmZzZXRgIHVwb24gYSBgd2hlZWxgIGV2ZW50IHRvXG4gKiBleHBhbmQgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBoZWlnaHQsIHJldmVhbGluZyBtb3JlIGxpc3QgaXRlbXMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5uZXJcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIHVzZUlubmVyT2Zmc2V0KGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgb3ZlcmZsb3dSZWYsXG4gICAgc2Nyb2xsUmVmLFxuICAgIG9uQ2hhbmdlOiB1bnN0YWJsZV9vbkNoYW5nZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG9uQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25DaGFuZ2UpO1xuICBjb25zdCBjb250cm9sbGVkU2Nyb2xsaW5nUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcHJldlNjcm9sbFRvcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5pdGlhbE92ZXJmbG93UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uV2hlZWwoZSkge1xuICAgICAgaWYgKGUuY3RybEtleSB8fCAhZWwgfHwgb3ZlcmZsb3dSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRZID0gZS5kZWx0YVk7XG4gICAgICBjb25zdCBpc0F0VG9wID0gb3ZlcmZsb3dSZWYuY3VycmVudC50b3AgPj0gLTAuNTtcbiAgICAgIGNvbnN0IGlzQXRCb3R0b20gPSBvdmVyZmxvd1JlZi5jdXJyZW50LmJvdHRvbSA+PSAtMC41O1xuICAgICAgY29uc3QgcmVtYWluaW5nU2Nyb2xsID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3Qgc2lnbiA9IGRZIDwgMCA/IC0xIDogMTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IGRZIDwgMCA/ICdtYXgnIDogJ21pbic7XG4gICAgICBpZiAoZWwuc2Nyb2xsSGVpZ2h0IDw9IGVsLmNsaWVudEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXRUb3AgJiYgZFkgPiAwIHx8ICFpc0F0Qm90dG9tICYmIGRZIDwgMCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoZCA9PiBkICsgTWF0aFttZXRob2RdKGRZLCByZW1haW5pbmdTY3JvbGwgKiBzaWduKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICgvZmlyZWZveC9pLnRlc3QoZ2V0VXNlckFnZW50KCkpKSB7XG4gICAgICAgIC8vIE5lZWRlZCB0byBwcm9wYWdhdGUgc2Nyb2xsaW5nIGR1cmluZyBtb21lbnR1bSBzY3JvbGxpbmcgcGhhc2Ugb25jZVxuICAgICAgICAvLyBpdCBnZXRzIGxpbWl0ZWQgYnkgdGhlIGJvdW5kYXJ5LiBVWCBpbXByb3ZlbWVudCwgbm90IGNyaXRpY2FsLlxuICAgICAgICBlbC5zY3JvbGxUb3AgKz0gZFk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGlmIChvcGVuICYmIGVsKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uV2hlZWwpO1xuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgcG9zaXRpb24gdG8gYmUgcmVhZHkuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGlmIChvdmVyZmxvd1JlZi5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgIC4uLm92ZXJmbG93UmVmLmN1cnJlbnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGluaXRpYWxPdmVyZmxvd1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZWxlbWVudHMuZmxvYXRpbmcsIG92ZXJmbG93UmVmLCBzY3JvbGxSZWYsIG9uQ2hhbmdlXSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uS2V5RG93bigpIHtcbiAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvbldoZWVsKCkge1xuICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBvblNjcm9sbCgpIHtcbiAgICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgICAgaWYgKCFvdmVyZmxvd1JlZi5jdXJyZW50IHx8ICFlbCB8fCAhY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRGlmZiA9IGVsLnNjcm9sbFRvcCAtIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKG92ZXJmbG93UmVmLmN1cnJlbnQuYm90dG9tIDwgLTAuNSAmJiBzY3JvbGxEaWZmIDwgLTEgfHwgb3ZlcmZsb3dSZWYuY3VycmVudC50b3AgPCAtMC41ICYmIHNjcm9sbERpZmYgPiAxKSB7XG4gICAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IG9uQ2hhbmdlKGQgPT4gZCArIHNjcm9sbERpZmYpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBbRmlyZWZveF0gV2FpdCBmb3IgdGhlIGhlaWdodCBjaGFuZ2UgdG8gaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBbZWxlbWVudHMuZmxvYXRpbmcsIG9uQ2hhbmdlLCBvdmVyZmxvd1JlZiwgc2Nyb2xsUmVmXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgZmxvYXRpbmdcbiAgfSA6IHt9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZUNoaWxkcmVuKG5vZGVzLCBpZCwgb25seU9wZW5DaGlsZHJlbikge1xuICBpZiAob25seU9wZW5DaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgb25seU9wZW5DaGlsZHJlbiA9IHRydWU7XG4gIH1cbiAgY29uc3QgZGlyZWN0Q2hpbGRyZW4gPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgdmFyIF9ub2RlJGNvbnRleHQ7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50SWQgPT09IGlkICYmICghb25seU9wZW5DaGlsZHJlbiB8fCAoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Lm9wZW4pKTtcbiAgfSk7XG4gIHJldHVybiBkaXJlY3RDaGlsZHJlbi5mbGF0TWFwKGNoaWxkID0+IFtjaGlsZCwgLi4uZ2V0Tm9kZUNoaWxkcmVuKG5vZGVzLCBjaGlsZC5pZCwgb25seU9wZW5DaGlsZHJlbildKTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICBjb25zdCBbeCwgeV0gPSBwb2ludDtcbiAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHBvbHlnb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICBjb25zdCBbeGksIHlpXSA9IHBvbHlnb25baV0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IFt4aiwgeWpdID0gcG9seWdvbltqXSB8fCBbMCwgMF07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPj0geSAhPT0geWogPj0geSAmJiB4IDw9ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGk7XG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0luc2lkZTtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlKHBvaW50LCByZWN0KSB7XG4gIHJldHVybiBwb2ludFswXSA+PSByZWN0LnggJiYgcG9pbnRbMF0gPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiBwb2ludFsxXSA+PSByZWN0LnkgJiYgcG9pbnRbMV0gPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNhZmUgcG9seWdvbiBhcmVhIHRoYXQgdGhlIHVzZXIgY2FuIHRyYXZlcnNlIHdpdGhvdXQgY2xvc2luZyB0aGVcbiAqIGZsb2F0aW5nIGVsZW1lbnQgb25jZSBsZWF2aW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlciNzYWZlcG9seWdvblxuICovXG5mdW5jdGlvbiBzYWZlUG9seWdvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGJ1ZmZlciA9IDAuNSxcbiAgICBibG9ja1BvaW50ZXJFdmVudHMgPSBmYWxzZSxcbiAgICByZXF1aXJlSW50ZW50ID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGltZW91dFJlZiA9IHtcbiAgICBjdXJyZW50OiAtMVxuICB9O1xuICBsZXQgaGFzTGFuZGVkID0gZmFsc2U7XG4gIGxldCBsYXN0WCA9IG51bGw7XG4gIGxldCBsYXN0WSA9IG51bGw7XG4gIGxldCBsYXN0Q3Vyc29yVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBmdW5jdGlvbiBnZXRDdXJzb3JTcGVlZCh4LCB5KSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IGN1cnJlbnRUaW1lIC0gbGFzdEN1cnNvclRpbWU7XG4gICAgaWYgKGxhc3RYID09PSBudWxsIHx8IGxhc3RZID09PSBudWxsIHx8IGVsYXBzZWRUaW1lID09PSAwKSB7XG4gICAgICBsYXN0WCA9IHg7XG4gICAgICBsYXN0WSA9IHk7XG4gICAgICBsYXN0Q3Vyc29yVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhWCA9IHggLSBsYXN0WDtcbiAgICBjb25zdCBkZWx0YVkgPSB5IC0gbGFzdFk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgICBjb25zdCBzcGVlZCA9IGRpc3RhbmNlIC8gZWxhcHNlZFRpbWU7IC8vIHB4IC8gbXNcblxuICAgIGxhc3RYID0geDtcbiAgICBsYXN0WSA9IHk7XG4gICAgbGFzdEN1cnNvclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICByZXR1cm4gc3BlZWQ7XG4gIH1cbiAgY29uc3QgZm4gPSBfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG9uQ2xvc2UsXG4gICAgICBub2RlSWQsXG4gICAgICB0cmVlXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dFJlZik7XG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRSZWYpO1xuICAgICAgaWYgKCFlbGVtZW50cy5kb21SZWZlcmVuY2UgfHwgIWVsZW1lbnRzLmZsb2F0aW5nIHx8IHBsYWNlbWVudCA9PSBudWxsIHx8IHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBjbGllbnRQb2ludCA9IFtjbGllbnRYLCBjbGllbnRZXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICBjb25zdCBpc0xlYXZlID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnO1xuICAgICAgY29uc3QgaXNPdmVyRmxvYXRpbmdFbCA9IGNvbnRhaW5zKGVsZW1lbnRzLmZsb2F0aW5nLCB0YXJnZXQpO1xuICAgICAgY29uc3QgaXNPdmVyUmVmZXJlbmNlRWwgPSBjb250YWlucyhlbGVtZW50cy5kb21SZWZlcmVuY2UsIHRhcmdldCk7XG4gICAgICBjb25zdCByZWZSZWN0ID0gZWxlbWVudHMuZG9tUmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnRzLmZsb2F0aW5nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgc2lkZSA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgY29uc3QgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPSB4ID4gcmVjdC5yaWdodCAtIHJlY3Qud2lkdGggLyAyO1xuICAgICAgY29uc3QgY3Vyc29yTGVhdmVGcm9tQm90dG9tID0geSA+IHJlY3QuYm90dG9tIC0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgY29uc3QgaXNPdmVyUmVmZXJlbmNlUmVjdCA9IGlzSW5zaWRlKGNsaWVudFBvaW50LCByZWZSZWN0KTtcbiAgICAgIGNvbnN0IGlzRmxvYXRpbmdXaWRlciA9IHJlY3Qud2lkdGggPiByZWZSZWN0LndpZHRoO1xuICAgICAgY29uc3QgaXNGbG9hdGluZ1RhbGxlciA9IHJlY3QuaGVpZ2h0ID4gcmVmUmVjdC5oZWlnaHQ7XG4gICAgICBjb25zdCBsZWZ0ID0gKGlzRmxvYXRpbmdXaWRlciA/IHJlZlJlY3QgOiByZWN0KS5sZWZ0O1xuICAgICAgY29uc3QgcmlnaHQgPSAoaXNGbG9hdGluZ1dpZGVyID8gcmVmUmVjdCA6IHJlY3QpLnJpZ2h0O1xuICAgICAgY29uc3QgdG9wID0gKGlzRmxvYXRpbmdUYWxsZXIgPyByZWZSZWN0IDogcmVjdCkudG9wO1xuICAgICAgY29uc3QgYm90dG9tID0gKGlzRmxvYXRpbmdUYWxsZXIgPyByZWZSZWN0IDogcmVjdCkuYm90dG9tO1xuICAgICAgaWYgKGlzT3ZlckZsb2F0aW5nRWwpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpc0xlYXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNPdmVyUmVmZXJlbmNlRWwpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNPdmVyUmVmZXJlbmNlRWwgJiYgIWlzTGVhdmUpIHtcbiAgICAgICAgaGFzTGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2ZW50IG92ZXJsYXBwaW5nIGZsb2F0aW5nIGVsZW1lbnQgZnJvbSBiZWluZyBzdHVjayBpbiBhbiBvcGVuLWNsb3NlXG4gICAgICAvLyBsb29wOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE5MTBcbiAgICAgIGlmIChpc0xlYXZlICYmIGlzRWxlbWVudChldmVudC5yZWxhdGVkVGFyZ2V0KSAmJiBjb250YWlucyhlbGVtZW50cy5mbG9hdGluZywgZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhbnkgbmVzdGVkIGNoaWxkIGlzIG9wZW4sIGFib3J0LlxuICAgICAgaWYgKHRyZWUgJiYgZ2V0Tm9kZUNoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcG9pbnRlciBpcyBsZWF2aW5nIGZyb20gdGhlIG9wcG9zaXRlIHNpZGUsIHRoZSBcImJ1ZmZlclwiIGxvZ2ljXG4gICAgICAvLyBjcmVhdGVzIGEgcG9pbnQgd2hlcmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVtYWlucyBvcGVuLCBidXQgc2hvdWxkIGJlXG4gICAgICAvLyBpZ25vcmVkLlxuICAgICAgLy8gQSBjb25zdGFudCBvZiAxIGhhbmRsZXMgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzLlxuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnICYmIHkgPj0gcmVmUmVjdC5ib3R0b20gLSAxIHx8IHNpZGUgPT09ICdib3R0b20nICYmIHkgPD0gcmVmUmVjdC50b3AgKyAxIHx8IHNpZGUgPT09ICdsZWZ0JyAmJiB4ID49IHJlZlJlY3QucmlnaHQgLSAxIHx8IHNpZGUgPT09ICdyaWdodCcgJiYgeCA8PSByZWZSZWN0LmxlZnQgKyAxKSB7XG4gICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZ25vcmUgd2hlbiB0aGUgY3Vyc29yIGlzIHdpdGhpbiB0aGUgcmVjdGFuZ3VsYXIgdHJvdWdoIGJldHdlZW4gdGhlXG4gICAgICAvLyB0d28gZWxlbWVudHMuIFNpbmNlIHRoZSB0cmlhbmdsZSBpcyBjcmVhdGVkIGZyb20gdGhlIGN1cnNvciBwb2ludCxcbiAgICAgIC8vIHdoaWNoIGNhbiBzdGFydCBiZXlvbmQgdGhlIHJlZiBlbGVtZW50J3MgZWRnZSwgdHJhdmVyc2luZyBiYWNrIGFuZFxuICAgICAgLy8gZm9ydGggZnJvbSB0aGUgcmVmIHRvIHRoZSBmbG9hdGluZyBlbGVtZW50IGNhbiBjYXVzZSBpdCB0byBjbG9zZS4gVGhpc1xuICAgICAgLy8gZW5zdXJlcyBpdCBhbHdheXMgcmVtYWlucyBvcGVuIGluIHRoYXQgY2FzZS5cbiAgICAgIGxldCByZWN0UG9seSA9IFtdO1xuICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW2xlZnQsIHJlZlJlY3QudG9wICsgMV0sIFtsZWZ0LCByZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVmUmVjdC50b3AgKyAxXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW2xlZnQsIHJlY3QudG9wICsgMV0sIFtsZWZ0LCByZWZSZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlZlJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVjdC50b3AgKyAxXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tyZWN0LnJpZ2h0IC0gMSwgYm90dG9tXSwgW3JlY3QucmlnaHQgLSAxLCB0b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgdG9wXSwgW3JlZlJlY3QubGVmdCArIDEsIGJvdHRvbV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlZlJlY3QucmlnaHQgLSAxLCBib3R0b21dLCBbcmVmUmVjdC5yaWdodCAtIDEsIHRvcF0sIFtyZWN0LmxlZnQgKyAxLCB0b3BdLCBbcmVjdC5sZWZ0ICsgMSwgYm90dG9tXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRQb2x5Z29uKF9yZWYyKSB7XG4gICAgICAgIGxldCBbeCwgeV0gPSBfcmVmMjtcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbaXNGbG9hdGluZ1dpZGVyID8geCArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgKyBidWZmZXIgKyAxXTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbaXNGbG9hdGluZ1dpZGVyID8geCAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgKyBidWZmZXIgKyAxXTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tyZWN0LmxlZnQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IHJlY3QudG9wXSwgW3JlY3QucmlnaHQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gaXNGbG9hdGluZ1dpZGVyID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiByZWN0LnRvcCA6IHJlY3QuYm90dG9tIC0gYnVmZmVyXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW2lzRmxvYXRpbmdXaWRlciA/IHggKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5IC0gYnVmZmVyXTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbaXNGbG9hdGluZ1dpZGVyID8geCAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgLSBidWZmZXJdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW3JlY3QubGVmdCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyByZWN0LnRvcCArIGJ1ZmZlciA6IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QudG9wICsgYnVmZmVyIDogcmVjdC5ib3R0b21dLCBbcmVjdC5yaWdodCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LnRvcCArIGJ1ZmZlciA6IHJlY3QuYm90dG9tIDogcmVjdC50b3AgKyBidWZmZXJdXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW3ggKyBidWZmZXIgKyAxLCBpc0Zsb2F0aW5nVGFsbGVyID8geSArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbeCArIGJ1ZmZlciArIDEsIGlzRmxvYXRpbmdUYWxsZXIgPyB5IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IHJlY3QubGVmdCwgcmVjdC50b3BdLCBbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gYnVmZmVyLCByZWN0LmJvdHRvbV1dO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLmNvbW1vblBvaW50cywgY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW3ggLSBidWZmZXIsIGlzRmxvYXRpbmdUYWxsZXIgPyB5ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFt4IC0gYnVmZmVyLCBpc0Zsb2F0aW5nVGFsbGVyID8geSAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyByZWN0LmxlZnQgKyBidWZmZXIgOiBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogcmVjdC5yaWdodCwgcmVjdC50b3BdLCBbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IHJlY3QucmlnaHQgOiByZWN0LmxlZnQgKyBidWZmZXIsIHJlY3QuYm90dG9tXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNQb2ludEluUG9seWdvbihbY2xpZW50WCwgY2xpZW50WV0sIHJlY3RQb2x5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaGFzTGFuZGVkICYmICFpc092ZXJSZWZlcmVuY2VSZWN0KSB7XG4gICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0xlYXZlICYmIHJlcXVpcmVJbnRlbnQpIHtcbiAgICAgICAgY29uc3QgY3Vyc29yU3BlZWQgPSBnZXRDdXJzb3JTcGVlZChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgY29uc3QgY3Vyc29yU3BlZWRUaHJlc2hvbGQgPSAwLjE7XG4gICAgICAgIGlmIChjdXJzb3JTcGVlZCAhPT0gbnVsbCAmJiBjdXJzb3JTcGVlZCA8IGN1cnNvclNwZWVkVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNQb2ludEluUG9seWdvbihbY2xpZW50WCwgY2xpZW50WV0sIGdldFBvbHlnb24oW3gsIHldKSkpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWhhc0xhbmRlZCAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KGNsb3NlLCA0MCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgZm4uX19vcHRpb25zID0ge1xuICAgIGJsb2NrUG9pbnRlckV2ZW50c1xuICB9O1xuICByZXR1cm4gZm47XG59XG5cbmV4cG9ydCB7IENvbXBvc2l0ZSwgQ29tcG9zaXRlSXRlbSwgRmxvYXRpbmdBcnJvdywgRmxvYXRpbmdEZWxheUdyb3VwLCBGbG9hdGluZ0ZvY3VzTWFuYWdlciwgRmxvYXRpbmdMaXN0LCBGbG9hdGluZ05vZGUsIEZsb2F0aW5nT3ZlcmxheSwgRmxvYXRpbmdQb3J0YWwsIEZsb2F0aW5nVHJlZSwgTmV4dEZsb2F0aW5nRGVsYXlHcm91cCwgaW5uZXIsIHNhZmVQb2x5Z29uLCB1c2VDbGljaywgdXNlQ2xpZW50UG9pbnQsIHVzZURlbGF5R3JvdXAsIHVzZURlbGF5R3JvdXBDb250ZXh0LCB1c2VEaXNtaXNzLCB1c2VGbG9hdGluZywgdXNlRmxvYXRpbmdOb2RlSWQsIHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkLCB1c2VGbG9hdGluZ1BvcnRhbE5vZGUsIHVzZUZsb2F0aW5nUm9vdENvbnRleHQsIHVzZUZsb2F0aW5nVHJlZSwgdXNlRm9jdXMsIHVzZUhvdmVyLCB1c2VJZCwgdXNlSW5uZXJPZmZzZXQsIHVzZUludGVyYWN0aW9ucywgdXNlTGlzdEl0ZW0sIHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VNZXJnZVJlZnMsIHVzZU5leHREZWxheUdyb3VwLCB1c2VSb2xlLCB1c2VUcmFuc2l0aW9uU3RhdHVzLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCB1c2VUeXBlYWhlYWQgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZU1vZGVybkxheW91dEVmZmVjdCIsInVzZUVmZmVjdEV2ZW50IiwiZ2V0TWluTGlzdEluZGV4IiwiZ2V0TWF4TGlzdEluZGV4IiwiY3JlYXRlR3JpZENlbGxNYXAiLCJpc0xpc3RJbmRleERpc2FibGVkIiwiZ2V0R3JpZE5hdmlnYXRlZEluZGV4IiwiZ2V0R3JpZENlbGxJbmRleE9mQ29ybmVyIiwiZ2V0R3JpZENlbGxJbmRpY2VzIiwiZmluZE5vbkRpc2FibGVkTGlzdEluZGV4IiwiaXNJbmRleE91dE9mTGlzdEJvdW5kcyIsInVzZUxhdGVzdFJlZiIsImdldERvY3VtZW50IiwiZ2V0RG9jdW1lbnQkMSIsImlzTW91c2VMaWtlUG9pbnRlclR5cGUiLCJjb250YWlucyIsImNvbnRhaW5zJDEiLCJpc1NhZmFyaSIsImVuYWJsZUZvY3VzSW5zaWRlIiwiaXNPdXRzaWRlRXZlbnQiLCJnZXRQcmV2aW91c1RhYmJhYmxlIiwiZ2V0TmV4dFRhYmJhYmxlIiwiZGlzYWJsZUZvY3VzSW5zaWRlIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiZ2V0RmxvYXRpbmdGb2N1c0VsZW1lbnQiLCJnZXRUYWJiYWJsZU9wdGlvbnMiLCJnZXROb2RlQW5jZXN0b3JzIiwiYWN0aXZlRWxlbWVudCIsImdldE5vZGVDaGlsZHJlbiIsImdldE5vZGVDaGlsZHJlbiQxIiwic3RvcEV2ZW50IiwiZ2V0VGFyZ2V0IiwiZ2V0VGFyZ2V0JDEiLCJpc1ZpcnR1YWxDbGljayIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsImdldFBsYXRmb3JtIiwiaXNUeXBlYWJsZUVsZW1lbnQiLCJpc1JlYWN0RXZlbnQiLCJpc1Jvb3RFbGVtZW50IiwiaXNFdmVudFRhcmdldFdpdGhpbiIsIm1hdGNoZXNGb2N1c1Zpc2libGUiLCJpc01hYyIsImdldERlZXBlc3ROb2RlIiwiZ2V0VXNlckFnZW50IiwianN4IiwianN4cyIsIkZyYWdtZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzRWxlbWVudCIsImlzU2hhZG93Um9vdCIsImdldE5vZGVOYW1lIiwiaXNIVE1MRWxlbWVudCIsImdldFdpbmRvdyIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImdldFBhcmVudE5vZGUiLCJpc1dlYktpdCIsInRhYmJhYmxlIiwiaXNUYWJiYWJsZSIsImZvY3VzYWJsZSIsIlJlYWN0RE9NIiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJ1c2VGbG9hdGluZyIsInVzZUZsb2F0aW5nJDEiLCJvZmZzZXQiLCJkZXRlY3RPdmVyZmxvdyIsImFycm93IiwiYXV0b1BsYWNlbWVudCIsImF1dG9VcGRhdGUiLCJjb21wdXRlUG9zaXRpb24iLCJmbGlwIiwiaGlkZSIsImlubGluZSIsImxpbWl0U2hpZnQiLCJwbGF0Zm9ybSIsInNoaWZ0Iiwic2l6ZSIsImV2YWx1YXRlIiwibWF4Iiwicm91bmQiLCJtaW4iLCJ1c2VNZXJnZVJlZnMiLCJyZWZzIiwiY2xlYW51cFJlZiIsInVzZVJlZiIsInVuZGVmaW5lZCIsInJlZkVmZmVjdCIsInVzZUNhbGxiYWNrIiwiaW5zdGFuY2UiLCJjbGVhbnVwcyIsIm1hcCIsInJlZiIsInJlZkNhbGxiYWNrIiwicmVmQ2xlYW51cCIsImN1cnJlbnQiLCJmb3JFYWNoIiwidXNlTWVtbyIsImV2ZXJ5IiwidmFsdWUiLCJzb3J0QnlEb2N1bWVudFBvc2l0aW9uIiwiYSIsImIiLCJwb3NpdGlvbiIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiTm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSIsIkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TIiwiRmxvYXRpbmdMaXN0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJNYXAiLCJlbGVtZW50c1JlZiIsIkZsb2F0aW5nTGlzdCIsInByb3BzIiwiY2hpbGRyZW4iLCJsYWJlbHNSZWYiLCJub2RlcyIsInNldE5vZGVzIiwidXNlU3RhdGUiLCJTZXQiLCJub2RlIiwicHJldlNldCIsImFkZCIsInNldCIsImRlbGV0ZSIsIm5ld01hcCIsInNvcnRlZE5vZGVzIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInNvcnQiLCJpbmRleCIsIlByb3ZpZGVyIiwidXNlTGlzdEl0ZW0iLCJsYWJlbCIsInVzZUNvbnRleHQiLCJzZXRJbmRleCIsImNvbXBvbmVudFJlZiIsIl9ub2RlJHRleHRDb250ZW50IiwiaXNMYWJlbERlZmluZWQiLCJ0ZXh0Q29udGVudCIsImdldCIsIkZPQ1VTQUJMRV9BVFRSSUJVVEUiLCJBQ1RJVkVfS0VZIiwiU0VMRUNURURfS0VZIiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiQVJST1dfVVAiLCJBUlJPV19ET1dOIiwicmVuZGVySnN4IiwicmVuZGVyIiwiY29tcHV0ZWRQcm9wcyIsImNsb25lRWxlbWVudCIsIkNvbXBvc2l0ZUNvbnRleHQiLCJhY3RpdmVJbmRleCIsIm9uTmF2aWdhdGUiLCJob3Jpem9udGFsS2V5cyIsInZlcnRpY2FsS2V5cyIsImFsbEtleXMiLCJDb21wb3NpdGUiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZGVkUmVmIiwib3JpZW50YXRpb24iLCJsb29wIiwicnRsIiwiY29scyIsImRpc2FibGVkSW5kaWNlcyIsImV4dGVybmFsQWN0aXZlSW5kZXgiLCJleHRlcm5hbFNldEFjdGl2ZUluZGV4IiwiaXRlbVNpemVzIiwiZGVuc2UiLCJkb21Qcm9wcyIsImludGVybmFsQWN0aXZlSW5kZXgiLCJpbnRlcm5hbFNldEFjdGl2ZUluZGV4IiwicmVuZGVyRWxlbWVudFByb3BzIiwiY29udGV4dFZhbHVlIiwiaXNHcmlkIiwiaGFuZGxlS2V5RG93biIsImV2ZW50IiwiaW5jbHVkZXMiLCJrZXkiLCJuZXh0SW5kZXgiLCJtaW5JbmRleCIsIm1heEluZGV4IiwiaG9yaXpvbnRhbEVuZEtleSIsImhvcml6b250YWxTdGFydEtleSIsInNpemVzIiwibGVuZ3RoIiwid2lkdGgiLCJoZWlnaHQiLCJjZWxsTWFwIiwibWluR3JpZEluZGV4IiwiZmluZEluZGV4IiwibWF4R3JpZEluZGV4IiwicmVkdWNlIiwiZm91bmRJbmRleCIsImNlbGxJbmRleCIsIm1heWJlTmV4dEluZGV4IiwiaXRlbUluZGV4IiwiXyIsInByZXZJbmRleCIsInRvRW5kS2V5cyIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsImJvdGgiLCJ0b1N0YXJ0S2V5cyIsInByZXZlbnRlZEtleXMiLCJzdGFydGluZ0luZGV4IiwiZGVjcmVtZW50IiwiX2VsZW1lbnRzUmVmJGN1cnJlbnQkIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJmb2N1cyIsIm9uS2V5RG93biIsImUiLCJDb21wb3NpdGVJdGVtIiwibWVyZ2VkUmVmIiwiaXNBY3RpdmUiLCJ0YWJJbmRleCIsIm9uRm9jdXMiLCJTYWZlUmVhY3QiLCJzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUiLCJjb3VudCIsImdlbklkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJ1c2VGbG9hdGluZ0lkIiwiaWQiLCJzZXRJZCIsInVzZUVmZmVjdCIsInVzZVJlYWN0SWQiLCJ1c2VJZCIsImRldk1lc3NhZ2VTZXQiLCJwcm9jZXNzIiwid2FybiIsIl9kZXZNZXNzYWdlU2V0IiwiX2xlbiIsImFyZ3VtZW50cyIsIm1lc3NhZ2VzIiwiX2tleSIsIm1lc3NhZ2UiLCJqb2luIiwiaGFzIiwiX2Rldk1lc3NhZ2VTZXQyIiwiY29uc29sZSIsImVycm9yIiwiX2Rldk1lc3NhZ2VTZXQzIiwiX2xlbjIiLCJfa2V5MiIsIl9kZXZNZXNzYWdlU2V0NCIsIkZsb2F0aW5nQXJyb3ciLCJjb250ZXh0IiwicGxhY2VtZW50IiwiZWxlbWVudHMiLCJmbG9hdGluZyIsIm1pZGRsZXdhcmVEYXRhIiwidGlwUmFkaXVzIiwic3Ryb2tlV2lkdGgiLCJzdGF0aWNPZmZzZXQiLCJzdHJva2UiLCJkIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJyZXN0U3R5bGUiLCJyZXN0IiwiY2xpcFBhdGhJZCIsImlzUlRMIiwic2V0SXNSVEwiLCJkaXJlY3Rpb24iLCJzaWRlIiwiYWxpZ25tZW50Iiwic3BsaXQiLCJpc1ZlcnRpY2FsU2lkZSIsImNvbXB1dGVkU3RhdGljT2Zmc2V0IiwieCIsInkiLCJjb21wdXRlZFN0cm9rZVdpZHRoIiwiaGFsZlN0cm9rZVdpZHRoIiwic3ZnWCIsInN2Z1kiLCJpc0N1c3RvbVNoYXBlIiwieU9mZnNldFByb3AiLCJ4T2Zmc2V0UHJvcCIsImFycm93WCIsImFycm93WSIsImRWYWx1ZSIsInJvdGF0aW9uIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0Iiwidmlld0JveCIsInBvaW50ZXJFdmVudHMiLCJmaWx0ZXIiLCJ0IiwiY2xpcFBhdGgiLCJmaWxsIiwiY3JlYXRlRXZlbnRFbWl0dGVyIiwiZW1pdCIsImRhdGEiLCJfbWFwJGdldCIsImxpc3RlbmVyIiwib24iLCJvZmYiLCJfbWFwJGdldDIiLCJGbG9hdGluZ05vZGVDb250ZXh0IiwiRmxvYXRpbmdUcmVlQ29udGV4dCIsInVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkIiwiX1JlYWN0JHVzZUNvbnRleHQiLCJ1c2VGbG9hdGluZ1RyZWUiLCJ1c2VGbG9hdGluZ05vZGVJZCIsImN1c3RvbVBhcmVudElkIiwidHJlZSIsInJlYWN0UGFyZW50SWQiLCJwYXJlbnRJZCIsImFkZE5vZGUiLCJyZW1vdmVOb2RlIiwiRmxvYXRpbmdOb2RlIiwiRmxvYXRpbmdUcmVlIiwibm9kZXNSZWYiLCJuIiwiZXZlbnRzIiwiY3JlYXRlQXR0cmlidXRlIiwibmFtZSIsImNsZWFyVGltZW91dElmU2V0IiwidGltZW91dFJlZiIsImNsZWFyVGltZW91dCIsInNhZmVQb2x5Z29uSWRlbnRpZmllciIsImdldERlbGF5IiwicHJvcCIsInBvaW50ZXJUeXBlIiwicmVzdWx0IiwiZ2V0UmVzdE1zIiwidXNlSG92ZXIiLCJvcGVuIiwib25PcGVuQ2hhbmdlIiwiZGF0YVJlZiIsImVuYWJsZWQiLCJkZWxheSIsImhhbmRsZUNsb3NlIiwibW91c2VPbmx5IiwicmVzdE1zIiwibW92ZSIsImhhbmRsZUNsb3NlUmVmIiwiZGVsYXlSZWYiLCJvcGVuUmVmIiwicmVzdE1zUmVmIiwicG9pbnRlclR5cGVSZWYiLCJoYW5kbGVyUmVmIiwicmVzdFRpbWVvdXRSZWYiLCJibG9ja01vdXNlTW92ZVJlZiIsInBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZiIsInVuYmluZE1vdXNlTW92ZVJlZiIsInJlc3RUaW1lb3V0UGVuZGluZ1JlZiIsImlzSG92ZXJPcGVuIiwiX2RhdGFSZWYkY3VycmVudCRvcGVuIiwidHlwZSIsIm9wZW5FdmVudCIsIl9yZWYiLCJvbkxlYXZlIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xvc2VXaXRoRGVsYXkiLCJydW5FbHNlQnJhbmNoIiwicmVhc29uIiwiY2xvc2VEZWxheSIsIndpbmRvdyIsInNldFRpbWVvdXQiLCJjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciIsImNsZWFyUG9pbnRlckV2ZW50cyIsImJvZHkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpc0NsaWNrTGlrZU9wZW5FdmVudCIsIm9uUmVmZXJlbmNlTW91c2VFbnRlciIsIm9wZW5EZWxheSIsIm9uUmVmZXJlbmNlTW91c2VMZWF2ZSIsImRvYyIsImZsb2F0aW5nQ29udGV4dCIsImNsaWVudFgiLCJjbGllbnRZIiwib25DbG9zZSIsImhhbmRsZXIiLCJzaG91bGRDbG9zZSIsInJlbGF0ZWRUYXJnZXQiLCJvblNjcm9sbE1vdXNlTGVhdmUiLCJvbkZsb2F0aW5nTW91c2VFbnRlciIsIm9uRmxvYXRpbmdNb3VzZUxlYXZlIiwiZG9tUmVmZXJlbmNlIiwicmVmZXJlbmNlIiwib25jZSIsIl9oYW5kbGVDbG9zZVJlZiRjdXJyZSIsIl9fb3B0aW9ucyIsImJsb2NrUG9pbnRlckV2ZW50cyIsImZsb2F0aW5nRWwiLCJfdHJlZSRub2Rlc1JlZiRjdXJyZW4iLCJzZXRBdHRyaWJ1dGUiLCJwYXJlbnRGbG9hdGluZyIsImZpbmQiLCJzZXRQb2ludGVyUmVmIiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlckVudGVyIiwib25Nb3VzZU1vdmUiLCJuYXRpdmVFdmVudCIsImhhbmRsZU1vdXNlTW92ZSIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsIk5PT1AiLCJGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0IiwiaW5pdGlhbERlbGF5IiwidGltZW91dE1zIiwiY3VycmVudElkIiwic2V0Q3VycmVudElkIiwic2V0U3RhdGUiLCJpc0luc3RhbnRQaGFzZSIsInVzZURlbGF5R3JvdXBDb250ZXh0IiwiRmxvYXRpbmdEZWxheUdyb3VwIiwic3RhdGUiLCJ1c2VSZWR1Y2VyIiwicHJldiIsIm5leHQiLCJpbml0aWFsQ3VycmVudElkUmVmIiwidXNlRGVsYXlHcm91cCIsIm9wdGlvbnMiLCJmbG9hdGluZ0lkIiwib3B0aW9uSWQiLCJncm91cENvbnRleHQiLCJjbG9zZSIsInVuc2V0IiwidGltZW91dCIsIk5leHRGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0IiwiaGFzUHJvdmlkZXIiLCJpbml0aWFsRGVsYXlSZWYiLCJ0aW1lb3V0SWRSZWYiLCJjdXJyZW50SWRSZWYiLCJjdXJyZW50Q29udGV4dFJlZiIsIk5leHRGbG9hdGluZ0RlbGF5R3JvdXAiLCJ1c2VOZXh0RGVsYXlHcm91cCIsInNldElzSW5zdGFudFBoYXNlIiwiX2N1cnJlbnRDb250ZXh0UmVmJGN1IiwicHJldkNvbnRleHQiLCJwcmV2SWQiLCJyYWZJZCIsImVucXVldWVGb2N1cyIsImVsIiwicHJldmVudFNjcm9sbCIsImNhbmNlbFByZXZpb3VzIiwic3luYyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZXhlYyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInBhcmVudCIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsInBhcmVudE5vZGUiLCJob3N0IiwiY29tcG9zZWRQYXRoIiwidGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50IiwiY291bnRlcnMiLCJpbmVydCIsIldlYWtNYXAiLCJub25lIiwiZ2V0Q291bnRlck1hcCIsImNvbnRyb2wiLCJ1bmNvbnRyb2xsZWRFbGVtZW50c1NldCIsIldlYWtTZXQiLCJtYXJrZXJNYXAiLCJsb2NrQ291bnQkMSIsInN1cHBvcnRzSW5lcnQiLCJIVE1MRWxlbWVudCIsInByb3RvdHlwZSIsInVud3JhcEhvc3QiLCJjb3JyZWN0RWxlbWVudHMiLCJ0YXJnZXRzIiwiY29ycmVjdGVkVGFyZ2V0IiwiYXBwbHlBdHRyaWJ1dGVUb090aGVycyIsInVuY29ycmVjdGVkQXZvaWRFbGVtZW50cyIsImFyaWFIaWRkZW4iLCJtYXJrZXJOYW1lIiwiY29udHJvbEF0dHJpYnV0ZSIsImF2b2lkRWxlbWVudHMiLCJlbGVtZW50c1RvS2VlcCIsImVsZW1lbnRzVG9TdG9wIiwiaGlkZGVuRWxlbWVudHMiLCJtYXJrZXJDb3VudGVyIiwia2VlcCIsImRlZXAiLCJjbGVhciIsImNhbGwiLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwiYWxyZWFkeUhpZGRlbiIsImNvdW50ZXJNYXAiLCJjb3VudGVyVmFsdWUiLCJtYXJrZXJWYWx1ZSIsInB1c2giLCJlbGVtZW50IiwiY3VycmVudENvdW50ZXJWYWx1ZSIsIm1hcmtPdGhlcnMiLCJjb25jYXQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiSElEREVOX1NUWUxFUyIsImJvcmRlciIsImNsaXAiLCJtYXJnaW4iLCJvdmVyZmxvdyIsInBhZGRpbmciLCJ3aGl0ZVNwYWNlIiwiRm9jdXNHdWFyZCIsInJvbGUiLCJzZXRSb2xlIiwicmVzdFByb3BzIiwiUG9ydGFsQ29udGV4dCIsInVzZUZsb2F0aW5nUG9ydGFsTm9kZSIsInJvb3QiLCJ1bmlxdWVJZCIsInBvcnRhbENvbnRleHQiLCJ1c2VQb3J0YWxDb250ZXh0IiwicG9ydGFsTm9kZSIsInNldFBvcnRhbE5vZGUiLCJwb3J0YWxOb2RlUmVmIiwicmVtb3ZlIiwicXVldWVNaWNyb3Rhc2siLCJleGlzdGluZ0lkUm9vdCIsImdldEVsZW1lbnRCeUlkIiwic3ViUm9vdCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNvbnRhaW5lciIsImlkV3JhcHBlciIsIkZsb2F0aW5nUG9ydGFsIiwicHJlc2VydmVUYWJPcmRlciIsImZvY3VzTWFuYWdlclN0YXRlIiwic2V0Rm9jdXNNYW5hZ2VyU3RhdGUiLCJiZWZvcmVPdXRzaWRlUmVmIiwiYWZ0ZXJPdXRzaWRlUmVmIiwiYmVmb3JlSW5zaWRlUmVmIiwiYWZ0ZXJJbnNpZGVSZWYiLCJtb2RhbCIsInNob3VsZFJlbmRlckd1YXJkcyIsImZvY3VzaW5nIiwibWFuYWdlRm9jdXMiLCJfYmVmb3JlSW5zaWRlUmVmJGN1cnIiLCJwcmV2VGFiYmFibGUiLCJjcmVhdGVQb3J0YWwiLCJfYWZ0ZXJJbnNpZGVSZWYkY3VycmUiLCJuZXh0VGFiYmFibGUiLCJjbG9zZU9uRm9jdXNPdXQiLCJ1c2VMaXRlTWVyZ2VSZWZzIiwiTElTVF9MSU1JVCIsInByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMiLCJhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQiLCJpc0Nvbm5lY3RlZCIsImdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsInJldmVyc2UiLCJnZXRGaXJzdFRhYmJhYmxlRWxlbWVudCIsInRhYmJhYmxlT3B0aW9ucyIsImhhbmRsZVRhYkluZGV4IiwiZmxvYXRpbmdGb2N1c0VsZW1lbnQiLCJvcmRlclJlZiIsIl9mbG9hdGluZ0ZvY3VzRWxlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwidGFiYmFibGVDb250ZW50IiwiZGF0YVRhYkluZGV4IiwiaGFzQXR0cmlidXRlIiwic3RhcnRzV2l0aCIsIlZpc3VhbGx5SGlkZGVuRGlzbWlzcyIsIkZsb2F0aW5nRm9jdXNNYW5hZ2VyIiwiZGlzYWJsZWQiLCJvcmRlciIsImd1YXJkcyIsIl9ndWFyZHMiLCJpbml0aWFsRm9jdXMiLCJyZXR1cm5Gb2N1cyIsInJlc3RvcmVGb2N1cyIsInZpc3VhbGx5SGlkZGVuRGlzbWlzcyIsIm91dHNpZGVFbGVtZW50c0luZXJ0IiwiZ2V0SW5zaWRlRWxlbWVudHMiLCJfZ2V0SW5zaWRlRWxlbWVudHMiLCJnZXROb2RlSWQiLCJfZGF0YVJlZiRjdXJyZW50JGZsb2EiLCJub2RlSWQiLCJpZ25vcmVJbml0aWFsRm9jdXMiLCJpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3giLCJpbmVydFN1cHBvcnRlZCIsInVzZUluZXJ0IiwiaW5pdGlhbEZvY3VzUmVmIiwicmV0dXJuRm9jdXNSZWYiLCJzdGFydERpc21pc3NCdXR0b25SZWYiLCJlbmREaXNtaXNzQnV0dG9uUmVmIiwicHJldmVudFJldHVybkZvY3VzUmVmIiwiaXNQb2ludGVyRG93blJlZiIsInRhYmJhYmxlSW5kZXhSZWYiLCJpc0luc2lkZVBvcnRhbCIsImdldFRhYmJhYmxlQ29udGVudCIsImdldFRhYmJhYmxlRWxlbWVudHMiLCJjb250ZW50IiwiQm9vbGVhbiIsImZsYXQiLCJlbHMiLCJzaGlmdEtleSIsImhhbmRsZUZvY3VzSW4iLCJ0YWJiYWJsZUluZGV4IiwiaW5kZXhPZiIsImhhbmRsZVBvaW50ZXJEb3duIiwiaGFuZGxlRm9jdXNPdXRzaWRlIiwiY3VycmVudFRhcmdldCIsIm1vdmVkVG9VbnJlbGF0ZWROb2RlIiwiX25vZGUkY29udGV4dCIsIl9ub2RlJGNvbnRleHQyIiwiX25vZGUkY29udGV4dDMiLCJfbm9kZSRjb250ZXh0NCIsIl9ub2RlJGNvbnRleHQ1IiwicHJldlRhYmJhYmxlSW5kZXgiLCJub2RlVG9Gb2N1cyIsImluc2lkZVJlYWN0VHJlZSIsImJlZm9yZUd1YXJkUmVmIiwiYWZ0ZXJHdWFyZFJlZiIsIm1lcmdlZEJlZm9yZUd1YXJkUmVmIiwibWVyZ2VkQWZ0ZXJHdWFyZFJlZiIsIl9wb3J0YWxDb250ZXh0JHBvcnRhbCIsIl9hbmNlc3RvcnMkZmluZCIsInBvcnRhbE5vZGVzIiwiYW5jZXN0b3JzIiwiYW5jZXN0b3JGbG9hdGluZ05vZGVzIiwiX25vZGUkY29udGV4dDYiLCJyb290QW5jZXN0b3JDb21ib2JveERvbVJlZmVyZW5jZSIsIl9ub2RlJGNvbnRleHQ3IiwiaW5zaWRlRWxlbWVudHMiLCJjbGVhbnVwIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiaW5pdGlhbEZvY3VzVmFsdWUiLCJlbFRvRm9jdXMiLCJmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsIiwibmVzdGVkIiwiaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkIiwiZmFsbGJhY2tFbCIsIk9iamVjdCIsImFzc2lnbiIsImluc2VydEFkamFjZW50RWxlbWVudCIsImdldFJldHVybkVsZW1lbnQiLCJhY3RpdmVFbCIsImlzRm9jdXNJbnNpZGVGbG9hdGluZ1RyZWUiLCJzb21lIiwiX25vZGUkY29udGV4dDgiLCJyZXR1cm5FbGVtZW50IiwidGFiYmFibGVSZXR1cm5FbGVtZW50IiwicmVuZGVyRGlzbWlzc0J1dHRvbiIsImxvY2F0aW9uIiwib25DbGljayIsIl9wb3J0YWxDb250ZXh0JGJlZm9yZSIsIl9wb3J0YWxDb250ZXh0JGFmdGVyTyIsImxvY2tDb3VudCIsInNjcm9sbGJhclByb3BlcnR5IiwiZW5hYmxlU2Nyb2xsTG9jayIsImlzSU9TIiwidGVzdCIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiYm9keVN0eWxlIiwic2Nyb2xsYmFyWCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbExlZnQiLCJwYWRkaW5nUHJvcCIsInNjcm9sbGJhcldpZHRoIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsWCIsInBhcnNlRmxvYXQiLCJzY3JvbGxZIiwic2V0UHJvcGVydHkiLCJfd2luZG93JHZpc3VhbFZpZXdwb3IiLCJfd2luZG93JHZpc3VhbFZpZXdwb3IyIiwib2Zmc2V0TGVmdCIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0VG9wIiwiZmxvb3IiLCJyZW1vdmVQcm9wZXJ0eSIsInNjcm9sbFRvIiwiRmxvYXRpbmdPdmVybGF5IiwibG9ja1Njcm9sbCIsImlzQnV0dG9uVGFyZ2V0IiwidGFnTmFtZSIsImlzQW5jaG9yVGFyZ2V0IiwiaXNTcGFjZUlnbm9yZWQiLCJ1c2VDbGljayIsImV2ZW50T3B0aW9uIiwidG9nZ2xlIiwiaWdub3JlTW91c2UiLCJrZXlib2FyZEhhbmRsZXJzIiwic3RpY2tJZk9wZW4iLCJkaWRLZXlEb3duUmVmIiwib25Nb3VzZURvd24iLCJidXR0b24iLCJkZWZhdWx0UHJldmVudGVkIiwib25LZXlVcCIsImNyZWF0ZVZpcnR1YWxFbGVtZW50IiwiZG9tRWxlbWVudCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiaXNBdXRvVXBkYXRlRXZlbnQiLCJjb250ZXh0RWxlbWVudCIsIl9kYXRhJGRhdGFSZWYkY3VycmVudCIsImRvbVJlY3QiLCJpc1hBeGlzIiwiYXhpcyIsImlzWUF4aXMiLCJjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSIsImlzTW91c2VCYXNlZEV2ZW50IiwidXNlQ2xpZW50UG9pbnQiLCJpbml0aWFsUmVmIiwiY2xlYW51cExpc3RlbmVyUmVmIiwic2V0UG9pbnRlclR5cGUiLCJyZWFjdGl2ZSIsInNldFJlYWN0aXZlIiwic2V0UmVmZXJlbmNlIiwic2V0UG9zaXRpb25SZWZlcmVuY2UiLCJoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSIsIm9wZW5DaGVjayIsImFkZExpc3RlbmVyIiwid2luIiwic2V0UG9pbnRlclR5cGVSZWYiLCJvbk1vdXNlRW50ZXIiLCJidWJibGVIYW5kbGVyS2V5cyIsInBvaW50ZXJkb3duIiwibW91c2Vkb3duIiwiY2xpY2siLCJjYXB0dXJlSGFuZGxlcktleXMiLCJub3JtYWxpemVQcm9wIiwibm9ybWFsaXphYmxlIiwiX25vcm1hbGl6YWJsZSRlc2NhcGVLIiwiX25vcm1hbGl6YWJsZSRvdXRzaWRlIiwiZXNjYXBlS2V5Iiwib3V0c2lkZVByZXNzIiwidXNlRGlzbWlzcyIsInVuc3RhYmxlX291dHNpZGVQcmVzcyIsIm91dHNpZGVQcmVzc0V2ZW50IiwicmVmZXJlbmNlUHJlc3MiLCJyZWZlcmVuY2VQcmVzc0V2ZW50IiwiYW5jZXN0b3JTY3JvbGwiLCJidWJibGVzIiwiY2FwdHVyZSIsIm91dHNpZGVQcmVzc0ZuIiwiZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYiLCJlc2NhcGVLZXlCdWJibGVzIiwib3V0c2lkZVByZXNzQnViYmxlcyIsImVzY2FwZUtleUNhcHR1cmUiLCJvdXRzaWRlUHJlc3NDYXB0dXJlIiwiaXNDb21wb3NpbmdSZWYiLCJibHVyVGltZW91dFJlZiIsImNsb3NlT25Fc2NhcGVLZXlEb3duIiwic2hvdWxkRGlzbWlzcyIsIl9jaGlsZCRjb250ZXh0IiwiX19lc2NhcGVLZXlCdWJibGVzIiwiY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIiwiX2dldFRhcmdldDIiLCJjYWxsYmFjayIsIl9nZXRUYXJnZXQiLCJjbG9zZU9uUHJlc3NPdXRzaWRlIiwiX2RhdGFSZWYkY3VycmVudCRmbG9hMiIsImVuZGVkT3JTdGFydGVkSW5zaWRlIiwiaW5lcnRTZWxlY3RvciIsIm1hcmtlcnMiLCJ0YXJnZXRSb290QW5jZXN0b3IiLCJuZXh0UGFyZW50IiwibWFya2VyIiwibGFzdFRyYXZlcnNhYmxlTm9kZSIsInNjcm9sbFJlIiwiaXNTY3JvbGxhYmxlWCIsIm92ZXJmbG93WCIsImlzU2Nyb2xsYWJsZVkiLCJvdmVyZmxvd1kiLCJjYW5TY3JvbGxYIiwic2Nyb2xsV2lkdGgiLCJjYW5TY3JvbGxZIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwicHJlc3NlZFZlcnRpY2FsU2Nyb2xsYmFyIiwib2Zmc2V0V2lkdGgiLCJwcmVzc2VkSG9yaXpvbnRhbFNjcm9sbGJhciIsInRhcmdldElzSW5zaWRlQ2hpbGRyZW4iLCJfY2hpbGQkY29udGV4dDIiLCJfX291dHNpZGVQcmVzc0J1YmJsZXMiLCJjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSIsIl9nZXRUYXJnZXQ0IiwiX2dldFRhcmdldDMiLCJjb21wb3NpdGlvblRpbWVvdXQiLCJvblNjcm9sbCIsImhhbmRsZUNvbXBvc2l0aW9uU3RhcnQiLCJoYW5kbGVDb21wb3NpdGlvbkVuZCIsImFuY2VzdG9yIiwiX2RvYyRkZWZhdWx0VmlldyIsImRlZmF1bHRWaWV3IiwicGFzc2l2ZSIsIm9uTW91c2VVcCIsIm9uQmx1ckNhcHR1cmUiLCJ1c2VGbG9hdGluZ1Jvb3RDb250ZXh0Iiwib25PcGVuQ2hhbmdlUHJvcCIsImVsZW1lbnRzUHJvcCIsIm9wdGlvbkRvbVJlZmVyZW5jZSIsInBvc2l0aW9uUmVmZXJlbmNlIiwiaW50ZXJuYWxSb290Q29udGV4dCIsInJvb3RDb250ZXh0IiwiY29tcHV0ZWRFbGVtZW50cyIsIl9kb21SZWZlcmVuY2UiLCJzZXREb21SZWZlcmVuY2UiLCJfc2V0UG9zaXRpb25SZWZlcmVuY2UiLCJkb21SZWZlcmVuY2VSZWYiLCJjb21wdXRlZFBvc2l0aW9uUmVmZXJlbmNlIiwiZ2V0Q2xpZW50UmVjdHMiLCJpc01hY1NhZmFyaSIsInVzZUZvY3VzIiwidmlzaWJsZU9ubHkiLCJibG9ja0ZvY3VzUmVmIiwia2V5Ym9hcmRNb2RhbGl0eVJlZiIsIm9uQmx1ciIsIm9uTW91c2VMZWF2ZSIsIm1vdmVkVG9Gb2N1c0d1YXJkIiwibWVyZ2VQcm9wcyIsInVzZXJQcm9wcyIsInByb3BzTGlzdCIsImVsZW1lbnRLZXkiLCJpc0l0ZW0iLCJkb21Vc2VyUHJvcHMiLCJfXyIsInZhbGlkUHJvcHMiLCJwcm9wc09yR2V0UHJvcHMiLCJhY2MiLCJlbnRyaWVzIiwiYXJncyIsImZuIiwidmFsIiwidXNlSW50ZXJhY3Rpb25zIiwicmVmZXJlbmNlRGVwcyIsImZsb2F0aW5nRGVwcyIsIml0ZW1EZXBzIiwiaXRlbSIsImdldFJlZmVyZW5jZVByb3BzIiwiZ2V0RmxvYXRpbmdQcm9wcyIsImdldEl0ZW1Qcm9wcyIsIkVTQ0FQRSIsImRvU3dpdGNoIiwiaXNNYWluT3JpZW50YXRpb25LZXkiLCJpc01haW5PcmllbnRhdGlvblRvRW5kS2V5IiwiaXNDcm9zc09yaWVudGF0aW9uT3BlbktleSIsImlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5IiwidXNlTGlzdE5hdmlnYXRpb24iLCJsaXN0UmVmIiwidW5zdGFibGVfb25OYXZpZ2F0ZSIsInNlbGVjdGVkSW5kZXgiLCJhbGxvd0VzY2FwZSIsInZpcnR1YWwiLCJmb2N1c0l0ZW1Pbk9wZW4iLCJmb2N1c0l0ZW1PbkhvdmVyIiwib3Blbk9uQXJyb3dLZXlEb3duIiwicGFyZW50T3JpZW50YXRpb24iLCJzY3JvbGxJdGVtSW50b1ZpZXciLCJ2aXJ0dWFsSXRlbVJlZiIsImZsb2F0aW5nRm9jdXNFbGVtZW50UmVmIiwiaW5kZXhSZWYiLCJ0eXBlYWJsZUNvbWJvYm94UmVmZXJlbmNlIiwiZm9jdXNJdGVtT25PcGVuUmVmIiwia2V5UmVmIiwiaXNQb2ludGVyTW9kYWxpdHlSZWYiLCJwcmV2aW91c09uTmF2aWdhdGVSZWYiLCJwcmV2aW91c01vdW50ZWRSZWYiLCJwcmV2aW91c09wZW5SZWYiLCJmb3JjZVN5bmNGb2N1c1JlZiIsImZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYiLCJkaXNhYmxlZEluZGljZXNSZWYiLCJsYXRlc3RPcGVuUmVmIiwic2Nyb2xsSXRlbUludG9WaWV3UmVmIiwic2VsZWN0ZWRJbmRleFJlZiIsImFjdGl2ZUlkIiwic2V0QWN0aXZlSWQiLCJ2aXJ0dWFsSWQiLCJzZXRWaXJ0dWFsSWQiLCJmb2N1c0l0ZW0iLCJydW5Gb2N1cyIsIl9pdGVtJGlkIiwiZW5kc1dpdGgiLCJpbml0aWFsSXRlbSIsImZvcmNlU2Nyb2xsSW50b1ZpZXciLCJzY2hlZHVsZXIiLCJ2Iiwid2FpdGVkSXRlbSIsInNjcm9sbEludG9WaWV3T3B0aW9ucyIsInNob3VsZFNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsInJ1bnMiLCJ3YWl0Rm9yTGlzdFBvcHVsYXRlZCIsIl9ub2RlcyRmaW5kIiwidHJlZUNvbnRhaW5zQWN0aXZlRWwiLCJoYW5kbGVWaXJ0dWFsRm9jdXMiLCJoYXNBY3RpdmVJbmRleCIsInN5bmNDdXJyZW50VGFyZ2V0IiwiX3JlZjIiLCJfcmVmMyIsIm9uUG9pbnRlckxlYXZlIiwiX3JlZjQiLCJnZXRQYXJlbnRPcmllbnRhdGlvbiIsImNvbW1vbk9uS2V5RG93biIsIndoaWNoIiwiY3VycmVudEluZGV4IiwiYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wIiwib25Qb2ludGVyTW92ZSIsImNoZWNrVmlydHVhbE1vdXNlIiwiY2hlY2tWaXJ0dWFsUG9pbnRlciIsImlzQXJyb3dLZXkiLCJpc0hvbWVPckVuZEtleSIsImlzTW92ZUtleSIsImlzQ3Jvc3NPcGVuS2V5IiwiaXNDcm9zc0Nsb3NlS2V5IiwiaXNQYXJlbnRDcm9zc09wZW5LZXkiLCJpc01haW5LZXkiLCJpc05hdmlnYXRpb25LZXkiLCJ0cmltIiwiZGVlcGVzdE5vZGUiLCJldmVudE9iamVjdCIsIktleWJvYXJkRXZlbnQiLCJfZGVlcGVzdE5vZGUkY29udGV4dCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0MiIsImlzQ3VycmVudFRhcmdldCIsImRpc3BhdGNoSXRlbSIsImRpc3BhdGNoRXZlbnQiLCJfZGVlcGVzdE5vZGUkY29udGV4dCQiLCJpc1BhcmVudE1haW5LZXkiLCJjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCIsInVzZVJvbGUiLCJfZWxlbWVudHMkZG9tUmVmZXJlbmMiLCJfY29tcG9uZW50Um9sZVRvQXJpYVIiLCJkZWZhdWx0RmxvYXRpbmdJZCIsImRlZmF1bHRSZWZlcmVuY2VJZCIsInJlZmVyZW5jZUlkIiwiX2dldEZsb2F0aW5nRm9jdXNFbGVtIiwiYXJpYVJvbGUiLCJpc05lc3RlZCIsImZsb2F0aW5nUHJvcHMiLCJhY3RpdmUiLCJzZWxlY3RlZCIsImNvbW1vblByb3BzIiwiY2FtZWxDYXNlVG9LZWJhYkNhc2UiLCJzdHIiLCJyZXBsYWNlIiwiJCIsIm9mcyIsInRvTG93ZXJDYXNlIiwiZXhlY1dpdGhBcmdzT3JSZXR1cm4iLCJ2YWx1ZU9yRm4iLCJ1c2VEZWxheVVubW91bnQiLCJkdXJhdGlvbk1zIiwiaXNNb3VudGVkIiwic2V0SXNNb3VudGVkIiwidXNlVHJhbnNpdGlvblN0YXR1cyIsImR1cmF0aW9uIiwiaXNOdW1iZXJEdXJhdGlvbiIsImNsb3NlRHVyYXRpb24iLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJmcmFtZSIsImZsdXNoU3luYyIsInVzZVRyYW5zaXRpb25TdHlsZXMiLCJpbml0aWFsIiwidW5zdGFibGVfaW5pdGlhbCIsIm9wYWNpdHkiLCJ1bnN0YWJsZV9vcGVuIiwidW5zdGFibGVfY2xvc2UiLCJjb21tb24iLCJ1bnN0YWJsZV9jb21tb24iLCJmbkFyZ3MiLCJvcGVuRHVyYXRpb24iLCJzdHlsZXMiLCJzZXRTdHlsZXMiLCJjbG9zZVJlZiIsImNvbW1vblJlZiIsImluaXRpYWxTdHlsZXMiLCJjbG9zZVN0eWxlcyIsImNvbW1vblN0eWxlcyIsIm9wZW5TdHlsZXMiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ1c2VUeXBlYWhlYWQiLCJvbk1hdGNoIiwidW5zdGFibGVfb25NYXRjaCIsIm9uVHlwaW5nQ2hhbmdlIiwidW5zdGFibGVfb25UeXBpbmdDaGFuZ2UiLCJmaW5kTWF0Y2giLCJyZXNldE1zIiwiaWdub3JlS2V5cyIsInN0cmluZ1JlZiIsInByZXZJbmRleFJlZiIsIm1hdGNoSW5kZXhSZWYiLCJmaW5kTWF0Y2hSZWYiLCJpZ25vcmVLZXlzUmVmIiwic2V0VHlwaW5nQ2hhbmdlIiwidHlwaW5nIiwiZ2V0TWF0Y2hpbmdJbmRleCIsImxpc3QiLCJvcmRlcmVkTGlzdCIsInN0cmluZyIsInRleHQiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImxpc3RDb250ZW50IiwiY3RybEtleSIsIm1ldGFLZXkiLCJhbHRLZXkiLCJhbGxvd1JhcGlkU3VjY2Vzc2lvbk9mRmlyc3RMZXR0ZXIiLCJfdGV4dCQiLCJfdGV4dCQyIiwiZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodCIsInJlY3RzIiwiaW5uZXIiLCJvdmVyZmxvd1JlZiIsIm9uRmFsbGJhY2tDaGFuZ2UiLCJpbm5lck9mZnNldCIsIm1pbkl0ZW1zVmlzaWJsZSIsInJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkIiwic2Nyb2xsUmVmIiwiZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIiwic2Nyb2xsRWwiLCJjbGllbnRUb3AiLCJmbG9hdGluZ0lzQm9yZGVyZWQiLCJzY3JvbGxFbElzQm9yZGVyZWQiLCJmbG9hdGluZ0lzU2Nyb2xsRWwiLCJuZXh0QXJncyIsIm9mZnNldEhlaWdodCIsInJlZk92ZXJmbG93IiwiZWxlbWVudENvbnRleHQiLCJkaWZmWSIsIm5leHRZIiwiaXNTY3JvbGxhYmxlIiwicm91bmRlciIsIm1heEhlaWdodCIsInNjcm9sbFRvcCIsInNob3VsZEZhbGxiYWNrIiwidXNlSW5uZXJPZmZzZXQiLCJvbkNoYW5nZSIsInVuc3RhYmxlX29uQ2hhbmdlIiwiY29udHJvbGxlZFNjcm9sbGluZ1JlZiIsInByZXZTY3JvbGxUb3BSZWYiLCJpbml0aWFsT3ZlcmZsb3dSZWYiLCJvbldoZWVsIiwiZFkiLCJkZWx0YVkiLCJpc0F0VG9wIiwiaXNBdEJvdHRvbSIsInJlbWFpbmluZ1Njcm9sbCIsInNpZ24iLCJtZXRob2QiLCJzY3JvbGxEaWZmIiwib25seU9wZW5DaGlsZHJlbiIsImRpcmVjdENoaWxkcmVuIiwiZmxhdE1hcCIsImlzUG9pbnRJblBvbHlnb24iLCJwb2ludCIsInBvbHlnb24iLCJpc0luc2lkZSIsImkiLCJqIiwieGkiLCJ5aSIsInhqIiwieWoiLCJpbnRlcnNlY3QiLCJyZWN0Iiwic2FmZVBvbHlnb24iLCJidWZmZXIiLCJyZXF1aXJlSW50ZW50IiwiaGFzTGFuZGVkIiwibGFzdFgiLCJsYXN0WSIsImxhc3RDdXJzb3JUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJnZXRDdXJzb3JTcGVlZCIsImN1cnJlbnRUaW1lIiwiZWxhcHNlZFRpbWUiLCJkZWx0YVgiLCJkaXN0YW5jZSIsInNxcnQiLCJzcGVlZCIsImNsaWVudFBvaW50IiwiaXNMZWF2ZSIsImlzT3ZlckZsb2F0aW5nRWwiLCJpc092ZXJSZWZlcmVuY2VFbCIsInJlZlJlY3QiLCJjdXJzb3JMZWF2ZUZyb21SaWdodCIsImN1cnNvckxlYXZlRnJvbUJvdHRvbSIsImlzT3ZlclJlZmVyZW5jZVJlY3QiLCJpc0Zsb2F0aW5nV2lkZXIiLCJpc0Zsb2F0aW5nVGFsbGVyIiwicmVjdFBvbHkiLCJnZXRQb2x5Z29uIiwiY3Vyc29yUG9pbnRPbmUiLCJjdXJzb3JQb2ludFR3byIsImNvbW1vblBvaW50cyIsImN1cnNvclNwZWVkIiwiY3Vyc29yU3BlZWRUaHJlc2hvbGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   activeElement: () => (/* binding */ activeElement),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createGridCellMap: () => (/* binding */ createGridCellMap),\n/* harmony export */   disableFocusInside: () => (/* binding */ disableFocusInside),\n/* harmony export */   enableFocusInside: () => (/* binding */ enableFocusInside),\n/* harmony export */   findNonDisabledListIndex: () => (/* binding */ findNonDisabledListIndex),\n/* harmony export */   getDeepestNode: () => (/* binding */ getDeepestNode),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getFloatingFocusElement: () => (/* binding */ getFloatingFocusElement),\n/* harmony export */   getGridCellIndexOfCorner: () => (/* binding */ getGridCellIndexOfCorner),\n/* harmony export */   getGridCellIndices: () => (/* binding */ getGridCellIndices),\n/* harmony export */   getGridNavigatedIndex: () => (/* binding */ getGridNavigatedIndex),\n/* harmony export */   getMaxListIndex: () => (/* binding */ getMaxListIndex),\n/* harmony export */   getMinListIndex: () => (/* binding */ getMinListIndex),\n/* harmony export */   getNextTabbable: () => (/* binding */ getNextTabbable),\n/* harmony export */   getNodeAncestors: () => (/* binding */ getNodeAncestors),\n/* harmony export */   getNodeChildren: () => (/* binding */ getNodeChildren),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getPreviousTabbable: () => (/* binding */ getPreviousTabbable),\n/* harmony export */   getTabbableOptions: () => (/* binding */ getTabbableOptions),\n/* harmony export */   getTarget: () => (/* binding */ getTarget),\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isDifferentGridRow: () => (/* binding */ isDifferentGridRow),\n/* harmony export */   isEventTargetWithin: () => (/* binding */ isEventTargetWithin),\n/* harmony export */   isIndexOutOfListBounds: () => (/* binding */ isIndexOutOfListBounds),\n/* harmony export */   isJSDOM: () => (/* binding */ isJSDOM),\n/* harmony export */   isListIndexDisabled: () => (/* binding */ isListIndexDisabled),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isMouseLikePointerType: () => (/* binding */ isMouseLikePointerType),\n/* harmony export */   isOutsideEvent: () => (/* binding */ isOutsideEvent),\n/* harmony export */   isReactEvent: () => (/* binding */ isReactEvent),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTypeableCombobox: () => (/* binding */ isTypeableCombobox),\n/* harmony export */   isTypeableElement: () => (/* binding */ isTypeableElement),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   matchesFocusVisible: () => (/* binding */ matchesFocusVisible),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent),\n/* harmony export */   useEffectEvent: () => (/* binding */ useEffectEvent),\n/* harmony export */   useLatestRef: () => (/* binding */ useLatestRef),\n/* harmony export */   useModernLayoutEffect: () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n\n\n\n\n\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n        return uaData.platform;\n    }\n    return navigator.platform;\n}\nfunction getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n        return uaData.brands.map((_ref)=>{\n            let { brand, version } = _ref;\n            return brand + \"/\" + version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n    const re = /android/i;\n    return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n    return getPlatform().toLowerCase().startsWith(\"mac\") && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n    return getUserAgent().includes(\"jsdom/\");\n}\nconst FOCUSABLE_ATTRIBUTE = \"data-floating-ui-focusable\";\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nconst ARROW_LEFT = \"ArrowLeft\";\nconst ARROW_RIGHT = \"ArrowRight\";\nconst ARROW_UP = \"ArrowUp\";\nconst ARROW_DOWN = \"ArrowDown\";\nfunction activeElement(doc) {\n    let activeElement = doc.activeElement;\n    while(((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null){\n        var _activeElement;\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n}\nfunction contains(parent, child) {\n    if (!parent || !child) {\n        return false;\n    }\n    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    }\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(rootNode)) {\n        let next = child;\n        while(next){\n            if (parent === next) {\n                return true;\n            }\n            // @ts-ignore\n            next = next.parentNode || next.host;\n        }\n    }\n    // Give up, the result is false\n    return false;\n}\nfunction getTarget(event) {\n    if (\"composedPath\" in event) {\n        return event.composedPath()[0];\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n}\nfunction isEventTargetWithin(event, node) {\n    if (node == null) {\n        return false;\n    }\n    if (\"composedPath\" in event) {\n        return event.composedPath().includes(node);\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n}\nfunction isRootElement(element) {\n    return element.matches(\"html,body\");\n}\nfunction getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isTypeableElement(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction isTypeableCombobox(element) {\n    if (!element) return false;\n    return element.getAttribute(\"role\") === \"combobox\" && isTypeableElement(element);\n}\nfunction matchesFocusVisible(element) {\n    // We don't want to block focus from working with `visibleOnly`\n    // (JSDOM doesn't match `:focus-visible` when the element has `:focus`)\n    if (!element || isJSDOM()) return true;\n    try {\n        return element.matches(\":focus-visible\");\n    } catch (_e) {\n        return true;\n    }\n}\nfunction getFloatingFocusElement(floatingElement) {\n    if (!floatingElement) {\n        return null;\n    }\n    // Try to find the element that has `{...getFloatingProps()}` spread on it.\n    // This indicates the floating element is acting as a positioning wrapper, and\n    // so focus should be managed on the child element with the event handlers and\n    // aria props.\n    return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(\"[\" + FOCUSABLE_ATTRIBUTE + \"]\") || floatingElement;\n}\nfunction getNodeChildren(nodes, id, onlyOpenChildren) {\n    if (onlyOpenChildren === void 0) {\n        onlyOpenChildren = true;\n    }\n    const directChildren = nodes.filter((node)=>{\n        var _node$context;\n        return node.parentId === id && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));\n    });\n    return directChildren.flatMap((child)=>[\n            child,\n            ...getNodeChildren(nodes, child.id, onlyOpenChildren)\n        ]);\n}\nfunction getDeepestNode(nodes, id) {\n    let deepestNodeId;\n    let maxDepth = -1;\n    function findDeepest(nodeId, depth) {\n        if (depth > maxDepth) {\n            deepestNodeId = nodeId;\n            maxDepth = depth;\n        }\n        const children = getNodeChildren(nodes, nodeId);\n        children.forEach((child)=>{\n            findDeepest(child.id, depth + 1);\n        });\n    }\n    findDeepest(id, 0);\n    return nodes.find((node)=>node.id === deepestNodeId);\n}\nfunction getNodeAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find((node)=>node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while(currentParentId){\n        const currentNode = nodes.find((node)=>node.id === currentParentId);\n        currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n        if (currentNode) {\n            allAncestors = allAncestors.concat(currentNode);\n        }\n    }\n    return allAncestors;\n}\nfunction stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\nfunction isReactEvent(event) {\n    return \"nativeEvent\" in event;\n}\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n    // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n    // Try to find a workaround for this. `react-aria` source still has the check.\n    if (event.mozInputSource === 0 && event.isTrusted) {\n        return true;\n    }\n    if (isAndroid() && event.pointerType) {\n        return event.type === \"click\" && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n    if (isJSDOM()) return false;\n    return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\" || // iOS VoiceOver returns 0.333â€¢ for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"touch\";\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = [\n        \"mouse\",\n        \"pen\"\n    ];\n    if (!strict) {\n        values.push(\"\", undefined);\n    }\n    return values.includes(pointerType);\n}\nvar isClient = typeof document !== \"undefined\";\nvar noop = function noop() {};\nvar index = isClient ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : noop;\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nconst SafeReact = {\n    .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n};\nfunction useLatestRef(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\nconst useInsertionEffect = SafeReact.useInsertionEffect;\nconst useSafeInsertionEffect = useInsertionEffect || ((fn)=>fn());\nfunction useEffectEvent(callback) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{\n        if (true) {\n            throw new Error(\"Cannot call an event handler while rendering.\");\n        }\n    });\n    useSafeInsertionEffect(()=>{\n        ref.current = callback;\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n}\nfunction isDifferentGridRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfListBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n}\nfunction getMinListIndex(listRef, disabledIndices) {\n    return findNonDisabledListIndex(listRef, {\n        disabledIndices\n    });\n}\nfunction getMaxListIndex(listRef, disabledIndices) {\n    return findNonDisabledListIndex(listRef, {\n        decrement: true,\n        startingIndex: listRef.current.length,\n        disabledIndices\n    });\n}\nfunction findNonDisabledListIndex(listRef, _temp) {\n    let { startingIndex = -1, decrement = false, disabledIndices, amount = 1 } = _temp === void 0 ? {} : _temp;\n    let index = startingIndex;\n    do {\n        index += decrement ? -amount : amount;\n    }while (index >= 0 && index <= listRef.current.length - 1 && isListIndexDisabled(listRef, index, disabledIndices));\n    return index;\n}\nfunction getGridNavigatedIndex(listRef, _ref) {\n    let { event, orientation, loop, rtl, cols, disabledIndices, minIndex, maxIndex, prevIndex, stopEvent: stop = false } = _ref;\n    let nextIndex = prevIndex;\n    if (event.key === ARROW_UP) {\n        stop && stopEvent(event);\n        if (prevIndex === -1) {\n            nextIndex = maxIndex;\n        } else {\n            nextIndex = findNonDisabledListIndex(listRef, {\n                startingIndex: nextIndex,\n                amount: cols,\n                decrement: true,\n                disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n                const col = prevIndex % cols;\n                const maxCol = maxIndex % cols;\n                const offset = maxIndex - (maxCol - col);\n                if (maxCol === col) {\n                    nextIndex = maxIndex;\n                } else {\n                    nextIndex = maxCol > col ? offset : offset - cols;\n                }\n            }\n        }\n        if (isIndexOutOfListBounds(listRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    if (event.key === ARROW_DOWN) {\n        stop && stopEvent(event);\n        if (prevIndex === -1) {\n            nextIndex = minIndex;\n        } else {\n            nextIndex = findNonDisabledListIndex(listRef, {\n                startingIndex: prevIndex,\n                amount: cols,\n                disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n                nextIndex = findNonDisabledListIndex(listRef, {\n                    startingIndex: prevIndex % cols - cols,\n                    amount: cols,\n                    disabledIndices\n                });\n            }\n        }\n        if (isIndexOutOfListBounds(listRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    // Remains on the same row/column.\n    if (orientation === \"both\") {\n        const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(prevIndex / cols);\n        if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {\n            stop && stopEvent(event);\n            if (prevIndex % cols !== cols - 1) {\n                nextIndex = findNonDisabledListIndex(listRef, {\n                    startingIndex: prevIndex,\n                    disabledIndices\n                });\n                if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledListIndex(listRef, {\n                        startingIndex: prevIndex - prevIndex % cols - 1,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledListIndex(listRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            }\n            if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {\n            stop && stopEvent(event);\n            if (prevIndex % cols !== 0) {\n                nextIndex = findNonDisabledListIndex(listRef, {\n                    startingIndex: prevIndex,\n                    decrement: true,\n                    disabledIndices\n                });\n                if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledListIndex(listRef, {\n                        startingIndex: prevIndex + (cols - prevIndex % cols),\n                        decrement: true,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledListIndex(listRef, {\n                    startingIndex: prevIndex + (cols - prevIndex % cols),\n                    decrement: true,\n                    disabledIndices\n                });\n            }\n            if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(maxIndex / cols) === prevRow;\n        if (isIndexOutOfListBounds(listRef, nextIndex)) {\n            if (loop && lastRow) {\n                nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            } else {\n                nextIndex = prevIndex;\n            }\n        }\n    }\n    return nextIndex;\n}\n/** For each cell index, gets the item index that occupies that cell */ function createGridCellMap(sizes, cols, dense) {\n    const cellMap = [];\n    let startIndex = 0;\n    sizes.forEach((_ref2, index)=>{\n        let { width, height } = _ref2;\n        if (width > cols) {\n            if (true) {\n                throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n            }\n        }\n        let itemPlaced = false;\n        if (dense) {\n            startIndex = 0;\n        }\n        while(!itemPlaced){\n            const targetCells = [];\n            for(let i = 0; i < width; i++){\n                for(let j = 0; j < height; j++){\n                    targetCells.push(startIndex + i + j * cols);\n                }\n            }\n            if (startIndex % cols + width <= cols && targetCells.every((cell)=>cellMap[cell] == null)) {\n                targetCells.forEach((cell)=>{\n                    cellMap[cell] = index;\n                });\n                itemPlaced = true;\n            } else {\n                startIndex++;\n            }\n        }\n    });\n    // convert into a non-sparse array\n    return [\n        ...cellMap\n    ];\n}\n/** Gets cell index of an item's corner or -1 when index is -1. */ function getGridCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n    if (index === -1) return -1;\n    const firstCellIndex = cellMap.indexOf(index);\n    const sizeItem = sizes[index];\n    switch(corner){\n        case \"tl\":\n            return firstCellIndex;\n        case \"tr\":\n            if (!sizeItem) {\n                return firstCellIndex;\n            }\n            return firstCellIndex + sizeItem.width - 1;\n        case \"bl\":\n            if (!sizeItem) {\n                return firstCellIndex;\n            }\n            return firstCellIndex + (sizeItem.height - 1) * cols;\n        case \"br\":\n            return cellMap.lastIndexOf(index);\n    }\n}\n/** Gets all cell indices that correspond to the specified indices */ function getGridCellIndices(indices, cellMap) {\n    return cellMap.flatMap((index, cellIndex)=>indices.includes(index) ? [\n            cellIndex\n        ] : []);\n}\nfunction isListIndexDisabled(listRef, index, disabledIndices) {\n    if (typeof disabledIndices === \"function\") {\n        return disabledIndices(index);\n    } else if (disabledIndices) {\n        return disabledIndices.includes(index);\n    }\n    const element = listRef.current[index];\n    return element == null || element.hasAttribute(\"disabled\") || element.getAttribute(\"aria-disabled\") === \"true\";\n}\nconst getTabbableOptions = ()=>({\n        getShadowRoot: true,\n        displayCheck: // JSDOM does not support the `tabbable` library. To solve this we can\n        // check if `ResizeObserver` is a real function (not polyfilled), which\n        // determines if the current environment is JSDOM-like.\n        typeof ResizeObserver === \"function\" && ResizeObserver.toString().includes(\"[native code]\") ? \"full\" : \"none\"\n    });\nfunction getTabbableIn(container, dir) {\n    const list = (0,tabbable__WEBPACK_IMPORTED_MODULE_3__.tabbable)(container, getTabbableOptions());\n    const len = list.length;\n    if (len === 0) return;\n    const active = activeElement(getDocument(container));\n    const index = list.indexOf(active);\n    const nextIndex = index === -1 ? dir === 1 ? 0 : len - 1 : index + dir;\n    return list[nextIndex];\n}\nfunction getNextTabbable(referenceElement) {\n    return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;\n}\nfunction getPreviousTabbable(referenceElement) {\n    return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;\n}\nfunction isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n    const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_3__.tabbable)(container, getTabbableOptions());\n    tabbableElements.forEach((element)=>{\n        element.dataset.tabindex = element.getAttribute(\"tabindex\") || \"\";\n        element.setAttribute(\"tabindex\", \"-1\");\n    });\n}\nfunction enableFocusInside(container) {\n    const elements = container.querySelectorAll(\"[data-tabindex]\");\n    elements.forEach((element)=>{\n        const tabindex = element.dataset.tabindex;\n        delete element.dataset.tabindex;\n        if (tabindex) {\n            element.setAttribute(\"tabindex\", tabindex);\n        } else {\n            element.removeAttribute(\"tabindex\");\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUN0QztBQUNTO0FBQ0c7QUFDUDtBQUVwQyxzQ0FBc0M7QUFDdEMsU0FBU007SUFDUCxNQUFNQyxTQUFTQyxVQUFVQyxhQUFhO0lBQ3RDLElBQUlGLFVBQVUsUUFBUUEsT0FBT0csUUFBUSxFQUFFO1FBQ3JDLE9BQU9ILE9BQU9HLFFBQVE7SUFDeEI7SUFDQSxPQUFPRixVQUFVRSxRQUFRO0FBQzNCO0FBQ0EsU0FBU0M7SUFDUCxNQUFNSixTQUFTQyxVQUFVQyxhQUFhO0lBQ3RDLElBQUlGLFVBQVVLLE1BQU1DLE9BQU8sQ0FBQ04sT0FBT08sTUFBTSxHQUFHO1FBQzFDLE9BQU9QLE9BQU9PLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDQyxDQUFBQTtZQUN2QixJQUFJLEVBQ0ZDLEtBQUssRUFDTEMsT0FBTyxFQUNSLEdBQUdGO1lBQ0osT0FBT0MsUUFBUSxNQUFNQztRQUN2QixHQUFHQyxJQUFJLENBQUM7SUFDVjtJQUNBLE9BQU9YLFVBQVVZLFNBQVM7QUFDNUI7QUFDQSxTQUFTQztJQUNQLDJEQUEyRDtJQUMzRCxPQUFPLFNBQVNDLElBQUksQ0FBQ2QsVUFBVWUsTUFBTTtBQUN2QztBQUNBLFNBQVNDO0lBQ1AsTUFBTUMsS0FBSztJQUNYLE9BQU9BLEdBQUdILElBQUksQ0FBQ2hCLGtCQUFrQm1CLEdBQUdILElBQUksQ0FBQ1g7QUFDM0M7QUFDQSxTQUFTZTtJQUNQLE9BQU9wQixjQUFjcUIsV0FBVyxHQUFHQyxVQUFVLENBQUMsVUFBVSxDQUFDcEIsVUFBVXFCLGNBQWM7QUFDbkY7QUFDQSxTQUFTQztJQUNQLE9BQU9uQixlQUFlb0IsUUFBUSxDQUFDO0FBQ2pDO0FBRUEsTUFBTUMsc0JBQXNCO0FBQzVCLE1B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Z0JDLGdCQUFnQjtJQUN2QyxPQUFPUCxjQUFjdkksWUFBWThJLGtCQUFrQkMsSUFBSSxFQUFFLE1BQU1EO0FBQ2pFO0FBQ0EsU0FBU0Usb0JBQW9CRixnQkFBZ0I7SUFDM0MsT0FBT1AsY0FBY3ZJLFlBQVk4SSxrQkFBa0JDLElBQUksRUFBRSxDQUFDLE1BQU1EO0FBQ2xFO0FBQ0EsU0FBU0csZUFBZTFKLEtBQUssRUFBRWlKLFNBQVM7SUFDdEMsTUFBTVUsbUJBQW1CVixhQUFhakosTUFBTTRKLGFBQWE7SUFDekQsTUFBTUMsZ0JBQWdCN0osTUFBTTZKLGFBQWE7SUFDekMsT0FBTyxDQUFDQSxpQkFBaUIsQ0FBQ3RLLFNBQVNvSyxrQkFBa0JFO0FBQ3ZEO0FBQ0EsU0FBU0MsbUJBQW1CYixTQUFTO0lBQ25DLE1BQU1jLG1CQUFtQjdNLGtEQUFRQSxDQUFDK0wsV0FBV047SUFDN0NvQixpQkFBaUJ4SCxPQUFPLENBQUNoQyxDQUFBQTtRQUN2QkEsUUFBUXlKLE9BQU8sQ0FBQ0MsUUFBUSxHQUFHMUosUUFBUU8sWUFBWSxDQUFDLGVBQWU7UUFDL0RQLFFBQVEySixZQUFZLENBQUMsWUFBWTtJQUNuQztBQUNGO0FBQ0EsU0FBU0Msa0JBQWtCbEIsU0FBUztJQUNsQyxNQUFNbUIsV0FBV25CLFVBQVVvQixnQkFBZ0IsQ0FBQztJQUM1Q0QsU0FBUzdILE9BQU8sQ0FBQ2hDLENBQUFBO1FBQ2YsTUFBTTBKLFdBQVcxSixRQUFReUosT0FBTyxDQUFDQyxRQUFRO1FBQ3pDLE9BQU8xSixRQUFReUosT0FBTyxDQUFDQyxRQUFRO1FBQy9CLElBQUlBLFVBQVU7WUFDWjFKLFFBQVEySixZQUFZLENBQUMsWUFBWUQ7UUFDbkMsT0FBTztZQUNMMUosUUFBUStKLGVBQWUsQ0FBQztRQUMxQjtJQUNGO0FBQ0Y7QUFFbXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmd0LWNsaW5pYy8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QvZGlzdC9mbG9hdGluZy11aS5yZWFjdC51dGlscy5tanM/MGVjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QsIGlzSFRNTEVsZW1lbnQgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IHRhYmJhYmxlIH0gZnJvbSAndGFiYmFibGUnO1xuXG4vLyBBdm9pZCBDaHJvbWUgRGV2VG9vbHMgYmx1ZSB3YXJuaW5nLlxuZnVuY3Rpb24gZ2V0UGxhdGZvcm0oKSB7XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLnBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5wbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtO1xufVxuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgaWYgKHVhRGF0YSAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgYnJhbmQsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIGJyYW5kICsgXCIvXCIgKyB2ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAvLyBDaHJvbWUgRGV2VG9vbHMgZG9lcyBub3QgY29tcGxhaW4gYWJvdXQgbmF2aWdhdG9yLnZlbmRvclxuICByZXR1cm4gL2FwcGxlL2kudGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbn1cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgY29uc3QgcmUgPSAvYW5kcm9pZC9pO1xuICByZXR1cm4gcmUudGVzdChnZXRQbGF0Zm9ybSgpKSB8fCByZS50ZXN0KGdldFVzZXJBZ2VudCgpKTtcbn1cbmZ1bmN0aW9uIGlzTWFjKCkge1xuICByZXR1cm4gZ2V0UGxhdGZvcm0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ21hYycpICYmICFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG59XG5mdW5jdGlvbiBpc0pTRE9NKCkge1xuICByZXR1cm4gZ2V0VXNlckFnZW50KCkuaW5jbHVkZXMoJ2pzZG9tLycpO1xufVxuXG5jb25zdCBGT0NVU0FCTEVfQVRUUklCVVRFID0gJ2RhdGEtZmxvYXRpbmctdWktZm9jdXNhYmxlJztcbmNvbnN0IFRZUEVBQkxFX1NFTEVDVE9SID0gXCJpbnB1dDpub3QoW3R5cGU9J2hpZGRlbiddKTpub3QoW2Rpc2FibGVkXSksXCIgKyBcIltjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPSdmYWxzZSddKSx0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSlcIjtcbmNvbnN0IEFSUk9XX0xFRlQgPSAnQXJyb3dMZWZ0JztcbmNvbnN0IEFSUk9XX1JJR0hUID0gJ0Fycm93UmlnaHQnO1xuY29uc3QgQVJST1dfVVAgPSAnQXJyb3dVcCc7XG5jb25zdCBBUlJPV19ET1dOID0gJ0Fycm93RG93bic7XG5cbmZ1bmN0aW9uIGFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gIGxldCBhY3RpdmVFbGVtZW50ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlICgoKF9hY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudCkgPT0gbnVsbCB8fCAoX2FjdGl2ZUVsZW1lbnQgPSBfYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSA9PSBudWxsID8gdm9pZCAwIDogX2FjdGl2ZUVsZW1lbnQuYWN0aXZlRWxlbWVudCkgIT0gbnVsbCkge1xuICAgIHZhciBfYWN0aXZlRWxlbWVudDtcbiAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIGlmICghcGFyZW50IHx8ICFjaGlsZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gbmV4dCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0KGV2ZW50KSB7XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydFxuICAvLyBgY29tcG9zZWRQYXRoKClgLCBidXQgYnJvd3NlcnMgd2l0aG91dCBzaGFkb3cgRE9NIGRvbid0LlxuICByZXR1cm4gZXZlbnQudGFyZ2V0O1xufVxuZnVuY3Rpb24gaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgbm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhub2RlKTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjb21wb3NlZFBhdGgsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBkb20gZG9uJ3RcbiAgY29uc3QgZSA9IGV2ZW50O1xuICByZXR1cm4gZS50YXJnZXQgIT0gbnVsbCAmJiBub2RlLmNvbnRhaW5zKGUudGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGlzUm9vdEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKCdodG1sLGJvZHknKTtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIChub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLm93bmVyRG9jdW1lbnQpIHx8IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lm1hdGNoZXMoVFlQRUFCTEVfU0VMRUNUT1IpO1xufVxuZnVuY3Rpb24gaXNUeXBlYWJsZUNvbWJvYm94KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnY29tYm9ib3gnICYmIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc0ZvY3VzVmlzaWJsZShlbGVtZW50KSB7XG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gYmxvY2sgZm9jdXMgZnJvbSB3b3JraW5nIHdpdGggYHZpc2libGVPbmx5YFxuICAvLyAoSlNET00gZG9lc24ndCBtYXRjaCBgOmZvY3VzLXZpc2libGVgIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGA6Zm9jdXNgKVxuICBpZiAoIWVsZW1lbnQgfHwgaXNKU0RPTSgpKSByZXR1cm4gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKCc6Zm9jdXMtdmlzaWJsZScpO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGbG9hdGluZ0ZvY3VzRWxlbWVudChmbG9hdGluZ0VsZW1lbnQpIHtcbiAgaWYgKCFmbG9hdGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBUcnkgdG8gZmluZCB0aGUgZWxlbWVudCB0aGF0IGhhcyBgey4uLmdldEZsb2F0aW5nUHJvcHMoKX1gIHNwcmVhZCBvbiBpdC5cbiAgLy8gVGhpcyBpbmRpY2F0ZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgYWN0aW5nIGFzIGEgcG9zaXRpb25pbmcgd3JhcHBlciwgYW5kXG4gIC8vIHNvIGZvY3VzIHNob3VsZCBiZSBtYW5hZ2VkIG9uIHRoZSBjaGlsZCBlbGVtZW50IHdpdGggdGhlIGV2ZW50IGhhbmRsZXJzIGFuZFxuICAvLyBhcmlhIHByb3BzLlxuICByZXR1cm4gZmxvYXRpbmdFbGVtZW50Lmhhc0F0dHJpYnV0ZShGT0NVU0FCTEVfQVRUUklCVVRFKSA/IGZsb2F0aW5nRWxlbWVudCA6IGZsb2F0aW5nRWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiW1wiICsgRk9DVVNBQkxFX0FUVFJJQlVURSArIFwiXVwiKSB8fCBmbG9hdGluZ0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVDaGlsZHJlbihub2RlcywgaWQsIG9ubHlPcGVuQ2hpbGRyZW4pIHtcbiAgaWYgKG9ubHlPcGVuQ2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgIG9ubHlPcGVuQ2hpbGRyZW4gPSB0cnVlO1xuICB9XG4gIGNvbnN0IGRpcmVjdENoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBpZCAmJiAoIW9ubHlPcGVuQ2hpbGRyZW4gfHwgKChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5vcGVuKSk7XG4gIH0pO1xuICByZXR1cm4gZGlyZWN0Q2hpbGRyZW4uZmxhdE1hcChjaGlsZCA9PiBbY2hpbGQsIC4uLmdldE5vZGVDaGlsZHJlbihub2RlcywgY2hpbGQuaWQsIG9ubHlPcGVuQ2hpbGRyZW4pXSk7XG59XG5mdW5jdGlvbiBnZXREZWVwZXN0Tm9kZShub2RlcywgaWQpIHtcbiAgbGV0IGRlZXBlc3ROb2RlSWQ7XG4gIGxldCBtYXhEZXB0aCA9IC0xO1xuICBmdW5jdGlvbiBmaW5kRGVlcGVzdChub2RlSWQsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID4gbWF4RGVwdGgpIHtcbiAgICAgIGRlZXBlc3ROb2RlSWQgPSBub2RlSWQ7XG4gICAgICBtYXhEZXB0aCA9IGRlcHRoO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IGdldE5vZGVDaGlsZHJlbihub2Rlcywgbm9kZUlkKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGZpbmREZWVwZXN0KGNoaWxkLmlkLCBkZXB0aCArIDEpO1xuICAgIH0pO1xuICB9XG4gIGZpbmREZWVwZXN0KGlkLCAwKTtcbiAgcmV0dXJuIG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBkZWVwZXN0Tm9kZUlkKTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVBbmNlc3RvcnMobm9kZXMsIGlkKSB7XG4gIHZhciBfbm9kZXMkZmluZDtcbiAgbGV0IGFsbEFuY2VzdG9ycyA9IFtdO1xuICBsZXQgY3VycmVudFBhcmVudElkID0gKF9ub2RlcyRmaW5kID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLnBhcmVudElkO1xuICB3aGlsZSAoY3VycmVudFBhcmVudElkKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gY3VycmVudFBhcmVudElkKTtcbiAgICBjdXJyZW50UGFyZW50SWQgPSBjdXJyZW50Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudE5vZGUucGFyZW50SWQ7XG4gICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICBhbGxBbmNlc3RvcnMgPSBhbGxBbmNlc3RvcnMuY29uY2F0KGN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbEFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gaXNSZWFjdEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAnbmF0aXZlRXZlbnQnIGluIGV2ZW50O1xufVxuXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUvcmVhY3Qtc3BlY3RydW0vYmxvYi9iMzVkNWMwMmZlOTAwYmFkY2NkMGNmMWE4ZjIzYmI1OTM0MTlmMjM4L3BhY2thZ2VzL0ByZWFjdC1hcmlhL3V0aWxzL3NyYy9pc1ZpcnR1YWxFdmVudC50c1xuZnVuY3Rpb24gaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHtcbiAgLy8gRklYTUU6IEZpcmVmb3ggaXMgbm93IGVtaXR0aW5nIGEgZGVwcmVjYXRpb24gd2FybmluZyBmb3IgYG1veklucHV0U291cmNlYC5cbiAgLy8gVHJ5IHRvIGZpbmQgYSB3b3JrYXJvdW5kIGZvciB0aGlzLiBgcmVhY3QtYXJpYWAgc291cmNlIHN0aWxsIGhhcyB0aGUgY2hlY2suXG4gIGlmIChldmVudC5tb3pJbnB1dFNvdXJjZSA9PT0gMCAmJiBldmVudC5pc1RydXN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBbmRyb2lkKCkgJiYgZXZlbnQucG9pbnRlclR5cGUpIHtcbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiBldmVudC5idXR0b25zID09PSAxO1xuICB9XG4gIHJldHVybiBldmVudC5kZXRhaWwgPT09IDAgJiYgIWV2ZW50LnBvaW50ZXJUeXBlO1xufVxuZnVuY3Rpb24gaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gIGlmIChpc0pTRE9NKCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICFpc0FuZHJvaWQoKSAmJiBldmVudC53aWR0aCA9PT0gMCAmJiBldmVudC5oZWlnaHQgPT09IDAgfHwgaXNBbmRyb2lkKCkgJiYgZXZlbnQud2lkdGggPT09IDEgJiYgZXZlbnQuaGVpZ2h0ID09PSAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fFxuICAvLyBpT1MgVm9pY2VPdmVyIHJldHVybnMgMC4zMzPigKIgZm9yIHdpZHRoL2hlaWdodC5cbiAgZXZlbnQud2lkdGggPCAxICYmIGV2ZW50LmhlaWdodCA8IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xufVxuZnVuY3Rpb24gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSwgc3RyaWN0KSB7XG4gIC8vIE9uIHNvbWUgTGludXggbWFjaGluZXMgd2l0aCBDaHJvbWl1bSwgbW91c2UgaW5wdXRzIHJldHVybiBhIGBwb2ludGVyVHlwZWBcbiAgLy8gb2YgXCJwZW5cIjogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yMDE1XG4gIGNvbnN0IHZhbHVlcyA9IFsnbW91c2UnLCAncGVuJ107XG4gIGlmICghc3RyaWN0KSB7XG4gICAgdmFsdWVzLnB1c2goJycsIHVuZGVmaW5lZCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcy5pbmNsdWRlcyhwb2ludGVyVHlwZSk7XG59XG5cbnZhciBpc0NsaWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIGluZGV4ID0gaXNDbGllbnQgPyB1c2VMYXlvdXRFZmZlY3QgOiBub29wO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXVpL21hdGVyaWFsLXVpL2lzc3Vlcy80MTE5MCNpc3N1ZWNvbW1lbnQtMjA0MDg3MzM3OVxuY29uc3QgU2FmZVJlYWN0ID0ge1xuICAuLi5SZWFjdFxufTtcblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cbmNvbnN0IHVzZUluc2VydGlvbkVmZmVjdCA9IFNhZmVSZWFjdC51c2VJbnNlcnRpb25FZmZlY3Q7XG5jb25zdCB1c2VTYWZlSW5zZXJ0aW9uRWZmZWN0ID0gdXNlSW5zZXJ0aW9uRWZmZWN0IHx8IChmbiA9PiBmbigpKTtcbmZ1bmN0aW9uIHVzZUVmZmVjdEV2ZW50KGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZigoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBhbiBldmVudCBoYW5kbGVyIHdoaWxlIHJlbmRlcmluZy4nKTtcbiAgICB9XG4gIH0pO1xuICB1c2VTYWZlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogcmVmLmN1cnJlbnQoLi4uYXJncyk7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gaXNEaWZmZXJlbnRHcmlkUm93KGluZGV4LCBjb2xzLCBwcmV2Um93KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGluZGV4IC8gY29scykgIT09IHByZXZSb3c7XG59XG5mdW5jdGlvbiBpc0luZGV4T3V0T2ZMaXN0Qm91bmRzKGxpc3RSZWYsIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPj0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGdldE1pbkxpc3RJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpIHtcbiAgcmV0dXJuIGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgZGlzYWJsZWRJbmRpY2VzXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TWF4TGlzdEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgc3RhcnRpbmdJbmRleDogbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCxcbiAgICBkaXNhYmxlZEluZGljZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwgX3RlbXApIHtcbiAgbGV0IHtcbiAgICBzdGFydGluZ0luZGV4ID0gLTEsXG4gICAgZGVjcmVtZW50ID0gZmFsc2UsXG4gICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgIGFtb3VudCA9IDFcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBsZXQgaW5kZXggPSBzdGFydGluZ0luZGV4O1xuICBkbyB7XG4gICAgaW5kZXggKz0gZGVjcmVtZW50ID8gLWFtb3VudCA6IGFtb3VudDtcbiAgfSB3aGlsZSAoaW5kZXggPj0gMCAmJiBpbmRleCA8PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoIC0gMSAmJiBpc0xpc3RJbmRleERpc2FibGVkKGxpc3RSZWYsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZ2V0R3JpZE5hdmlnYXRlZEluZGV4KGxpc3RSZWYsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBldmVudCxcbiAgICBvcmllbnRhdGlvbixcbiAgICBsb29wLFxuICAgIHJ0bCxcbiAgICBjb2xzLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBtaW5JbmRleCxcbiAgICBtYXhJbmRleCxcbiAgICBwcmV2SW5kZXgsXG4gICAgc3RvcEV2ZW50OiBzdG9wID0gZmFsc2VcbiAgfSA9IF9yZWY7XG4gIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1VQKSB7XG4gICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wICYmIChwcmV2SW5kZXggLSBjb2xzIDwgbWluSW5kZXggfHwgbmV4dEluZGV4IDwgMCkpIHtcbiAgICAgICAgY29uc3QgY29sID0gcHJldkluZGV4ICUgY29scztcbiAgICAgICAgY29uc3QgbWF4Q29sID0gbWF4SW5kZXggJSBjb2xzO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXhJbmRleCAtIChtYXhDb2wgLSBjb2wpO1xuICAgICAgICBpZiAobWF4Q29sID09PSBjb2wpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhDb2wgPiBjb2wgPyBvZmZzZXQgOiBvZmZzZXQgLSBjb2xzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luZGV4T3V0T2ZMaXN0Qm91bmRzKGxpc3RSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTikge1xuICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAocHJldkluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbWluSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgIH0pO1xuICAgICAgaWYgKGxvb3AgJiYgcHJldkluZGV4ICsgY29scyA+IG1heEluZGV4KSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICUgY29scyAtIGNvbHMsXG4gICAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5kZXhPdXRPZkxpc3RCb3VuZHMobGlzdFJlZiwgbmV4dEluZGV4KSkge1xuICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbWFpbnMgb24gdGhlIHNhbWUgcm93L2NvbHVtbi5cbiAgaWYgKG9yaWVudGF0aW9uID09PSAnYm90aCcpIHtcbiAgICBjb25zdCBwcmV2Um93ID0gZmxvb3IocHJldkluZGV4IC8gY29scyk7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gKHJ0bCA/IEFSUk9XX0xFRlQgOiBBUlJPV19SSUdIVCkpIHtcbiAgICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSBjb2xzIC0gMSkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50R3JpZFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpZmZlcmVudEdyaWRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChldmVudC5rZXkgPT09IChydGwgPyBBUlJPV19SSUdIVCA6IEFSUk9XX0xFRlQpKSB7XG4gICAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgICBpZiAocHJldkluZGV4ICUgY29scyAhPT0gMCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9vcCAmJiBpc0RpZmZlcmVudEdyaWRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggKyAoY29scyAtIHByZXZJbmRleCAlIGNvbHMpLFxuICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9vcCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RpZmZlcmVudEdyaWRSb3cobmV4dEluZGV4LCBjb2xzLCBwcmV2Um93KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3RSb3cgPSBmbG9vcihtYXhJbmRleCAvIGNvbHMpID09PSBwcmV2Um93O1xuICAgIGlmIChpc0luZGV4T3V0T2ZMaXN0Qm91bmRzKGxpc3RSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIGlmIChsb29wICYmIGxhc3RSb3cpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZXZlbnQua2V5ID09PSAocnRsID8gQVJST1dfUklHSFQgOiBBUlJPV19MRUZUKSA/IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggLSBwcmV2SW5kZXggJSBjb2xzIC0gMSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0SW5kZXg7XG59XG5cbi8qKiBGb3IgZWFjaCBjZWxsIGluZGV4LCBnZXRzIHRoZSBpdGVtIGluZGV4IHRoYXQgb2NjdXBpZXMgdGhhdCBjZWxsICovXG5mdW5jdGlvbiBjcmVhdGVHcmlkQ2VsbE1hcChzaXplcywgY29scywgZGVuc2UpIHtcbiAgY29uc3QgY2VsbE1hcCA9IFtdO1xuICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gIHNpemVzLmZvckVhY2goKF9yZWYyLCBpbmRleCkgPT4ge1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAod2lkdGggPiBjb2xzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltGbG9hdGluZyBVSV06IEludmFsaWQgZ3JpZCAtIGl0ZW0gd2lkdGggYXQgaW5kZXggXCIgKyBpbmRleCArIFwiIGlzIGdyZWF0ZXIgdGhhbiBncmlkIGNvbHVtbnNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpdGVtUGxhY2VkID0gZmFsc2U7XG4gICAgaWYgKGRlbnNlKSB7XG4gICAgICBzdGFydEluZGV4ID0gMDtcbiAgICB9XG4gICAgd2hpbGUgKCFpdGVtUGxhY2VkKSB7XG4gICAgICBjb25zdCB0YXJnZXRDZWxscyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICB0YXJnZXRDZWxscy5wdXNoKHN0YXJ0SW5kZXggKyBpICsgaiAqIGNvbHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRJbmRleCAlIGNvbHMgKyB3aWR0aCA8PSBjb2xzICYmIHRhcmdldENlbGxzLmV2ZXJ5KGNlbGwgPT4gY2VsbE1hcFtjZWxsXSA9PSBudWxsKSkge1xuICAgICAgICB0YXJnZXRDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgIGNlbGxNYXBbY2VsbF0gPSBpbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZW1QbGFjZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gY29udmVydCBpbnRvIGEgbm9uLXNwYXJzZSBhcnJheVxuICByZXR1cm4gWy4uLmNlbGxNYXBdO1xufVxuXG4vKiogR2V0cyBjZWxsIGluZGV4IG9mIGFuIGl0ZW0ncyBjb3JuZXIgb3IgLTEgd2hlbiBpbmRleCBpcyAtMS4gKi9cbmZ1bmN0aW9uIGdldEdyaWRDZWxsSW5kZXhPZkNvcm5lcihpbmRleCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsIGNvcm5lcikge1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gLTE7XG4gIGNvbnN0IGZpcnN0Q2VsbEluZGV4ID0gY2VsbE1hcC5pbmRleE9mKGluZGV4KTtcbiAgY29uc3Qgc2l6ZUl0ZW0gPSBzaXplc1tpbmRleF07XG4gIHN3aXRjaCAoY29ybmVyKSB7XG4gICAgY2FzZSAndGwnOlxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4O1xuICAgIGNhc2UgJ3RyJzpcbiAgICAgIGlmICghc2l6ZUl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4ICsgc2l6ZUl0ZW0ud2lkdGggLSAxO1xuICAgIGNhc2UgJ2JsJzpcbiAgICAgIGlmICghc2l6ZUl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4ICsgKHNpemVJdGVtLmhlaWdodCAtIDEpICogY29scztcbiAgICBjYXNlICdicic6XG4gICAgICByZXR1cm4gY2VsbE1hcC5sYXN0SW5kZXhPZihpbmRleCk7XG4gIH1cbn1cblxuLyoqIEdldHMgYWxsIGNlbGwgaW5kaWNlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHNwZWNpZmllZCBpbmRpY2VzICovXG5mdW5jdGlvbiBnZXRHcmlkQ2VsbEluZGljZXMoaW5kaWNlcywgY2VsbE1hcCkge1xuICByZXR1cm4gY2VsbE1hcC5mbGF0TWFwKChpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRpY2VzLmluY2x1ZGVzKGluZGV4KSA/IFtjZWxsSW5kZXhdIDogW10pO1xufVxuZnVuY3Rpb24gaXNMaXN0SW5kZXhEaXNhYmxlZChsaXN0UmVmLCBpbmRleCwgZGlzYWJsZWRJbmRpY2VzKSB7XG4gIGlmICh0eXBlb2YgZGlzYWJsZWRJbmRpY2VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRpc2FibGVkSW5kaWNlcyhpbmRleCk7XG4gIH0gZWxzZSBpZiAoZGlzYWJsZWRJbmRpY2VzKSB7XG4gICAgcmV0dXJuIGRpc2FibGVkSW5kaWNlcy5pbmNsdWRlcyhpbmRleCk7XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IGxpc3RSZWYuY3VycmVudFtpbmRleF07XG4gIHJldHVybiBlbGVtZW50ID09IG51bGwgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gJ3RydWUnO1xufVxuXG5jb25zdCBnZXRUYWJiYWJsZU9wdGlvbnMgPSAoKSA9PiAoe1xuICBnZXRTaGFkb3dSb290OiB0cnVlLFxuICBkaXNwbGF5Q2hlY2s6XG4gIC8vIEpTRE9NIGRvZXMgbm90IHN1cHBvcnQgdGhlIGB0YWJiYWJsZWAgbGlicmFyeS4gVG8gc29sdmUgdGhpcyB3ZSBjYW5cbiAgLy8gY2hlY2sgaWYgYFJlc2l6ZU9ic2VydmVyYCBpcyBhIHJlYWwgZnVuY3Rpb24gKG5vdCBwb2x5ZmlsbGVkKSwgd2hpY2hcbiAgLy8gZGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBKU0RPTS1saWtlLlxuICB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgUmVzaXplT2JzZXJ2ZXIudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpID8gJ2Z1bGwnIDogJ25vbmUnXG59KTtcbmZ1bmN0aW9uIGdldFRhYmJhYmxlSW4oY29udGFpbmVyLCBkaXIpIHtcbiAgY29uc3QgbGlzdCA9IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpO1xuICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuO1xuICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGNvbnRhaW5lcikpO1xuICBjb25zdCBpbmRleCA9IGxpc3QuaW5kZXhPZihhY3RpdmUpO1xuICBjb25zdCBuZXh0SW5kZXggPSBpbmRleCA9PT0gLTEgPyBkaXIgPT09IDEgPyAwIDogbGVuIC0gMSA6IGluZGV4ICsgZGlyO1xuICByZXR1cm4gbGlzdFtuZXh0SW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFRhYmJhYmxlKHJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFRhYmJhYmxlSW4oZ2V0RG9jdW1lbnQocmVmZXJlbmNlRWxlbWVudCkuYm9keSwgMSkgfHwgcmVmZXJlbmNlRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzVGFiYmFibGUocmVmZXJlbmNlRWxlbWVudCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihnZXREb2N1bWVudChyZWZlcmVuY2VFbGVtZW50KS5ib2R5LCAtMSkgfHwgcmVmZXJlbmNlRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBjb250YWluZXIpIHtcbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lciB8fCBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgcmV0dXJuICFyZWxhdGVkVGFyZ2V0IHx8ICFjb250YWlucyhjb250YWluZXJFbGVtZW50LCByZWxhdGVkVGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgdGFiYmFibGVFbGVtZW50cyA9IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpO1xuICB0YWJiYWJsZUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJyc7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5hYmxlRm9jdXNJbnNpZGUoY29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRhYmluZGV4XScpO1xuICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHRhYmluZGV4ID0gZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4O1xuICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgaWYgKHRhYmluZGV4KSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0YWJpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IGFjdGl2ZUVsZW1lbnQsIGNvbnRhaW5zLCBjcmVhdGVHcmlkQ2VsbE1hcCwgZGlzYWJsZUZvY3VzSW5zaWRlLCBlbmFibGVGb2N1c0luc2lkZSwgZmluZE5vbkRpc2FibGVkTGlzdEluZGV4LCBnZXREZWVwZXN0Tm9kZSwgZ2V0RG9jdW1lbnQsIGdldEZsb2F0aW5nRm9jdXNFbGVtZW50LCBnZXRHcmlkQ2VsbEluZGV4T2ZDb3JuZXIsIGdldEdyaWRDZWxsSW5kaWNlcywgZ2V0R3JpZE5hdmlnYXRlZEluZGV4LCBnZXRNYXhMaXN0SW5kZXgsIGdldE1pbkxpc3RJbmRleCwgZ2V0TmV4dFRhYmJhYmxlLCBnZXROb2RlQW5jZXN0b3JzLCBnZXROb2RlQ2hpbGRyZW4sIGdldFBsYXRmb3JtLCBnZXRQcmV2aW91c1RhYmJhYmxlLCBnZXRUYWJiYWJsZU9wdGlvbnMsIGdldFRhcmdldCwgZ2V0VXNlckFnZW50LCBpc0FuZHJvaWQsIGlzRGlmZmVyZW50R3JpZFJvdywgaXNFdmVudFRhcmdldFdpdGhpbiwgaXNJbmRleE91dE9mTGlzdEJvdW5kcywgaXNKU0RPTSwgaXNMaXN0SW5kZXhEaXNhYmxlZCwgaXNNYWMsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGlzT3V0c2lkZUV2ZW50LCBpc1JlYWN0RXZlbnQsIGlzUm9vdEVsZW1lbnQsIGlzU2FmYXJpLCBpc1R5cGVhYmxlQ29tYm9ib3gsIGlzVHlwZWFibGVFbGVtZW50LCBpc1ZpcnR1YWxDbGljaywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50LCBtYXRjaGVzRm9jdXNWaXNpYmxlLCBzdG9wRXZlbnQsIHVzZUVmZmVjdEV2ZW50LCB1c2VMYXRlc3RSZWYsIGluZGV4IGFzIHVzZU1vZGVybkxheW91dEVmZmVjdCB9O1xuIl0sIm5hbWVzIjpbImlzU2hhZG93Um9vdCIsImlzSFRNTEVsZW1lbnQiLCJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsImZsb29yIiwidGFiYmFibGUiLCJnZXRQbGF0Zm9ybSIsInVhRGF0YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudERhdGEiLCJwbGF0Zm9ybSIsImdldFVzZXJBZ2VudCIsIkFycmF5IiwiaXNBcnJheSIsImJyYW5kcyIsIm1hcCIsIl9yZWYiLCJicmFuZCIsInZlcnNpb24iLCJqb2luIiwidXNlckFnZW50IiwiaXNTYWZhcmkiLCJ0ZXN0IiwidmVuZG9yIiwiaXNBbmRyb2lkIiwicmUiLCJpc01hYyIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsIm1heFRvdWNoUG9pbnRzIiwiaXNKU0RPTSIsImluY2x1ZGVzIiwiRk9DVVNBQkxFX0FUVFJJQlVURSIsIlRZUEVBQkxFX1NFTEVDVE9SIiwiQVJST1dfTEVGVCIsIkFSUk9XX1JJR0hUIiwiQVJST1dfVVAiLCJBUlJPV19ET1dOIiwiYWN0aXZlRWxlbWVudCIsImRvYyIsIl9hY3RpdmVFbGVtZW50Iiwic2hhZG93Um9vdCIsImNvbnRhaW5zIiwicGFyZW50IiwiY2hpbGQiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwibmV4dCIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0VGFyZ2V0IiwiZXZlbnQiLCJjb21wb3NlZFBhdGgiLCJ0YXJnZXQiLCJpc0V2ZW50VGFyZ2V0V2l0aGluIiwibm9kZSIsImUiLCJpc1Jvb3RFbGVtZW50IiwiZWxlbWVudCIsIm1hdGNoZXMiLCJnZXREb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsImlzVHlwZWFibGVFbGVtZW50IiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiZ2V0QXR0cmlidXRlIiwibWF0Y2hlc0ZvY3VzVmlzaWJsZSIsIl9lIiwiZ2V0RmxvYXRpbmdGb2N1c0VsZW1lbnQiLCJmbG9hdGluZ0VsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0Tm9kZUNoaWxkcmVuIiwibm9kZXMiLCJpZCIsIm9ubHlPcGVuQ2hpbGRyZW4iLCJkaXJlY3RDaGlsZHJlbiIsImZpbHRlciIsIl9ub2RlJGNvbnRleHQiLCJwYXJlbnRJZCIsImNvbnRleHQiLCJvcGVuIiwiZmxhdE1hcCIsImdldERlZXBlc3ROb2RlIiwiZGVlcGVzdE5vZGVJZCIsIm1heERlcHRoIiwiZmluZERlZXBlc3QiLCJub2RlSWQiLCJkZXB0aCIsImNoaWxkcmVuIiwiZm9yRWFjaCIsImZpbmQiLCJnZXROb2RlQW5jZXN0b3JzIiwiX25vZGVzJGZpbmQiLCJhbGxBbmNlc3RvcnMiLCJjdXJyZW50UGFyZW50SWQiLCJjdXJyZW50Tm9kZSIsImNvbmNhdCIsInN0b3BFdmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiaXNSZWFjdEV2ZW50IiwiaXNWaXJ0dWFsQ2xpY2siLCJtb3pJbnB1dFNvdXJjZSIsImlzVHJ1c3RlZCIsInBvaW50ZXJUeXBlIiwidHlwZSIsImJ1dHRvbnMiLCJkZXRhaWwiLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJ3aWR0aCIsImhlaWdodCIsInByZXNzdXJlIiwiaXNNb3VzZUxpa2VQb2ludGVyVHlwZSIsInN0cmljdCIsInZhbHVlcyIsInB1c2giLCJ1bmRlZmluZWQiLCJpc0NsaWVudCIsIm5vb3AiLCJpbmRleCIsIlNhZmVSZWFjdCIsInVzZUxhdGVzdFJlZiIsInZhbHVlIiwicmVmIiwidXNlUmVmIiwiY3VycmVudCIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZVNhZmVJbnNlcnRpb25FZmZlY3QiLCJmbiIsInVzZUVmZmVjdEV2ZW50IiwiY2FsbGJhY2siLCJwcm9jZXNzIiwiRXJyb3IiLCJ1c2VDYWxsYmFjayIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiX2tleSIsImlzRGlmZmVyZW50R3JpZFJvdyIsImNvbHMiLCJwcmV2Um93IiwiTWF0aCIsImlzSW5kZXhPdXRPZkxpc3RCb3VuZHMiLCJsaXN0UmVmIiwiZ2V0TWluTGlzdEluZGV4IiwiZGlzYWJsZWRJbmRpY2VzIiwiZmluZE5vbkRpc2FibGVkTGlzdEluZGV4IiwiZ2V0TWF4TGlzdEluZGV4IiwiZGVjcmVtZW50Iiwic3RhcnRpbmdJbmRleCIsIl90ZW1wIiwiYW1vdW50IiwiaXNMaXN0SW5kZXhEaXNhYmxlZCIsImdldEdyaWROYXZpZ2F0ZWRJbmRleCIsIm9yaWVudGF0aW9uIiwibG9vcCIsInJ0bCIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJwcmV2SW5kZXgiLCJzdG9wIiwibmV4dEluZGV4Iiwia2V5IiwiY29sIiwibWF4Q29sIiwib2Zmc2V0IiwibGFzdFJvdyIsImNyZWF0ZUdyaWRDZWxsTWFwIiwic2l6ZXMiLCJkZW5zZSIsImNlbGxNYXAiLCJzdGFydEluZGV4IiwiX3JlZjIiLCJpdGVtUGxhY2VkIiwidGFyZ2V0Q2VsbHMiLCJpIiwiaiIsImV2ZXJ5IiwiY2VsbCIsImdldEdyaWRDZWxsSW5kZXhPZkNvcm5lciIsImNvcm5lciIsImZpcnN0Q2VsbEluZGV4IiwiaW5kZXhPZiIsInNpemVJdGVtIiwibGFzdEluZGV4T2YiLCJnZXRHcmlkQ2VsbEluZGljZXMiLCJpbmRpY2VzIiwiY2VsbEluZGV4IiwiZ2V0VGFiYmFibGVPcHRpb25zIiwiZ2V0U2hhZG93Um9vdCIsImRpc3BsYXlDaGVjayIsIlJlc2l6ZU9ic2VydmVyIiwidG9TdHJpbmciLCJnZXRUYWJiYWJsZUluIiwiY29udGFpbmVyIiwiZGlyIiwibGlzdCIsImxlbiIsImFjdGl2ZSIsImdldE5leHRUYWJiYWJsZSIsInJlZmVyZW5jZUVsZW1lbnQiLCJib2R5IiwiZ2V0UHJldmlvdXNUYWJiYWJsZSIsImlzT3V0c2lkZUV2ZW50IiwiY29udGFpbmVyRWxlbWVudCIsImN1cnJlbnRUYXJnZXQiLCJyZWxhdGVkVGFyZ2V0IiwiZGlzYWJsZUZvY3VzSW5zaWRlIiwidGFiYmFibGVFbGVtZW50cyIsImRhdGFzZXQiLCJ0YWJpbmRleCIsInNldEF0dHJpYnV0ZSIsImVuYWJsZUZvY3VzSW5zaWRlIiwiZWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVtb3ZlQXR0cmlidXRlIiwidXNlTW9kZXJuTGF5b3V0RWZmZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getFrameElement: () => (/* binding */ getFrameElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isTopLayer: () => (/* binding */ isTopLayer),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction hasWindow() {\n    return \"undefined\" !== \"undefined\";\n}\nfunction getNodeName(node) {\n    if (isNode(node)) {\n        return (node.nodeName || \"\").toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return \"#document\";\n}\nfunction getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n    if (!hasWindow()) {\n        return false;\n    }\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n    if (!hasWindow() || typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/ new Set([\n    \"inline\",\n    \"contents\"\n]);\nfunction isOverflowElement(element) {\n    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/ new Set([\n    \"table\",\n    \"td\",\n    \"th\"\n]);\nfunction isTableElement(element) {\n    return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [\n    \":popover-open\",\n    \":modal\"\n];\nfunction isTopLayer(element) {\n    return topLayerSelectors.some((selector)=>{\n        try {\n            return element.matches(selector);\n        } catch (_e) {\n            return false;\n        }\n    });\n}\nconst transformProperties = [\n    \"transform\",\n    \"translate\",\n    \"scale\",\n    \"rotate\",\n    \"perspective\"\n];\nconst willChangeValues = [\n    \"transform\",\n    \"translate\",\n    \"scale\",\n    \"rotate\",\n    \"perspective\",\n    \"filter\"\n];\nconst containValues = [\n    \"paint\",\n    \"layout\",\n    \"strict\",\n    \"content\"\n];\nfunction isContainingBlock(elementOrCss) {\n    const webkit = isWebKit();\n    const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n    return transformProperties.some((value)=>css[value] ? css[value] !== \"none\" : false) || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || willChangeValues.some((value)=>(css.willChange || \"\").includes(value)) || containValues.some((value)=>(css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else if (isTopLayer(currentNode)) {\n            return null;\n        }\n        currentNode = getParentNode(currentNode);\n    }\n    return null;\n}\nfunction isWebKit() {\n    if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n    return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nconst lastTraversableNodeNames = /*#__PURE__*/ new Set([\n    \"html\",\n    \"body\",\n    \"#document\"\n]);\nfunction isLastTraversableNode(node) {\n    return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.scrollX,\n        scrollTop: element.scrollY\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    const result = // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n        return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n        list = [];\n    }\n    if (traverseIframes === void 0) {\n        traverseIframes = true;\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n        const frameElement = getFrameElement(win);\n        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBO0lBQ1AsT0FBTyxnQkFBa0I7QUFDM0I7QUFDQSxTQUFTQyxZQUFZQyxJQUFJO0lBQ3ZCLElBQUlDLE9BQU9ELE9BQU87UUFDaEIsT0FBTyxDQUFDQSxLQUFLRSxRQUFRLElBQUksRUFBQyxFQUFHQyxXQUFXO0lBQzFDO0lBQ0Esd0VBQXdFO0lBQ3hFLHNEQUFzRDtJQUN0RCx5REFBeUQ7SUFDekQsT0FBTztBQUNUO0FBQ0EsU0FBU0MsVUFBVUosSUFBSTtJQUNyQixJQUFJSztJQUNKLE9BQU8sQ0FBQ0wsUUFBUSxRQUFRLENBQUNLLHNCQUFzQkwsS0FBS00sYUFBYSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxvQkFBb0JFLFdBQVcsS0FBS0M7QUFDNUg7QUFDQSxTQUFTQyxtQkFBbUJULElBQUk7SUFDOUIsSUFBSVU7SUFDSixPQUFPLENBQUNBLE9BQU8sQ0FBQ1QsT0FBT0QsUUFBUUEsS0FBS00sYUFBYSxHQUFHTixLQUFLVyxRQUFRLEtBQUtILE9BQU9HLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSUQsS0FBS0UsZUFBZTtBQUNoSTtBQUNBLFNBQVNYLE9BQU9ZLEtBQUs7SUFDbkIsSUFBSSxDQUFDZixhQUFhO1FBQ2hCLE9BQU87SUFDVDtJQUNBLE9BQU9lLGlCQUFpQkMsUUFBUUQsaUJBQWlCVCxVQUFVUyxPQUFPQyxJQUFJO0FBQ3hFO0FBQ0EsU0FBU0MsVUFBVUYsS0FBSztJQUN0QixJQUFJLENBQUNmLGFBQWE7UUFDaEIsT0FBTztJQUNUO0lBQ0EsT0FBT2UsaUJBQWlCRyxXQUFXSCxpQkFBaUJULFVBQVVTLE9BQU9HLE9BQU87QUFDOUU7QUFDQSxTQUFTQyxjQUFjSixLQUFLO0lBQzFCLElBQUksQ0FBQ2YsYUFBYTtRQUNoQixPQUFPO0lBQ1Q7SUFD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QUFFQyxlQUFlO0lBQ3ZELElBQUlDO0lBQ0osSUFBSUYsU0FBUyxLQUFLLEdBQUc7UUFDbkJBLE9BQU8sRUFBRTtJQUNYO0lBQ0EsSUFBSUMsb0JBQW9CLEtBQUssR0FBRztRQUM5QkEsa0JBQWtCO0lBQ3BCO0lBQ0EsTUFBTUUscUJBQXFCTiwyQkFBMkJ0RTtJQUN0RCxNQUFNNkUsU0FBU0QsdUJBQXdCLEVBQUNELHVCQUF1QjNFLEtBQUtNLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSXFFLHFCQUFxQkosSUFBSTtJQUMvSCxNQUFNTyxNQUFNMUUsVUFBVXdFO0lBQ3RCLElBQUlDLFFBQVE7UUFDVixNQUFNRSxlQUFlQyxnQkFBZ0JGO1FBQ3JDLE9BQU9MLEtBQUtRLE1BQU0sQ0FBQ0gsS0FBS0EsSUFBSUksY0FBYyxJQUFJLEVBQUUsRUFBRTNELGtCQUFrQnFELHNCQUFzQkEscUJBQXFCLEVBQUUsRUFBRUcsZ0JBQWdCTCxrQkFBa0JGLHFCQUFxQk8sZ0JBQWdCLEVBQUU7SUFDOUw7SUFDQSxPQUFPTixLQUFLUSxNQUFNLENBQUNMLG9CQUFvQkoscUJBQXFCSSxvQkFBb0IsRUFBRSxFQUFFRjtBQUN0RjtBQUNBLFNBQVNNLGdCQUFnQkYsR0FBRztJQUMxQixPQUFPQSxJQUFJSyxNQUFNLElBQUlDLE9BQU9DLGNBQWMsQ0FBQ1AsSUFBSUssTUFBTSxJQUFJTCxJQUFJQyxZQUFZLEdBQUc7QUFDOUU7QUFFZ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZ3QtY2xpbmljLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanM/MjRlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvLyBNb2NrZWQgbm9kZXMgaW4gdGVzdGluZyBlbnZpcm9ubWVudHMgbWF5IG5vdCBiZSBpbnN0YW5jZXMgb2YgTm9kZS4gQnlcbiAgLy8gcmV0dXJuaW5nIGAjZG9jdW1lbnRgIGFuIGluZmluaXRlIGxvb3Agd29uJ3Qgb2NjdXIuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjMxN1xuICByZXR1cm4gJyNkb2N1bWVudCc7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIChub2RlID09IG51bGwgfHwgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIChfcmVmID0gKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuTm9kZTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkgfHwgdHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5jb25zdCBpbnZhbGlkT3ZlcmZsb3dEaXNwbGF5VmFsdWVzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydpbmxpbmUnLCAnY29udGVudHMnXSk7XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZLFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIWludmFsaWRPdmVyZmxvd0Rpc3BsYXlWYWx1ZXMuaGFzKGRpc3BsYXkpO1xufVxuY29uc3QgdGFibGVFbGVtZW50cyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsndGFibGUnLCAndGQnLCAndGgnXSk7XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiB0YWJsZUVsZW1lbnRzLmhhcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5jb25zdCB0b3BMYXllclNlbGVjdG9ycyA9IFsnOnBvcG92ZXItb3BlbicsICc6bW9kYWwnXTtcbmZ1bmN0aW9uIGlzVG9wTGF5ZXIoZWxlbWVudCkge1xuICByZXR1cm4gdG9wTGF5ZXJTZWxlY3RvcnMuc29tZShzZWxlY3RvciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IHRyYW5zZm9ybVByb3BlcnRpZXMgPSBbJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJywgJ3BlcnNwZWN0aXZlJ107XG5jb25zdCB3aWxsQ2hhbmdlVmFsdWVzID0gWyd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlJywgJ3NjYWxlJywgJ3JvdGF0ZScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXTtcbmNvbnN0IGNvbnRhaW5WYWx1ZXMgPSBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddO1xuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudE9yQ3NzKSB7XG4gIGNvbnN0IHdlYmtpdCA9IGlzV2ViS2l0KCk7XG4gIGNvbnN0IGNzcyA9IGlzRWxlbWVudChlbGVtZW50T3JDc3MpID8gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50T3JDc3MpIDogZWxlbWVudE9yQ3NzO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdHJhbnNmb3Jtcy0yLyNpbmRpdmlkdWFsLXRyYW5zZm9ybXNcbiAgcmV0dXJuIHRyYW5zZm9ybVByb3BlcnRpZXMuc29tZSh2YWx1ZSA9PiBjc3NbdmFsdWVdID8gY3NzW3ZhbHVlXSAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IChjc3MuY29udGFpbmVyVHlwZSA/IGNzcy5jb250YWluZXJUeXBlICE9PSAnbm9ybWFsJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuYmFja2Ryb3BGaWx0ZXIgPyBjc3MuYmFja2Ryb3BGaWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuZmlsdGVyID8gY3NzLmZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IHdpbGxDaGFuZ2VWYWx1ZXMuc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgY29udGFpblZhbHVlcy5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKGlzVG9wTGF5ZXIoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5jb25zdCBsYXN0VHJhdmVyc2FibGVOb2RlTmFtZXMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXSk7XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbGFzdFRyYXZlcnNhYmxlTm9kZU5hbWVzLmhhcyhnZXROb2RlTmFtZShub2RlKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICBjb25zdCBmcmFtZUVsZW1lbnQgPSBnZXRGcmFtZUVsZW1lbnQod2luKTtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgZnJhbWVFbGVtZW50ICYmIHRyYXZlcnNlSWZyYW1lcyA/IGdldE92ZXJmbG93QW5jZXN0b3JzKGZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQod2luKSB7XG4gIHJldHVybiB3aW4ucGFyZW50ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih3aW4ucGFyZW50KSA/IHdpbi5mcmFtZUVsZW1lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBnZXRDb250YWluaW5nQmxvY2ssIGdldERvY3VtZW50RWxlbWVudCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNUb3BMYXllciwgaXNXZWJLaXQgfTtcbiJdLCJuYW1lcyI6WyJoYXNXaW5kb3ciLCJnZXROb2RlTmFtZSIsIm5vZGUiLCJpc05vZGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0V2luZG93IiwiX25vZGUkb3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImdldERvY3VtZW50RWxlbWVudCIsIl9yZWYiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInZhbHVlIiwiTm9kZSIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NoYWRvd1Jvb3QiLCJTaGFkb3dSb290IiwiaW52YWxpZE92ZXJmbG93RGlzcGxheVZhbHVlcyIsIlNldCIsImlzT3ZlcmZsb3dFbGVtZW50IiwiZWxlbWVudCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZGlzcGxheSIsImdldENvbXB1dGVkU3R5bGUiLCJ0ZXN0IiwiaGFzIiwidGFibGVFbGVtZW50cyIsImlzVGFibGVFbGVtZW50IiwidG9wTGF5ZXJTZWxlY3RvcnMiLCJpc1RvcExheWVyIiwic29tZSIsInNlbGVjdG9yIiwibWF0Y2hlcyIsIl9lIiwidHJhbnNmb3JtUHJvcGVydGllcyIsIndpbGxDaGFuZ2VWYWx1ZXMiLCJjb250YWluVmFsdWVzIiwiaXNDb250YWluaW5nQmxvY2siLCJlbGVtZW50T3JDc3MiLCJ3ZWJraXQiLCJpc1dlYktpdCIsImNzcyIsImNvbnRhaW5lclR5cGUiLCJiYWNrZHJvcEZpbHRlciIsImZpbHRlciIsIndpbGxDaGFuZ2UiLCJpbmNsdWRlcyIsImNvbnRhaW4iLCJnZXRDb250YWluaW5nQmxvY2siLCJjdXJyZW50Tm9kZSIsImdldFBhcmVudE5vZGUiLCJpc0xhc3RUcmF2ZXJzYWJsZU5vZGUiLCJDU1MiLCJzdXBwb3J0cyIsImxhc3RUcmF2ZXJzYWJsZU5vZGVOYW1lcyIsImdldE5vZGVTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJyZXN1bHQiLCJhc3NpZ25lZFNsb3QiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yIiwiYm9keSIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwibGlzdCIsInRyYXZlcnNlSWZyYW1lcyIsIl9ub2RlJG93bmVyRG9jdW1lbnQyIiwic2Nyb2xsYWJsZUFuY2VzdG9yIiwiaXNCb2R5Iiwid2luIiwiZnJhbWVFbGVtZW50IiwiZ2V0RnJhbWVFbGVtZW50IiwiY29uY2F0IiwidmlzdWFsVmlld3BvcnQiLCJwYXJlbnQiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */ const sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst alignments = [\n    \"start\",\n    \"end\"\n];\nconst placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v)=>({\n        x: v,\n        y: v\n    });\nconst oppositeSideMap = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction clamp(start, value, end) {\n    return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n    return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nconst yAxisSides = /*#__PURE__*/ new Set([\n    \"top\",\n    \"bottom\"\n]);\nfunction getSideAxis(placement) {\n    return yAxisSides.has(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const length = getAxisLength(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [\n        mainAlignmentSide,\n        getOppositePlacement(mainAlignmentSide)\n    ];\n}\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = [\n    \"left\",\n    \"right\"\n];\nconst rlPlacement = [\n    \"right\",\n    \"left\"\n];\nconst tbPlacement = [\n    \"top\",\n    \"bottom\"\n];\nconst btPlacement = [\n    \"bottom\",\n    \"top\"\n];\nfunction getSideList(side, isStart, rtl) {\n    switch(side){\n        case \"top\":\n        case \"bottom\":\n            if (rtl) return isStart ? rlPlacement : lrPlacement;\n            return isStart ? lrPlacement : rlPlacement;\n        case \"left\":\n        case \"right\":\n            return isStart ? tbPlacement : btPlacement;\n        default:\n            return [];\n    }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    const alignment = getAlignment(placement);\n    let list = getSideList(getSide(placement), direction === \"start\", rtl);\n    if (alignment) {\n        list = list.map((side)=>side + \"-\" + alignment);\n        if (flipAlignment) {\n            list = list.concat(list.map(getOppositeAlignmentPlacement));\n        }\n    }\n    return list;\n}\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getPaddingObject(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    const { x, y, width, height } = rect;\n    return {\n        width,\n        height,\n        top: y,\n        left: x,\n        right: x + width,\n        bottom: y + height,\n        x,\n        y\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUVELE1BQU1BLFFBQVE7SUFBQztJQUFPO0lBQVM7SUFBVTtDQUFPO0FBQ2hELE1BQU1DLGFBQWE7SUFBQztJQUFTO0NBQU07QUFDbkMsTUFBTUMsYUFBYSxXQUFXLEdBQUVGLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxJQUFJRSxNQUFNLENBQUNELE1BQU1BLE9BQU8sTUFBTUosVUFBVSxDQUFDLEVBQUUsRUFBRUksT0FBTyxNQUFNSixVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDeEksTUFBTU0sTUFBTUMsS0FBS0QsR0FBRztBQUNwQixNQUFNRSxNQUFNRCxLQUFLQyxHQUFHO0FBQ3BCLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7QUFDeEIsTUFBTUMsUUFBUUgsS0FBS0csS0FBSztBQUN4QixNQUFNQyxlQUFlQyxDQUFBQSxJQUFNO1FBQ3pCQyxHQUFHRDtRQUNIRSxHQUFHRjtJQUNMO0FBQ0EsTUFBTUcsa0JBQWtCO0lBQ3RCQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxLQUFLO0FBQ1A7QUFDQSxNQUFNQyx1QkFBdUI7SUFDM0JDLE9BQU87SUFDUEMsS0FBSztBQUNQO0FBQ0EsU0FBU0MsTUFBTUYsS0FBSyxFQUFFRyxLQUFLLEVBQUVGLEdBQUc7SUFDOUIsT0FBT2QsSUFBSWEsT0FBT2YsSUFBSWtCLE9BQU9GO0FBQy9CO0FBQ0EsU0FBU0csU0FBU0QsS0FBSyxFQUFFRSxLQUFLO0lBQzVCLE9BQU8sT0FBT0YsVUFBVSxhQUFhQSxNQUFNRSxTQUFTRjtBQUN0RDtBQUNBLFNBQVNHLFFBQVFDLFNBQVM7SUFDeEIsT0FBT0EsVUFBVUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDO0FBQ0EsU0FB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LE9BQU87SUFDWjtBQUNGO0FBQ0EsU0FBU0MsaUJBQWlCRCxPQUFPO0lBQy9CLE9BQU8sT0FBT0EsWUFBWSxXQUFXRCxvQkFBb0JDLFdBQVc7UUFDbEU5QyxLQUFLOEM7UUFDTGhELE9BQU9nRDtRQUNQL0MsUUFBUStDO1FBQ1JqRCxNQUFNaUQ7SUFDUjtBQUNGO0FBQ0EsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzVCLE1BQU0sRUFDSnZELENBQUMsRUFDREMsQ0FBQyxFQUNEdUQsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBR0Y7SUFDSixPQUFPO1FBQ0xDO1FBQ0FDO1FBQ0FuRCxLQUFLTDtRQUNMRSxNQUFNSDtRQUNOSSxPQUFPSixJQUFJd0Q7UUFDWG5ELFFBQVFKLElBQUl3RDtRQUNaekQ7UUFDQUM7SUFDRjtBQUNGO0FBRXlXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmd0LWNsaW5pYy8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5tanM/NWFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5jb25zdCB5QXhpc1NpZGVzID0gLyojX19QVVJFX18qL25ldyBTZXQoWyd0b3AnLCAnYm90dG9tJ10pO1xuZnVuY3Rpb24gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiB5QXhpc1NpZGVzLmhhcyhnZXRTaWRlKHBsYWNlbWVudCkpID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGdldE9wcG9zaXRlQXhpcyhnZXRTaWRlQXhpcyhwbGFjZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCkge1xuICBpZiAocnRsID09PSB2b2lkIDApIHtcbiAgICBydGwgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgbGV0IG1haW5BbGlnbm1lbnRTaWRlID0gYWxpZ25tZW50QXhpcyA9PT0gJ3gnID8gYWxpZ25tZW50ID09PSAocnRsID8gJ2VuZCcgOiAnc3RhcnQnKSA/ICdyaWdodCcgOiAnbGVmdCcgOiBhbGlnbm1lbnQgPT09ICdzdGFydCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICBpZiAocmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPiByZWN0cy5mbG9hdGluZ1tsZW5ndGhdKSB7XG4gICAgbWFpbkFsaWdubWVudFNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSk7XG4gIH1cbiAgcmV0dXJuIFttYWluQWxpZ25tZW50U2lkZSwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpXTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgY29uc3Qgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGFsaWdubWVudCA9PiBvcHBvc2l0ZUFsaWdubWVudE1hcFthbGlnbm1lbnRdKTtcbn1cbmNvbnN0IGxyUGxhY2VtZW50ID0gWydsZWZ0JywgJ3JpZ2h0J107XG5jb25zdCBybFBsYWNlbWVudCA9IFsncmlnaHQnLCAnbGVmdCddO1xuY29uc3QgdGJQbGFjZW1lbnQgPSBbJ3RvcCcsICdib3R0b20nXTtcbmNvbnN0IGJ0UGxhY2VtZW50ID0gWydib3R0b20nLCAndG9wJ107XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybFBsYWNlbWVudCA6IGxyUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsclBsYWNlbWVudCA6IHJsUGxhY2VtZW50O1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGJQbGFjZW1lbnQgOiBidFBsYWNlbWVudDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiJdLCJuYW1lcyI6WyJzaWRlcyIsImFsaWdubWVudHMiLCJwbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwic2lkZSIsImNvbmNhdCIsIm1pbiIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImZsb29yIiwiY3JlYXRlQ29vcmRzIiwidiIsIngiLCJ5Iiwib3Bwb3NpdGVTaWRlTWFwIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwidG9wIiwib3Bwb3NpdGVBbGlnbm1lbnRNYXAiLCJzdGFydCIsImVuZCIsImNsYW1wIiwidmFsdWUiLCJldmFsdWF0ZSIsInBhcmFtIiwiZ2V0U2lkZSIsInBsYWNlbWVudCIsInNwbGl0IiwiZ2V0QWxpZ25tZW50IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiYXhpcyIsImdldEF4aXNMZW5ndGgiLCJ5QXhpc1NpZGVzIiwiU2V0IiwiZ2V0U2lkZUF4aXMiLCJoYXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJyZWN0cyIsInJ0bCIsImFsaWdubWVudCIsImFsaWdubWVudEF4aXMiLCJsZW5ndGgiLCJtYWluQWxpZ25tZW50U2lkZSIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwicmVwbGFjZSIsImxyUGxhY2VtZW50IiwicmxQbGFjZW1lbnQiLCJ0YlBsYWNlbWVudCIsImJ0UGxhY2VtZW50IiwiZ2V0U2lkZUxpc3QiLCJpc1N0YXJ0IiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsImZsaXBBbGlnbm1lbnQiLCJkaXJlY3Rpb24iLCJsaXN0IiwibWFwIiwiZXhwYW5kUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ })

};
;